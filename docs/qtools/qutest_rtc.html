<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QTools: Run-to-Completion Processing</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
  <a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">
    <img id="logo" src="img/logo_ql.png" alt="Quantum Leaps">
  </a>
  <span id="projectname">QTools</span>
  <span id="projectnumber">6.9.3</span>
           <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)"
               onblur="searchBox.OnSearchFieldFocus(false)"
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;"
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('qutest_rtc.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0"
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Run-to-Completion Processing </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#qutest_reset">Target Reset</a></li>
<li class="level1"><a href="#qutest_pause">Pausing the Reset</a></li>
<li class="level1"><a href="#qutest_noreset">NORESET Tests</a></li>
<li class="level1"><a href="#qutest_assert">Assertion Test</a></li>
<li class="level1"><a href="#qutest_simple">Simple Commands</a></li>
<li class="level1"><a href="#qutest_complex">Complex Commands</a></li>
</ul>
</div>
<div class="textblock"><p>The central concept applied in QUTest is <b>Run-to-Completion (RTC)</b> processing, both in the <em>test fixture</em> (Target) and in the <em>test script</em> (Host). RTC processing means that the code progresses in discrete, uninterruptible steps and that new inputs (commands) are recognized only <em>after</em> the current RTC step completes. </p>
<dl class="section attention"><dt>Attention</dt><dd>RTC Processing is the key to understanding <b>how much output to expect from any given input</b> as well as <b>when a given input will be processed</b>.</dd></dl>
<p>Of course, it is not a coincidence that the RTC processing of QUTest matches exactly the RTC processing in event-driven systems of state machines. And the good news here is that for all interactions with state machines, the RTC output generated by a <em>test fixture</em> will correspond exactly to the RTC step in the state machine.</p>
<p>However, a bit more tricky parts are the system reset, test initialization, and general processing of commands issued by <em>test scripts</em>. The following sections explain these parts by means of annotated sequence diagrams.</p>
<dl class="section remark"><dt>Remarks</dt><dd>For simplicity, the sequence diagrams in this section omit the QSPY intermediary from the communication between a <em>test fixture</em> (Target) and a <em>test script</em>. It is understood that every command from the <em>test script</em> goes to QSPY first and then is forwarded to the Target, and that every output from the Target goes through QSPY to reach the <em>test script</em>.</dd></dl>
<h1><a class="anchor" id="qutest_reset"></a>
Target Reset</h1>
<p>Most individual tests in a <em>test script</em>, start with a clean <b>target reset</b>. The following sequence diagram shows the details of this process. The explanation section following the diagram clarifies the interesting points (labeled with <code>[xx]</code>). :</p>
<p><img src="qutest_reset.gif" alt="" class="inline" title="Target reset"/></p>
<dl class="tag">
<dt>0</dt>
<dd>A <em>test script</em> executes the <a class="el" href="namespacequtest__dsl.html#a428afa0df76f435f6a7b3c201bdb846c" title="start a new test">test()</a> command.  </dd>
<dt>1</dt>
<dd>By default, each test starts with calling an internal function reset() to reset the Target. This reset() function sends the <code>QS_RX_RESET</code> request to the <em>test fixture</em>. After this, the <em>test script</em> enters a wait state in which it waits for <code>QS_TARGET_INFO</code> reply from the Target.  <blockquote class="doxtable">
<p><b>NOTE:</b> The Target reset can be suppressed by the <code>NORESET</code> option given in the <a class="el" href="namespacequtest__dsl.html#a428afa0df76f435f6a7b3c201bdb846c" title="start a new test">test()</a> command, which is illustrated in the <a class="el" href="qutest_rtc.html#qutest_noreset">NORESET Tests</a> sequence diagram. Please note, however, that the first test in a <em>test script</em> (test group) and any test immediately following an "assertion-test" <b>must</b> cleanly reset the Target (so it cannot use the <code>NORESET</code> option). </p>
</blockquote>
</dd>
<dt>2</dt>
<dd>The <em>test fixture</em> processes the <a class="el" href="qs__copy_8h.html#abf73d66c1a2a355d50741e010f11b026a1a4d50e5e36c7b56b96f85df286c6c18" title="reset the Target">QS_RX_RESET</a> request immediately by calling the <a class="el" href="qs__copy_8h.html#a0ee7523f0496d2ab2039be40a7fc57dd" title="Callback function to reset the Target (to be implemented in the BSP)">QS_onReset()</a> callback inside the Target.  <blockquote class="doxtable">
<p><b>NOTE:</b> Embedded Targets reboot automatically after resetting. In case of a <b>host executable</b>, however, QUTest&trade; (qutest.py) launches it again.<br  />
</p>
</blockquote>
</dd>
<dt>3</dt>
<dd>The Target starts executing the <em>test fixture</em> code from the beginning. After QS gets initialized (<a class="el" href="qs__copy_8h.html#af22371611fe57862a37eb785debb7921" title="Initialize the QS facility.">QS_INIT()</a>), the <em>test fixture</em> sends the <code>QS_TARGET_INFO</code> reply to the <em>test script</em>.  </dd>
<dt>4</dt>
<dd>Upon reception of the awaited <code>QS_TARGET_INFO</code> reply, the <em>test script</em> attempts to execute the <code><a class="el" href="namespacequtest__dsl.html#aa40735b0e2865f928331d30798090ee2" title="callback function invoked after each Target reset">on_reset()</a></code> procedure. If <code><a class="el" href="namespacequtest__dsl.html#aa40735b0e2865f928331d30798090ee2" title="callback function invoked after each Target reset">on_reset()</a></code> is defined in the script, it runs at this time. (This scenario assumes that <code><a class="el" href="namespacequtest__dsl.html#aa40735b0e2865f928331d30798090ee2" title="callback function invoked after each Target reset">on_reset()</a></code> is defined and runs until step [8]).  </dd>
<dt>5</dt>
<dd>A <em>test fixture</em> continues the initialization RTC step and typically produces some <a class="el" href="qs.html#qs_dict">QS dictionaries</a>.  <blockquote class="doxtable">
<p><b>NOTE:</b> The <a class="el" href="qs.html#qs_dict">QS dictionaries</a> are consumed by QSPY and are <b>not</b> forwarded to the <em>test script</em>. </p>
</blockquote>
</dd>
<dt>6</dt>
<dd>The <em>test fixture</em> might also produce some output that <b>is</b> forwarded to the <em>test script</em>.  </dd>
<dt>7</dt>
<dd>Any such output needs to be explicitly expected by the <em>test script</em>. The <code><a class="el" href="namespacequtest__dsl.html#aa40735b0e2865f928331d30798090ee2" title="callback function invoked after each Target reset">on_reset()</a></code> procedure is the ideal place to handle such output.  <blockquote class="doxtable">
<p><b>NOTE:</b> The main purpose of the <code><a class="el" href="namespacequtest__dsl.html#aa40735b0e2865f928331d30798090ee2" title="callback function invoked after each Target reset">on_reset()</a></code> procedure is to consume any output generated during the reset RTC step as well as to perform any setup that should follow the Target reset. In principle, instead of coding <code><a class="el" href="namespacequtest__dsl.html#aa40735b0e2865f928331d30798090ee2" title="callback function invoked after each Target reset">on_reset()</a></code>, you could place all this code directly at every test, but this would be repetitious and defining <code><a class="el" href="namespacequtest__dsl.html#aa40735b0e2865f928331d30798090ee2" title="callback function invoked after each Target reset">on_reset()</a></code> allows you to avoid such repetitions. </p>
</blockquote>
</dd>
<dt>8</dt>
<dd>The <code><a class="el" href="namespacequtest__dsl.html#aa40735b0e2865f928331d30798090ee2" title="callback function invoked after each Target reset">on_reset()</a></code> procedure ends and the <em>test script</em> sends <code>QS_RX_TEST_SETUP</code> to the Target.  </dd>
<dt>9</dt>
<dd><code>QS_RX_TEST_SETUP</code> typically arrives while the <em>test fixture</em> still runs the initialization RTC. Therefore, <code>QS_RX_TEST_SETUP</code> is <b>not</b> processed immediately and its processing is delayed until the end of the current RTC step.  </dd>
<dt>10</dt>
<dd>A <em>test fixture</em> continues the initialization RTC step and might still produce some <a class="el" href="qs.html#qs_dict">QS dictionaries</a>.  </dd>
<dt>11</dt>
<dd>Finally, the <em>test fixture</em> completes the initialization RTC by calling <code>QF_run()</code>. <code>QF_run()</code> runs an event loop, in which it processes commands that have accumulated from the <em>test script</em>.  </dd>
<dt>12</dt>
<dd>The first such command is <code>QS_RX_TEST_SETUP</code>, which has been waiting in the input buffer.  </dd>
<dt>13</dt>
<dd>The acknowledgement for the <code>QS_RX_TEST_SETUP</code> is sent back to the <em>test script</em>  </dd>
<dt>14</dt>
<dd>Upon reception of <code>Trg-Ack QS_RX_TEST_SETUP</code>, the <em>test script</em> attempts to execute the <code><a class="el" href="namespacequtest__dsl.html#a72c6919e936aff35c5a88dc715bde8a0" title="callback function invoked at the beginning of each test">on_setup()</a></code> procedure. If <code><a class="el" href="namespacequtest__dsl.html#a72c6919e936aff35c5a88dc715bde8a0" title="callback function invoked at the beginning of each test">on_setup()</a></code> is defined in the script, it runs at this time.  <blockquote class="doxtable">
<p><b>NOTE:</b> The main purpose of the <code><a class="el" href="namespacequtest__dsl.html#a72c6919e936aff35c5a88dc715bde8a0" title="callback function invoked at the beginning of each test">on_setup()</a></code> procedure is to consume any output generated from the <code><a class="el" href="qs__copy_8h.html#a3d316077c13f8033c1a391590937e696" title="callback to setup a unit test inside the Target">QS_onTestSetup()</a></code> callback in the <em>test fixture</em> invoked in the next step [15]. Note also the <code><a class="el" href="qs__copy_8h.html#a3d316077c13f8033c1a391590937e696" title="callback to setup a unit test inside the Target">QS_onTestSetup()</a></code> runs in all tests, including <a class="el" href="qutest_rtc.html#qutest_noreset">NORESET tests</a>. </p>
</blockquote>
</dd>
<dt>15</dt>
<dd>The <em>test fixture</em> calls the <code><a class="el" href="qs__copy_8h.html#a3d316077c13f8033c1a391590937e696" title="callback to setup a unit test inside the Target">QS_onTestSetup()</a></code> callback function in the Target.  </dd>
<dt>16</dt>
<dd>The <em>test script</em> proceeds with commands defined after the <a class="el" href="namespacequtest__dsl.html#a428afa0df76f435f6a7b3c201bdb846c" title="start a new test">test()</a> command. Processing of these commands is explained in sections <a class="el" href="qutest_rtc.html#qutest_simple">Simple Commands</a> and <a class="el" href="qutest_rtc.html#qutest_complex">Complex Commands</a>.  </dd>
</dl>
<div style="clear:both;"></div><h1><a class="anchor" id="qutest_pause"></a>
Pausing the Reset</h1>
<p>As explained in the previous section, the initialization RTC step in the <em>test fixture</em> extends throughout <code><a class="el" href="namespaceqview.html#a0ac274e7bffb2a1b29949100cd43ca35">main()</a></code>, from the beginning till the final call to <code>QF_run()</code>. The <em>test fixture</em> is unable to process any commands from the <em>test script</em> until the end of this long RTC step, which can limit the flexibility of the <em>test fixture</em>.</p>
<p>For example, consider the <em>test fixture</em> in the DPP example for QUTest (directory <span class="img folder"><code>qpc/examples/qutest/dpp/test/</code></span>). This <em>test fixture</em> reuses the <code><a class="el" href="namespaceqview.html#a0ac274e7bffb2a1b29949100cd43ca35">main()</a></code> function from the actual DPP application, which starts multiple active objects. To enable unit testing of a specific single active objects, it would be very convenient if the <em>test script</em> could set up the <a class="el" href="qs.html#qs_local">QS Local Filter</a> for the chosen active object component. Such local filter would then select the output, such as initialization from a given AO. But the problem is that such local filter requires the <a class="el" href="qs.html#qs_dict">QS object dictionary</a> to be already transmitted to QSPY. On the other hand, the local filter needs to take effect before the AOs are started. In other words, the initialization RTC step needs to be split into shorter pieces, right after sending the dictionaries, but before starting active objects.</p>
<p>For such situations, QUTest provides the <a class="el" href="qs__copy_8h.html#ae5841714b4f420c33df0a5132cc3f2c7" title="QS macro to pause test execution and enter the test event loop.">QS_TEST_PAUSE()</a> macro, which pauses the execution of an RTC step and enters an event loop within the <em>test fixture</em>. This, in turn, allows the <em>test fixture</em> to process any commands from the <em>test script</em>, before the RTC continues to completion (or to another <a class="el" href="qs__copy_8h.html#ae5841714b4f420c33df0a5132cc3f2c7" title="QS macro to pause test execution and enter the test event loop.">QS_TEST_PAUSE()</a>, if needed).</p>
<p>The following <em>test fixture</em> code illustrates the use of the <a class="el" href="qs__copy_8h.html#ae5841714b4f420c33df0a5132cc3f2c7" title="QS macro to pause test execution and enter the test event loop.">QS_TEST_PAUSE()</a> macro:</p>
<div class="fragment"><div class="line">    <span class="keywordtype">int</span> <a class="code" href="namespaceqview.html#a0ac274e7bffb2a1b29949100cd43ca35">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div>
<div class="line">        <span class="keyword">static</span> QEvt <span class="keyword">const</span> *tableQueueSto[N_PHILO];</div>
<div class="line">        <span class="keyword">static</span> QEvt <span class="keyword">const</span> *philoQueueSto[N_PHILO][N_PHILO];</div>
<div class="line">        ~ ~ ~</div>
<div class="line"> </div>
<div class="line">        QF_init();    <span class="comment">/* initialize the framework and the underlying RT kernel */</span></div>
<div class="line">        BSP_init(argc, argv); <span class="comment">/* NOTE: calls QS_INIT() */</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* object dictionaries... */</span></div>
<div class="line">        <a class="code" href="qs__copy_8h.html#a034206ff7f20a4e6426a5f554434643b">QS_OBJ_DICTIONARY</a>(AO_Table);</div>
<div class="line">        <a class="code" href="qs__copy_8h.html#a034206ff7f20a4e6426a5f554434643b">QS_OBJ_DICTIONARY</a>(AO_Philo[0]);</div>
<div class="line">        <a class="code" href="qs__copy_8h.html#a034206ff7f20a4e6426a5f554434643b">QS_OBJ_DICTIONARY</a>(AO_Philo[1]);</div>
<div class="line">        <a class="code" href="qs__copy_8h.html#a034206ff7f20a4e6426a5f554434643b">QS_OBJ_DICTIONARY</a>(AO_Philo[2]);</div>
<div class="line">        ~ ~ ~</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* pause execution of the test and wait for the test script to continue */</span></div>
<div class="line">[1]     <a class="code" href="qs__copy_8h.html#ae5841714b4f420c33df0a5132cc3f2c7">QS_TEST_PAUSE</a>();</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* initialize publish-subscribe... */</span></div>
<div class="line">        QF_psInit(subscrSto, Q_DIM(subscrSto));</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* initialize event pools... */</span></div>
<div class="line">        QF_poolInit(smlPoolSto, <span class="keyword">sizeof</span>(smlPoolSto), <span class="keyword">sizeof</span>(smlPoolSto[0]));</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* start the active objects... */</span></div>
<div class="line">        Philo_ctor(); <span class="comment">/* instantiate all Philosopher active objects */</span></div>
<div class="line">        <span class="keywordflow">for</span> (n = 0U; n &lt; N_PHILO; ++n) {</div>
<div class="line">            QACTIVE_START(AO_Philo[n],      <span class="comment">/* AO to start */</span></div>
<div class="line">                     (n + 1),               <span class="comment">/* QP priority of the AO */</span></div>
<div class="line">                     philoQueueSto[n],      <span class="comment">/* event queue storage */</span></div>
<div class="line">                     Q_DIM(philoQueueSto[n]), <span class="comment">/* queue length [events] */</span></div>
<div class="line">                     (<span class="keywordtype">void</span> *)0,             <span class="comment">/* stack storage (not used) */</span></div>
<div class="line">                     0U,                    <span class="comment">/* size of the stack [bytes] */</span></div>
<div class="line">                     (QEvt *)0);            <span class="comment">/* initialization event */</span></div>
<div class="line">        }</div>
<div class="line">        ~ ~ ~</div>
<div class="line"> </div>
<div class="line">[2]     <span class="keywordflow">return</span> QF_run(); <span class="comment">/* run the QF application */</span></div>
<div class="line">    }</div>
<div class="ttc" id="anamespaceqview_html_a0ac274e7bffb2a1b29949100cd43ca35"><div class="ttname"><a href="namespaceqview.html#a0ac274e7bffb2a1b29949100cd43ca35">qview.main</a></div><div class="ttdeci">def main()</div><div class="ttdef"><b>Definition:</b> <a href="qview_8py_source.html#l01832">qview.py:1832</a></div></div>
<div class="ttc" id="aqs__copy_8h_html_a034206ff7f20a4e6426a5f554434643b"><div class="ttname"><a href="qs__copy_8h.html#a034206ff7f20a4e6426a5f554434643b">QS_OBJ_DICTIONARY</a></div><div class="ttdeci">#define QS_OBJ_DICTIONARY(obj_)</div><div class="ttdoc">Output object dictionary record.</div><div class="ttdef"><b>Definition:</b> <a href="qs__copy_8h_source.html#l00779">qs_copy.h:779</a></div></div>
<div class="ttc" id="aqs__copy_8h_html_ae5841714b4f420c33df0a5132cc3f2c7"><div class="ttname"><a href="qs__copy_8h.html#ae5841714b4f420c33df0a5132cc3f2c7">QS_TEST_PAUSE</a></div><div class="ttdeci">#define QS_TEST_PAUSE()</div><div class="ttdoc">QS macro to pause test execution and enter the test event loop.</div><div class="ttdef"><b>Definition:</b> <a href="qs__copy_8h_source.html#l00990">qs_copy.h:990</a></div></div>
</div><!-- fragment --><dl class="tag">
<dt>1</dt>
<dd>The <a class="el" href="qs__copy_8h.html#ae5841714b4f420c33df0a5132cc3f2c7" title="QS macro to pause test execution and enter the test event loop.">QS_TEST_PAUSE()</a> macro pauses the initialization RTC after producing QS dictionaries, but before starting active objects.  </dd>
<dt>2</dt>
<dd>The QF_run() function completes the initialization RTC.  </dd>
</dl>
<div style="clear:both;"></div><p>The following sequence diagram shows the details of pausing a test. The explanation section following the diagram clarifies the interesting points (labeled with <code>[xx]</code>). :</p>
<p><img src="qutest_pause.gif" alt="" class="inline" title="Pausing a test"/></p>
<dl class="tag">
<dt>1</dt>
<dd>The target reset proceeds as before and produces the QS_TARGET_INFO trace record.  </dd>
<dt>2</dt>
<dd>At some point, however, the <em>test fixture</em> executes <b><a class="el" href="qs__copy_8h.html#ae5841714b4f420c33df0a5132cc3f2c7" title="QS macro to pause test execution and enter the test event loop.">QS_TEST_PAUSE()</a></b>, which sends QS_TEST_PAUSED record to the <em>test script</em>. At this point, the <em>test fixture</em> enters the event loop, so the initialization RTC finishes and the <em>test fixture</em> is now responsive to commands.  </dd>
<dt>3</dt>
<dd>At this point, the <em>test script</em> must be explicitily expecting QS_TEST_PAUSE by means of the <a class="el" href="namespacequtest__dsl.html#a24bbc89bd100f363a1988c3690764995" title="defines expectation for a Test Pause">expect_pause()</a> command.  <blockquote class="doxtable">
<p><b>NOTE:</b> The best place to put <a class="el" href="namespacequtest__dsl.html#a24bbc89bd100f363a1988c3690764995" title="defines expectation for a Test Pause">expect_pause()</a> is the <a class="el" href="namespacequtest__dsl.html#aa40735b0e2865f928331d30798090ee2" title="callback function invoked after each Target reset">on_reset()</a> callback function, which should be defined in <em>test scripts</em> corresponding to <em>test fixtures</em> that call <a class="el" href="qs__copy_8h.html#ae5841714b4f420c33df0a5132cc3f2c7" title="QS macro to pause test execution and enter the test event loop.">QS_TEST_PAUSE()</a>. </p>
</blockquote>
</dd>
<dt>4</dt>
<dd>The <a class="el" href="namespacequtest__dsl.html#aa40735b0e2865f928331d30798090ee2" title="callback function invoked after each Target reset">on_reset()</a> callack can now execute commands that are processed <b>immediately</b> in the <em>test fixture</em>.  </dd>
<dt>5</dt>
<dd>Eventually the <a class="el" href="namespacequtest__dsl.html#aa40735b0e2865f928331d30798090ee2" title="callback function invoked after each Target reset">on_reset()</a> callback releases the <em>test fixture</em> from the pause by executing the <a class="el" href="namespacequtest__dsl.html#a511b1ad4434c13c4c70a8e20149cc812" title="sends the CONTINUE packet to the Target to continue a test">continue_test()</a> command. This command sends QS_RX_TEST_CONTINUE to the <em>test fixture</em>.  </dd>
<dt>6</dt>
<dd>Upon reception of QS_RX_TEST_CONTINUE, the <em>test fixture</em> continues the initialization in another RTC step.  </dd>
<dt>7</dt>
<dd>The <a class="el" href="namespacequtest__dsl.html#aa40735b0e2865f928331d30798090ee2" title="callback function invoked after each Target reset">on_reset()</a> callback ends and the test script sends QS_RX_TEST_SETUP to the Target.  </dd>
<dt>8</dt>
<dd>The test proceeds as before.  </dd>
</dl>
<div style="clear:both;"></div><p>The following <em>test script</em> code illustrates the use of the <a class="el" href="namespacequtest__dsl.html#a24bbc89bd100f363a1988c3690764995" title="defines expectation for a Test Pause">expect_pause()</a> and <a class="el" href="namespacequtest__dsl.html#a511b1ad4434c13c4c70a8e20149cc812" title="sends the CONTINUE packet to the Target to continue a test">continue_test()</a> commands:</p>
<div class="fragment"><div class="line">    def <a class="code" href="namespacequtest__dsl.html#aa40735b0e2865f928331d30798090ee2">on_reset</a>():</div>
<div class="line">[1]     <a class="code" href="namespacequtest__dsl.html#a24bbc89bd100f363a1988c3690764995">expect_pause</a>()</div>
<div class="line">[2]     <a class="code" href="namespacequtest__dsl.html#a3ead8e3217c089e463fda6939fce6d9c">glb_filter</a>(<a class="code" href="namespaceqview.html#a7893c5567617f9bdd8f53182f9fb2f28">GRP_SM</a>)</div>
<div class="line">        <a class="code" href="namespacequtest__dsl.html#ac0d43a3ce5873c15dadde9fef0b735ee">loc_filter</a>(OBJ_SM_AO, <span class="stringliteral">&quot;AO_Philo&lt;2&gt;&quot;</span>)</div>
<div class="line">[3]     <a class="code" href="namespacequtest__dsl.html#a511b1ad4434c13c4c70a8e20149cc812">continue_test</a>()</div>
<div class="line">[4]     <a class="code" href="namespacequtest__dsl.html#a0489cc93c36a171881ff0c198e08f4f2">expect</a>(<span class="stringliteral">&quot;===RTC===&gt; St-Init  Obj=AO_Philo&lt;2&gt;,State=QHsm_top-&gt;Philo_thinking&quot;</span>)</div>
<div class="line">        <a class="code" href="namespacequtest__dsl.html#a0489cc93c36a171881ff0c198e08f4f2">expect</a>(<span class="stringliteral">&quot;===RTC===&gt; St-Entry Obj=AO_Philo&lt;2&gt;,State=Philo_thinking&quot;</span>)</div>
<div class="line">        <a class="code" href="namespacequtest__dsl.html#a0489cc93c36a171881ff0c198e08f4f2">expect</a>(<span class="stringliteral">&quot;@timestamp Init===&gt; Obj=AO_Philo&lt;2&gt;,State=Philo_thinking&quot;</span>)</div>
<div class="line">        <a class="code" href="namespacequtest__dsl.html#a3ead8e3217c089e463fda6939fce6d9c">glb_filter</a>(GRP_SM_AO, <a class="code" href="namespaceqview.html#a7dc940afca2fbe1d7df1efd0ece57344">GRP_UA</a>)</div>
<div class="line">        <a class="code" href="namespacequtest__dsl.html#ac890232d1de79547ba5485953f84ac66">current_obj</a>(OBJ_SM_AO, <span class="stringliteral">&quot;AO_Philo&lt;2&gt;&quot;</span>)</div>
<div class="line">    }</div>
<div class="ttc" id="anamespacequtest__dsl_html_a0489cc93c36a171881ff0c198e08f4f2"><div class="ttname"><a href="namespacequtest__dsl.html#a0489cc93c36a171881ff0c198e08f4f2">qutest_dsl.expect</a></div><div class="ttdeci">def expect(match)</div><div class="ttdoc">defines an expectation for the current test</div><div class="ttdef"><b>Definition:</b> <a href="qutest__dsl_8py_source.html#l00174">qutest_dsl.py:174</a></div></div>
<div class="ttc" id="anamespacequtest__dsl_html_a24bbc89bd100f363a1988c3690764995"><div class="ttname"><a href="namespacequtest__dsl.html#a24bbc89bd100f363a1988c3690764995">qutest_dsl.expect_pause</a></div><div class="ttdeci">def expect_pause()</div><div class="ttdoc">defines expectation for a Test Pause</div><div class="ttdef"><b>Definition:</b> <a href="qutest__dsl_8py_source.html#l00363">qutest_dsl.py:363</a></div></div>
<div class="ttc" id="anamespacequtest__dsl_html_a3ead8e3217c089e463fda6939fce6d9c"><div class="ttname"><a href="namespacequtest__dsl.html#a3ead8e3217c089e463fda6939fce6d9c">qutest_dsl.glb_filter</a></div><div class="ttdeci">def glb_filter(*args)</div><div class="ttdoc">Send the QS Global Filter to the Target.</div><div class="ttdef"><b>Definition:</b> <a href="qutest__dsl_8py_source.html#l00212">qutest_dsl.py:212</a></div></div>
<div class="ttc" id="anamespacequtest__dsl_html_a511b1ad4434c13c4c70a8e20149cc812"><div class="ttname"><a href="namespacequtest__dsl.html#a511b1ad4434c13c4c70a8e20149cc812">qutest_dsl.continue_test</a></div><div class="ttdeci">def continue_test()</div><div class="ttdoc">sends the CONTINUE packet to the Target to continue a test</div><div class="ttdef"><b>Definition:</b> <a href="qutest__dsl_8py_source.html#l00394">qutest_dsl.py:394</a></div></div>
<div class="ttc" id="anamespacequtest__dsl_html_aa40735b0e2865f928331d30798090ee2"><div class="ttname"><a href="namespacequtest__dsl.html#aa40735b0e2865f928331d30798090ee2">qutest_dsl.on_reset</a></div><div class="ttdeci">def on_reset()</div><div class="ttdoc">callback function invoked after each Target reset</div><div class="ttdef"><b>Definition:</b> <a href="qutest__dsl_8py_source.html#l00588">qutest_dsl.py:588</a></div></div>
<div class="ttc" id="anamespacequtest__dsl_html_ac0d43a3ce5873c15dadde9fef0b735ee"><div class="ttname"><a href="namespacequtest__dsl.html#ac0d43a3ce5873c15dadde9fef0b735ee">qutest_dsl.loc_filter</a></div><div class="ttdeci">def loc_filter(*args)</div><div class="ttdoc">Send the Local Filter to the Target.</div><div class="ttdef"><b>Definition:</b> <a href="qutest__dsl_8py_source.html#l00239">qutest_dsl.py:239</a></div></div>
<div class="ttc" id="anamespacequtest__dsl_html_ac890232d1de79547ba5485953f84ac66"><div class="ttname"><a href="namespacequtest__dsl.html#ac890232d1de79547ba5485953f84ac66">qutest_dsl.current_obj</a></div><div class="ttdeci">def current_obj(obj_kind, obj_id)</div><div class="ttdoc">Set the Current-Object in the Target.</div><div class="ttdef"><b>Definition:</b> <a href="qutest__dsl_8py_source.html#l00289">qutest_dsl.py:289</a></div></div>
<div class="ttc" id="anamespaceqview_html_a7893c5567617f9bdd8f53182f9fb2f28"><div class="ttname"><a href="namespaceqview.html#a7893c5567617f9bdd8f53182f9fb2f28">qview.GRP_SM</a></div><div class="ttdeci">int GRP_SM</div><div class="ttdef"><b>Definition:</b> <a href="qview_8py_source.html#l01520">qview.py:1520</a></div></div>
<div class="ttc" id="anamespaceqview_html_a7dc940afca2fbe1d7df1efd0ece57344"><div class="ttname"><a href="namespaceqview.html#a7dc940afca2fbe1d7df1efd0ece57344">qview.GRP_UA</a></div><div class="ttdeci">int GRP_UA</div><div class="ttdef"><b>Definition:</b> <a href="qview_8py_source.html#l01532">qview.py:1532</a></div></div>
</div><!-- fragment --><h1><a class="anchor" id="qutest_noreset"></a>
NORESET Tests</h1>
<p>In some tests, you specifically don't want to reset the Target, but rather you want to pick up exactly where the previous test left off. For example, you wish to test a specific state of your state machine, which you reached by dispatching or posting a specific sequence of events to it in the previous tests.</p>
<p>For such tests, you can suppress the target reset by following the <a class="el" href="namespacequtest__dsl.html#a428afa0df76f435f6a7b3c201bdb846c" title="start a new test">test()</a> command with the <b>NORESET</b> option. Such tests are called <a class="el" href="qutest_rtc.html#qutest_noreset">NORESET Tests</a>.</p>
<dl class="section note"><dt>Note</dt><dd>A "-norest Test" is not allowed as the first test of a <em>test group</em> and also not after an <a class="el" href="qutest_rtc.html#qutest_assert">Assertion Test</a>.</dd></dl>
<p>The following sequence diagram shows the details of this process. The explanation section following the diagram clarifies the interesting points (labeled with <code>[xx]</code>). :</p>
<p><img src="qutest_noreset.gif" alt="" class="inline" title="NORESET Test"/></p>
<dl class="tag">
<dt>0</dt>
<dd>The <em>test fixture</em> is done processing commands from any previous test(s) and is running an event loop.  </dd>
<dt>1</dt>
<dd>The <em>test script</em> executes the <a class="el" href="namespacequtest__dsl.html#a428afa0df76f435f6a7b3c201bdb846c">test(..., NORESET)</a> command.  </dd>
<dt>2</dt>
<dd>The <a class="el" href="namespacequtest__dsl.html#a428afa0df76f435f6a7b3c201bdb846c">test(..., NORESET)</a> command sends QS_RX_TEST_SETUP command to the <em>test fixture</em>.  </dd>
<dt>3</dt>
<dd>The <em>test fixture</em> processes QS_RX_TEST_SETUP immediately, because it is running event loop.  </dd>
<dt>4</dt>
<dd>The <em>test fixture</em> responds with Trg-Ack QS_RX_TEST_SETUP.  </dd>
<dt>5</dt>
<dd>Upon reception of Trg-Ack QS_RX_TEST_SETUP, the <em>test script</em> attempts to execute the <a class="el" href="namespacequtest__dsl.html#a72c6919e936aff35c5a88dc715bde8a0" title="callback function invoked at the beginning of each test">on_setup()</a> callback. If <a class="el" href="namespacequtest__dsl.html#a72c6919e936aff35c5a88dc715bde8a0" title="callback function invoked at the beginning of each test">on_setup()</a> is defined in the script, it runs at this time. <blockquote class="doxtable">
<p><b>NOTE</b>: The main purpose of the <a class="el" href="namespacequtest__dsl.html#a72c6919e936aff35c5a88dc715bde8a0" title="callback function invoked at the beginning of each test">on_setup()</a> callback is to consume any output generated from the <a class="el" href="qs__copy_8h.html#a3d316077c13f8033c1a391590937e696" title="callback to setup a unit test inside the Target">QS_onTestSetup()</a> callback in the test fixture invoked in the next step [6]. </p>
</blockquote>
</dd>
<dt>6</dt>
<dd>The <em>test fixture</em> calls the <a class="el" href="qs__copy_8h.html#a3d316077c13f8033c1a391590937e696" title="callback to setup a unit test inside the Target">QS_onTestSetup()</a> callback function in the Target.  </dd>
<dt>7</dt>
<dd>The <em>test script</em> proceeds with commands defined after the <a class="el" href="namespacequtest__dsl.html#a428afa0df76f435f6a7b3c201bdb846c" title="start a new test">test()</a> command. Processing of these commands is explained in sections <a class="el" href="qutest_rtc.html#qutest_simple">Simple Commands</a> and <a class="el" href="qutest_rtc.html#qutest_complex">Complex Commands</a>.  </dd>
</dl>
<div style="clear:both;"></div><h1><a class="anchor" id="qutest_assert"></a>
Assertion Test</h1>
<p>The use of assertions in embedded code (and especially in safety-critical code) is considered one of the <b>best practices</b> and the QP frameworks provide assertion facilities specifically designed for deeply embedded systems.</p>
<p>Assuming that you are using QP assertions in your code, an assertion failure can happen during a unit test. When it happens, the <em>test fixture</em> will produce the non-maskable QS_ASSERT_FAIL trace record. When this record arrives during a regular test, it will not be expected, so the test will fail. This is exactly what you want, because a failing assertion represents an error, which needs to be fixed.</p>
<dl class="section note"><dt>Note</dt><dd>The QP assertion handler Q_onAssert() is defined in the <a class="el" href="qutest_fixture.html#qutest_stub">QUTest Stub</a>. This assertion handler is instrumented to produce the QS_ASSERT_FAIL trace record.</dd></dl>
<p>However, sometimes you exactly want to test the assertion code itself, so you intentionally force an assertion in your test. In that case an assertion failure is expected and the test passes when assertion fails. Such tests are called "Assertion Tests" and QUTest&trade; has been specifically designed to support such tests.</p>
<p>Here is an example of an "Assertion Test":</p>
<div class="fragment"><div class="line"><a class="code" href="namespacequtest__dsl.html#a428afa0df76f435f6a7b3c201bdb846c">test</a>(<span class="stringliteral">&quot;TIMEOUT-&gt;Philo_thinking (ASSERT)&quot;</span>)</div>
<div class="line"><a class="code" href="namespacequtest__dsl.html#a8daad60d8c42f4b8bab8c440b06992a1">probe</a>(&quot;QActive_post_&quot;, 1)</div>
<div class="line"><a class="code" href="namespacequtest__dsl.html#afd0f42ed39bd1f6cdaee1e153176bd34">dispatch</a>(&quot;TIMEOUT_SIG&quot;)</div>
<div class="line"><a class="code" href="namespacequtest__dsl.html#a0489cc93c36a171881ff0c198e08f4f2">expect</a>(&quot;@timestamp Disp===&gt; Obj=AO_Philo&lt;2&gt;,Sig=TIMEOUT_SIG,State=Philo_thinking&quot;)</div>
<div class="line"><a class="code" href="namespacequtest__dsl.html#a0489cc93c36a171881ff0c198e08f4f2">expect</a>(&quot;===RTC===&gt; St-Exit  Obj=AO_Philo&lt;2&gt;,State=Philo_thinking&quot;)</div>
<div class="line"><a class="code" href="namespacequtest__dsl.html#a0489cc93c36a171881ff0c198e08f4f2">expect</a>(&quot;@timestamp TstProbe Fun=QActive_post_,Data=1&quot;)</div>
<div class="line"><a class="code" href="namespacequtest__dsl.html#a0489cc93c36a171881ff0c198e08f4f2">expect</a>(&quot;@timestamp =ASSERT= Mod=qf_actq,Loc=110&quot;)</div>
<div class="ttc" id="anamespacequtest__dsl_html_a428afa0df76f435f6a7b3c201bdb846c"><div class="ttname"><a href="namespacequtest__dsl.html#a428afa0df76f435f6a7b3c201bdb846c">qutest_dsl.test</a></div><div class="ttdeci">def test(title, opt=0)</div><div class="ttdoc">start a new test</div><div class="ttdef"><b>Definition:</b> <a href="qutest__dsl_8py_source.html#l00120">qutest_dsl.py:120</a></div></div>
<div class="ttc" id="anamespacequtest__dsl_html_a8daad60d8c42f4b8bab8c440b06992a1"><div class="ttname"><a href="namespacequtest__dsl.html#a8daad60d8c42f4b8bab8c440b06992a1">qutest_dsl.probe</a></div><div class="ttdeci">def probe(func, data)</div><div class="ttdoc">sends a Test-Probe to the Target</div><div class="ttdef"><b>Definition:</b> <a href="qutest__dsl_8py_source.html#l00505">qutest_dsl.py:505</a></div></div>
<div class="ttc" id="anamespacequtest__dsl_html_afd0f42ed39bd1f6cdaee1e153176bd34"><div class="ttname"><a href="namespacequtest__dsl.html#afd0f42ed39bd1f6cdaee1e153176bd34">qutest_dsl.dispatch</a></div><div class="ttdeci">def dispatch(signal, params=None)</div><div class="ttdoc">dispatch a given event in the current SM object in the Target</div><div class="ttdef"><b>Definition:</b> <a href="qutest__dsl_8py_source.html#l00447">qutest_dsl.py:447</a></div></div>
</div><!-- fragment --><p>As you can see, the test ends with an explicit expectation of an assertion failure: <a class="el" href="namespacequtest__dsl.html#a0489cc93c36a171881ff0c198e08f4f2">expect('@timestamp =ASSERT= Mod=qf_actq,Loc=...')</a>. This is very easy and natural in QUTest.</p>
<dl class="section note"><dt>Note</dt><dd>The only special treatment required here is that a test immediately following an such an "Assertion Test" must necessarily reset the Target (it cannot be a <a class="el" href="qutest_rtc.html#qutest_noreset">NORESET-Test</a>).</dd></dl>
<h1><a class="anchor" id="qutest_simple"></a>
Simple Commands</h1>
<p>Simple <em>test script</em> commands do not produce any output from the Target, except only the "Trg-Ack" (acknowledgement). Examples of <code>&lt;SIMPLE-COMMAND&gt;</code> include <a class="el" href="namespacequtest__dsl.html#a3ead8e3217c089e463fda6939fce6d9c" title="Send the QS Global Filter to the Target.">glb_filter()</a>, <a class="el" href="namespacequtest__dsl.html#ac0d43a3ce5873c15dadde9fef0b735ee" title="Send the Local Filter to the Target.">loc_filter()</a> and <a class="el" href="namespacequtest__dsl.html#ac890232d1de79547ba5485953f84ac66" title="Set the Current-Object in the Target.">current_obj()</a>,</p>
<p><img src="qutest_simple.gif" alt="" class="inline" title="Simple command processing"/></p>
<dl class="tag">
<dt>1</dt>
<dd>A <em>test script</em> sends a <code>&lt;SIMPLE-COMMAND&gt;</code> to the <em>test fixture</em>.  </dd>
<dt>2</dt>
<dd>The <em>test fixture</em> receives the command and immediately starts processing it.  </dd>
<dt>3</dt>
<dd>Processing of a command triggers an RTC step and produces only the "Trg-Ack  &lt;SIMPLE-COMMAND&gt;" (acknowledgement of the specific <code>&lt;SIMPLE-COMMAND&gt;</code>).  </dd>
<dt>4</dt>
<dd>Immediately after sending the <code>&lt;SIMPLE-COMMAND&gt;</code>, the <em>test script</em> enters an implicit expect state, in which it waits for the "Trg-Ack &lt;SIMPLE-COMMAND&gt;" output from the Target. The processing of the <code>&lt;SIMPLE-COMMAND&gt;</code> ends when the next output received from the Target matches exactly the expected output.  </dd>
</dl>
<div style="clear:both;"></div><h1><a class="anchor" id="qutest_complex"></a>
Complex Commands</h1>
<p>Complex <em>test script</em> commands might produce some output from the Target, not just the "Trg-Ack" (acknowledgement). Examples of <code>&lt;COMPLEX-COMMAND&gt;</code> include <a class="el" href="namespacequtest__dsl.html#afd0f42ed39bd1f6cdaee1e153176bd34" title="dispatch a given event in the current SM object in the Target">dispatch()</a>, <a class="el" href="namespacequtest__dsl.html#aa9a8d170b3adbe3fb03db4a199876336" title="post a given event to the current AO object in the Target">post()</a> and <a class="el" href="namespacequtest__dsl.html#a061dff11f10ad3fdf4ca5c8f118e39c1" title="trigger system clock tick in the Target">tick()</a>,</p>
<p><img src="qutest_complex.gif" alt="" class="inline" title="Complex command processing"/></p>
<dl class="tag">
<dt>1</dt>
<dd>A <em>test script</em> sends a <code>&lt;COMPLEX-COMMAND&gt;</code> to the <em>test fixture</em>.  </dd>
<dt>2</dt>
<dd>The <em>test fixture</em> receives the command and immediately starts processing it.  </dd>
<dt>3</dt>
<dd>Processing of a command triggers an RTC step and produces only the "Trg-Ack  &lt;COMPLEX-COMMAND&gt;" (acknowledgement of the specific <code>&lt;COMPLEX-COMMAND&gt;</code>).  </dd>
<dt>4</dt>
<dd>The <code>&lt;COMPLEX-COMMAND&gt;</code> must be followed in the <em>test script</em> by the explicit <a class="el" href="namespacequtest__dsl.html#a0489cc93c36a171881ff0c198e08f4f2" title="defines an expectation for the current test">expect()</a> commands that concume any ouptu produced by the command.  </dd>
<dt>5-6</dt>
<dd>The <em>test fixture</em> produces some output.  </dd>
<dt>7</dt>
<dd>Each such ouput is consumed by the matching <a class="el" href="namespacequtest__dsl.html#a0489cc93c36a171881ff0c198e08f4f2" title="defines an expectation for the current test">expect()</a> command.  </dd>
<dt>8</dt>
<dd>The <em>test fixture</em> sends additional QS record "Trg-Done &lt;COMPLEX-COMMAND&gt;", which explicitly delimits the output from this parricualr command.  </dd>
<dt>8</dt>
<dd>The <em>test script</em> must consume the "Trg-Done &lt;COMPLEX-COMMAND&gt;" record by an explicit <a class="el" href="namespacequtest__dsl.html#a0489cc93c36a171881ff0c198e08f4f2" title="defines an expectation for the current test">expect()</a> command.  </dd>
</dl>
<div style="clear:both;"></div><hr  />
<p><b>Next:</b> <a class="el" href="qutest_tut.html">QUTest&trade; Tutorial</a></p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
    <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
      <ul>
        <li class="footer">
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; 2005-2021 Quantum Leaps</a> &nbsp;| &nbsp; <a title="help" href="help.html">Using Online Help</a>&nbsp;| &nbsp;<a title="Doxygen" href="http://www.doxygen.nl">Generated with Doxygen</a>&nbsp; | &nbsp;<b>QTools 6.9.3</b>
<hr class="footer"/><address class="footer"><small>
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; Quantum Leaps 2020</a> &nbsp;| &nbsp; <a title="help" href="help.html">Using Online Help</a>&nbsp;| &nbsp;<a title="Doxygen" href="http://www.doxygen.nl">Generated with Doxygen</a>&nbsp; | &nbsp;<b>QTools 6.9.3</b>
</small></address>
        </li>
      </ul>
    </div>
    <script src="custom.js"></script>
  </body>
</html>
