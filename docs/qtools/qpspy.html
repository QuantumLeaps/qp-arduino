<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QTools: QP/Spy&trade; Software Tracing</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
  <a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">
    <img id="logo" src="img/logo_ql.png" alt="Quantum Leaps">
  </a>
  <span id="projectname">QTools</span>
  <span id="projectnumber">6.9.3</span>
           <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)"
               onblur="searchBox.OnSearchFieldFocus(false)"
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;"
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('qpspy.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0"
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">QP/Spy&trade; Software Tracing </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><div class="image">
<img src="qspy_banner.jpg" alt=""/>
</div>
<p>In any real-life project, getting the code written, compiled, and successfully linked is only the first step. The system still needs to be tested, validated, and tuned for best performance and resource consumption. A single-step debugger is frequently not helpful because it stops the system and exactly hinders seeing <b>live interactions</b> within the application. Clogging up high-performance code with <code>printf</code> statements is usually too intrusive and simply unworkable in many embedded systems, because <code>printf</code> formatting and output via a serial port happen exactly in the most time-critical paths through the code. </p>
<p>So the questions are: How can you monitor the behavior of a running real-time system without degrading the system itself? How can you discover and document elusive, intermittent bugs that are caused by subtle interactions among concurrent components? How do you design and execute repeatable <a class="el" href="qutest.html">unit tests</a> and <b>integration tests</b> of your system? How do you ensure that a system runs reliably for long periods of time and achieves optimal performance?</p>
<p>Techniques based on <b>software tracing</b> can answer many of these questions. Software tracing is a method for obtaining diagnostic information in a live environment without the need to stop the application to get the system feedback. Software tracing always involves some form of a target system instrumentation to log interesting discrete events for subsequent retrieval from the system and analysis.</p>
<p><a class="anchor" id="qpspy_framework"></a></p><dl class="section note"><dt>Note</dt><dd>Software tracing is particularly effective and powerful in combination with the event-driven <b>reactive programming</b> model, such as the one implemented in <a href="https://www.state-machine.com/products/#QP" class="extern" target="_blank">QP&trade; real-time frameworks</a>. Due to the inversion of a control, a real-time framework controls almost all interesting interactions in the system, so an instrumented real-time framework can provide much more comprehensive and detailed information than any traditional RTOS.</dd></dl>
<h1><a class="anchor" id="ab_about"></a>
What is it?</h1>
<p><b>QP/Spy&trade;</b> is a <a class="el" href="qpspy.html">software tracing and testing system</a> specifically designed for embedded systems, such as single chip microcontrollers. The job of QP/Spy is to capture information about an embedded code's execution and send it to the host computer with minimal impact on the real-time performance of the embedded code.</p>
<div class="image">
<img src="qpspy0.gif" alt=""/>
<div class="caption">
Software tracing data records flowing from Target to the Host</div></div>
<dl class="section remark"><dt>Remarks</dt><dd>QP/Spy can also (optionally) send commands and data <b>to the embedded target</b> (see <a class="el" href="qpspy.html#qpspy_rx">Bi-Directional QP/Spy</a>), which serves as the basis for <a class="el" href="qutest.html">Unit Testing</a> and for <a class="el" href="qview.html">Visualization and Monitoring</a> subsystems of the QP/Spy system.</dd></dl>
<h1><a class="anchor" id="ab_how"></a>
How it works?</h1>
<p>In a nutshell, working with QP/Spy&trade; is similar to peppering the code with <code>printf</code> or similar (like <code>sprintf</code>) statements for logging and debugging, except that QP/Spy&trade; is much less intrusive, more lightweight, portable and <a class="el" href="qs.html#qs_filters">selective</a> than the primitive <code>printf</code>. Additionally, unlike the <code>printf</code> output, the data produced by QP/Spy&trade; contain the data <em>integrity</em> and <em>continuity</em> checks, so the host computer can tell when it receives corrupt data or incomplete data.</p>
<p>The main advantages of the QP/Spy&trade; tracing system over peppering the code with <code>printf</code> statements are:</p>
<ul>
<li>When you use <code>printfs</code>, the data formatting and sending occur in the <em>time-critical</em> paths through the embedded code. In contrast, QP/Spy produces raw <em>binary data</em>, so all the time-consuming formatting is removed from the embedded system and is done after the fact in the host computer.</li>
<li>in QP/Spy, data logging and sending to the host are <b>separated</b> so that the embedded system can typically perform the transmission outside of the time-critical path, for example in the <em>idle processing</em> of the embedded CPU.</li>
<li>Data produced by <code>printf</code> gives you no clue if the data gets corrupted or lost in transmission. In contrast, the <a class="el" href="qpspy_proto.html">QP/Spy transmission protocol</a> checks for data <b>integrity</b> and <b>continuity</b>.</li>
<li>The QP/Spy tracing provides flexible <a class="el" href="qs.html#qs_filters">filtering</a> mechanisms, which allow you to selectively trace only the aspects of the system that you choose and suppress the data that is not interesting at the moment.</li>
<li>The QP/Spy tracing is implemented as macros that are active only in the "Spy" build configuration and are inactive in the Release or Debug build configurations. This means that you can safely leave the instrumentation in the code for future maintenance, development and testing.</li>
<li>The QP/Spy trace data contain precise, high-granularity <b>timestamps</b>, so you can tie the data to the common timeline.</li>
<li>The code size of the <a class="el" href="qs.html">target-resident component</a> in QP/Spy is merely a few hundred bytes, which contrasts with several kilobytes of code required by a full-blown <code>printf</code> formatter.</li>
</ul>
<p>The picture below shows a typical setup for software tracing. The embedded Target system is executing instrumented code, which logs the trace data into a RAM buffer inside the Target. From that buffer the trace data is sent over a data link to a Host computer, which stores, displays, and analyzes the information. This configuration means that a software tracing always requires two components: a "Target resident component" for generating and sending the trace data (<a class="el" href="qs.html">QS</a> in QP/Spy&trade;), and a "Host resident component" to receive, decompress, visualize, and analyze the data (<a class="el" href="qspy.html">QSPY</a> in QP/SPy&trade;).</p>
<div class="image">
<img src="qspy1.gif" alt=""/>
<div class="caption">
Typical setup for software tracing with QP/Spy&trade;</div></div>
<dl class="section note"><dt>Note</dt><dd>Software tracing instrumentation logs interesting discrete events that occur in the target system. These discrete events will be called <b>trace records</b>, to avoid confusing them with the application-level <em>events</em>.</dd></dl>
<p>A good tracing solution, such as QP/Spy, is minimally intrusive, which means that it can provide visibility into the running code with minimal impact on the target system behavior. Properly implemented and used, it will let you diagnose a live system without interrupting or significantly altering the behavior of the system under investigation.</p>
<p>Of course, it's always possible that the overhead of software tracing, no matter how small, will have some effect on the target system behavior, which is known as the <em>probe effect</em> (a.k.a. the "Heisenberg effect"). To help you determine whether that is occurring, you must be able to configure the instrumentation in and out both at compile-time as well as at run-time.</p>
<p>To minimize the "probe effect", a good trace system performs efficient, selective logging of trace records using as little processing and memory resources of the target as possible. Selective logging means that the tracing system provides user-definable, fine granularity filters so that the target-resident component only collects events of interest you can filter as many or as few instrumented events as you need. That way you can make the tracing as noninvasive as necessary.</p>
<p>To minimize the RAM usage, the target-resident trace component typically uses a circular trace buffer that is continuously updated, and new data overwrites the old when the buffer "wraps around" due to limited size or transmission rate to the host. This reflects the typically applied <em>last-is-best</em> policy in collecting the trace data. In order to focus on certain periods of time, software trace provides configurable software triggers that can start and stop trace collection before the new data overwrites the old data of interest in the circular buffer.</p>
<p>To further maximize the amount of data collected in the trace buffer, the Target-resident component typically applies some form of <em>data compression</em> to squeeze more trace information into the buffer and to minimize the bandwidth required to uplink the data to the Host.</p>
<p>However, perhaps the most important characteristic of a flexible software tracing system is the separation of trace logging (<em>what</em> is being traced) from the data transmission mechanism (<em>how</em> and <em>when</em> exactly the data is sent to the Host). This separation of concerns allows the transmissions to occur in the least time-critical paths of the code, such as the <em>idle loop</em>. Also, clients should be able to employ any data transmission mechanism available on the Target, meaning both the physical transport layer (e.g., serial port, SPI, USB, Ethernet, etc.) as well as implementation strategy (polling, interrupt, DMA, etc.). The tracing facility should tolerate and be able to detect any RAM buffer overruns due to bursts of tracing data production rate or insufficient transmission rate to the host.</p>
<p>Finally, the tracing facility must allow consolidating data from all parts of the system, including concurrently executing threads and interrupts. This means that the instrumentation facilities must be <em>reentrant</em> (i.e., both thread-safe and interrupt-safe). Also, to be able to correlate all this data, most tracing systems provide precise <a class="el" href="qs.html#qs_tstamp">time-stamping</a> of the trace records.</p>
<h2><a class="anchor" id="qpspy_rx"></a>
Bi-Directional Connection to the Target</h2>
<p>While traditional software tracing systems support only uni-directional output of trace data from the embedded Target to a Host computer, QP/Spy supports bi-directional communication to the target as well. This capability allows users to send commands and data to the Target and form the basis for <a class="el" href="qutest.html">Unit Testing</a> and <a class="el" href="qview.html">Visualization and Monitoring</a> of embedded Targets.</p>
<div class="image">
<img src="qpspy1.gif" alt=""/>
<div class="caption">
Bi-directional data exchange between the Target and the Host</div></div>
<h2><a class="anchor" id="qpspy_udp"></a>
UDP Socket Extension</h2>
<p>The QP/Spy system provides a <a class="el" href="qspy_udp.html">UDP socket</a>, which is open for communication with various Front-Ends (GUI-based or "headless"). Currently, the UDP connection point is used by the <a class="el" href="qutest.html">QUTest</a> headless (console-based) front-end and GUI-based <a class="el" href="qview.html">QView</a> front-end.</p>
<h2><a class="anchor" id="qpspy_exa"></a>
QP/Spy Session Example</h2>
<p>To give you a better idea how QP/Spy works, the listing below shows an example output from a QP/Spy session. The left-hand side shows the raw, <a class="el" href="qpspy_proto.html">binary output</a> generated by the target-resident component (<a class="el" href="qs.html">QS</a>). The right-hand side shows the <a class="el" href="qspy_text.html">human-readable format</a> generated from the same data by the host-resident component (<a class="el" href="qspy.html">QSPY</a>). The compression ratio between the binary and textual outputs in this data sample is about 3.7.</p>
<div class="image">
<img src="qpspy_exa.png" alt=""/>
<div class="caption">
Example of the QP/Spy output</div></div>
<p>The following sections explain the concepts and components of QP/Spy&trade;:</p><ul>
<li><a class="el" href="qpspy_proto.html">QP/Spy&trade; Data Protocol</a></li>
<li><a class="el" href="qs.html">QS Target Component</a></li>
<li><a class="el" href="qspy.html">QSPY Host Application</a></li>
</ul>
<hr  />
<p><b>Next:</b> <a class="el" href="qpspy_proto.html">QP/Spy&trade; Data Protocol</a></p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
    <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
      <ul>
        <li class="footer">
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; 2005-2021 Quantum Leaps</a> &nbsp;| &nbsp; <a title="help" href="help.html">Using Online Help</a>&nbsp;| &nbsp;<a title="Doxygen" href="http://www.doxygen.nl">Generated with Doxygen</a>&nbsp; | &nbsp;<b>QTools 6.9.3</b>
<hr class="footer"/><address class="footer"><small>
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; Quantum Leaps 2020</a> &nbsp;| &nbsp; <a title="help" href="help.html">Using Online Help</a>&nbsp;| &nbsp;<a title="Doxygen" href="http://www.doxygen.nl">Generated with Doxygen</a>&nbsp; | &nbsp;<b>QTools 6.9.3</b>
</small></address>
        </li>
      </ul>
    </div>
    <script src="custom.js"></script>
  </body>
</html>
