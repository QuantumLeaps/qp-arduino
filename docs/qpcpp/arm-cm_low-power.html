<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QP/C++: Low-Power Example</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
  <a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">
    <img id="logo" src="img/logo_ql.png" alt="Quantum Leaps">
  </a>
  <span id="projectname">QP/C++</span>
  <span id="projectnumber">6.9.3</span>
           <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)"
               onblur="searchBox.OnSearchFieldFocus(false)"
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;"
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('arm-cm_low-power.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0"
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Low-Power Example </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#arm-cm_low_power_tick">The System Clock Tick</a><ul><li class="level2"><a href="#arm-cm_low_power_tickless">The &quot;Tickless Mode&quot;</a></li>
<li class="level2"><a href="#arm-cm_low_power_multiple">Multiple Tick Rates</a></li>
</ul>
</li>
<li class="level1"><a href="#arm-cm_low_power_app">The Low-Power Example Application</a><ul><li class="level2"><a href="#arm-cm_low_power_behave">Behavior</a></li>
<li class="level2"><a href="#arm-cm_low_power_sm">State Machines</a></li>
<li class="level2"><a href="#arm-cm_low_power_xt">Extended Thread (QXK)</a></li>
<li class="level2"><a href="#arm-cm_low_power_idle">The Idle Callback (QK/QXK)</a></li>
<li class="level2"><a href="#arm-cm_low_power_idle-qv">The Idle Callback (QV)</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>The main principle of low-power design for software is to keep the hardware in the most appropriate low-power sleep mode for as long as possible. Most commonly, the software enters a low-power sleep mode from the <b>idle callback</b> (a.k.a. "idle hook"), which is called when the software has nothing left to do and is waiting for an interrupt to deliver more work. The QP/C and QP/C++ Real-Time Embedded Frameworks (RTEFs) support the <em>idle callback</em> in all of the built-in real-time kernels, such as the cooperative <a class="el" href="group__qv.html">QV kernel</a>, the preemptive non-blocking <a class="el" href="group__qk.html">QK kernel</a> and the preemptive blocking <a class="el" href="group__qxk.html">QXK kernel</a>. Also, such an <em>idle callback</em> is provided in all 3rd-party traditional RTOS kernels that QP/C/C++ have been <a class="el" href="ports_rtos.html">ported to</a>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Design for low-power is a broad subject that requires a holistic system approach to achieve a really long battery-powered operation. This example covers only certain <em>software-related</em> aspects of the problem.</dd></dl>
<h1><a class="anchor" id="arm-cm_low_power_tick"></a>
The System Clock Tick</h1>
<p>Most real-time systems, including traditional RTOSes and RTEFs, require a periodic time source called the <b>system clock tick</b> to keep track of time delays, timeouts, and <a class="el" href="class_q_p_1_1_q_time_evt.html" title="Time Event class.">QP::QTimeEvt</a> "time events" in case of the event-driven <a class="el" href="namespace_q_p.html" title="namespace associated with the QP/C++ framework">QP</a> frameworks. The system clock tick is typically a periodic interrupt that occurs at a predetermined rate, typically between 10Hz and 1000Hz.</p>
<p>While the system clock tick is very useful, it also has the unfortunate side effect of taking the processor out of a low power state as many as 1000 times per second regardless if real work needs to be done or not. This effect can have a significant negative impact on the power efficiency of the system.</p>
<p><img src="exa_low-power_tick.gif" alt="" class="inline" title="Additional power dissipation caused by the system clock tick"/></p>
<h2><a class="anchor" id="arm-cm_low_power_tickless"></a>
The "Tickless Mode"</h2>
<p>Some real-time kernels use the low-power optimization called the "tickless mode" (a.k.a. "tick supression" or "dynamic tick"). In this mode, instead of indiscriminately making the clock tick fire with a fixed period, the kernel adjusts the clock ticks <em>dynamically</em>, as needed. Specifically, after each clock tick the kernel re-calculates the time for the next clock tick and then sets the clock tick interrupt for the earliest timeout it has to wait for. So for example, if the shortest wait the kernel has to attend to is 300 milliseconds into the future, then the clock interrupt will be set for 300 milliseconds.</p>
<p>This approach maximizes the amount of time the processor can remain asleep, but requires the kernel to perform the additional work to calculate the dynamic tick intervals and to program them into the hardware. This additional bookkeeping adds complexity to the kernel, is often non-deterministic and, most importantly, extends the time CPU spends in the high-power active mode and thus eliminates some of the power gains the "tickless mode" was supposed to bring.</p>
<p>Also, the "tickless mode" requires a more capable hardware timer that must be able of being reprogrammed for every interrupt in a wide dynamic range and also must accurately keep track of the elapsed time to correct for the irregular (dynamic) tick intervals. Still, "tickless mode" often causes a drift in the timing of the clock tick.</p>
<h2><a class="anchor" id="arm-cm_low_power_multiple"></a>
Multiple Tick Rates</h2>
<p>For the reasons just mentioned, the <a class="el" href="namespace_q_p.html" title="namespace associated with the QP/C++ framework">QP</a>&trade; Real-Time Embedded Frameworks don't provide the "tickless mode". Instead, the <a class="el" href="namespace_q_p.html" title="namespace associated with the QP/C++ framework">QP</a>&trade; frameworks support <b>multiple clock tick rates</b>, which can be turned on and off, as needed. The <a class="el" href="namespace_q_p.html" title="namespace associated with the QP/C++ framework">QP</a>&trade; frameworks also provide methods for finding out <em>when</em> a given clock tick rate is not used, which allows the idle callback inside the application to shut down the given clock tick rate and also to decide which sleep mode to use for the CPU and the peripherals.</p>
<p>The support for multiple static clock tick rates is much <em>simpler</em> than the "dynamic tick", and essentially does not increase the complexity of the kernel (because the same code for the single tick rate can handle other tick rates the same way). Also, multiple static tick rates require much simpler hardware timers, which can be clocked specifically to the desired frequency and don't need particularly wide dynamic range. For example, 16-bit timers or even 8-bit timers are completely adequate.</p>
<p>Yet the <em>multiple clock rates</em> can deliver similar low-power operation for the system, while keeping the <a class="el" href="namespace_q_p.html" title="namespace associated with the QP/C++ framework">QP</a> framework much simpler and easier to certify than "tickless" kernels. The rest of this example explains how to use the multiple static clock rates in QP/C/C++ and shows how to leverage this feature to achieve low-power software design.</p>
<h1><a class="anchor" id="arm-cm_low_power_app"></a>
The Low-Power Example Application</h1>
<p>The low-power example is located in QP/C and QP/C++ distributions, in the directory with the following structure:</p>
<div class="fragment"><div class="line">qpc|qpcpp/                   <span class="comment">// QP/C/C++ installation directory</span></div>
<div class="line"> +-examples/                 <span class="comment">// QP/C/C++ examples directory (application)</span></div>
<div class="line"> | +-arm-cm/                 <span class="comment">// QP/C/C++ examples for ARM Cortex-M</span></div>
<div class="line"> | | +-low-power_ek-tm4c123gxl/ <span class="comment">// Low-Power example on the EK-TM4C123GLX board</span></div>
<div class="line"> | | | +-qk/      <span class="comment">//----------- Projects for the preemptive QK kernel</span></div>
<div class="line"> | | | | +-arm/              <span class="comment">// ARM-KEIL toolchain</span></div>
<div class="line"> | | | | | +-low-power-qk.uvprojx <span class="comment">// uVision project</span></div>
<div class="line"> | | | | +-gnu/              <span class="comment">// GNU-ARM toolchain</span></div>
<div class="line"> | | | | | +-Makefile        <span class="comment">// Makefile for building the project</span></div>
<div class="line"> | | | | +-iar/              <span class="comment">// IAR-ARM toolchain</span></div>
<div class="line"> | | | | | +-low-power-qk.eww <span class="comment">// IAR EW-ARM workspace</span></div>
<div class="line"> | | | | +-bsp.c             <span class="comment">// BSP for the QK kernel</span></div>
<div class="line"> | | | +-qv/      <span class="comment">//----------- Projects for the cooperative QV kernel</span></div>
<div class="line"> | | | | +-arm/              <span class="comment">// ARM-KEIL toolchain</span></div>
<div class="line"> | | | | | +-low-power-qv.uvprojx <span class="comment">// uVision project</span></div>
<div class="line"> | | | | +-gnu/              <span class="comment">// GNU-ARM toolchain</span></div>
<div class="line"> | | | | | +-Makefile        <span class="comment">// Makefile for building the project with GNU-ARM</span></div>
<div class="line"> | | | | +-iar/              <span class="comment">// IAR-ARM toolchain</span></div>
<div class="line"> | | | | | +-low-power-qk.eww <span class="comment">// IAR EW-ARM workspace</span></div>
<div class="line"> | | | | +-bsp.c|.cpp        <span class="comment">// BSP for the QV kernel</span></div>
<div class="line"> | | | +-qxk/     <span class="comment">//----------- Projects for the dual-mode QXK kernel</span></div>
<div class="line"> | | | | +-arm/              <span class="comment">// ARM-KEIL toolchain</span></div>
<div class="line"> | | | | | +-low-power-qxk.uvprojx <span class="comment">// uVision project</span></div>
<div class="line"> | | | | +-gnu/              <span class="comment">// GNU-ARM toolchain</span></div>
<div class="line"> | | | | | +-Makefile        <span class="comment">// Makefile for building the project</span></div>
<div class="line"> | | | | +-iar/              <span class="comment">// IAR-ARM toolchain</span></div>
<div class="line"> | | | | | +-low-power-qxk.eww <span class="comment">// IAR EW-ARM workspace</span></div>
<div class="line"> | | | | +-bsp.c|.cpp        <span class="comment">// BSP for the QxK kernel</span></div>
<div class="line"> | | | | +-xblinky1.c|.cpp   <span class="comment">// eXtended thread for the QXK kernel</span></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>To focus the discussion, this example uses the <b>EK-TM4C123GXL</b> evaluation board (a.k.a. TivaC LaunchPad) with Cortex-M4 MCU. However, the general demonstrated principles apply to most modern microcontrollers.</dd></dl>
<p><br  />
<img src="bd_EK-TM4C123GXL_pins.jpg" alt="" class="inline" title="EK-TM4C123GXL evaluation board"/></p>
<h2><a class="anchor" id="arm-cm_low_power_behave"></a>
Behavior</h2>
<p>The the low-power example illustrates the use of two clock tick rates to toggle the LEDs available on the EK-TM4C123GXL board. After the application code is loaded to the board, the <b>Green-LED</b> starts blinking once per two seconds (a second on and a second off), while the <b>Red-LED</b> lights up and stays on. If no buttons on the board are pressed, the <b>Green-LED</b> stops blinking after 4 times. The <b>Red-LED</b> shows the <b>idle</b> condition, where the system is in a sleep mode.</p>
<p>When your press the <b>SW1-Button</b>, the <b>Green-LED</b> starts blinking as before, but additionally, the <b>Blue-LED</b> starts blinking rapidly for 13 times (1/10 of a second on and 1/10 off).</p>
<p>So, depending when the SW1 switch is pressed, you can have only <b>Green-LED</b> blinking, or both green and blue blinking at different rates. The <b>Red-LED</b> appears to be on all the time.</p>
<dl class="section note"><dt>Note</dt><dd>Actually, the <b>Red-LED</b> is also turned off for very brief moments, but this is imperceptible to the human eye. Instead, the <b>Red-LED</b> appears to be on all the time, which corresponds to the application being mostly idle.</dd></dl>
<p>The behavior just described is designed for the slow human interaction with the application. However, for more precise measurements with a logic analyzer, it is more convenient to speed up the application by factor of 100. This speed up can be achieved by editing the <code>bsp.h</code> header file:</p>
<div class="fragment"><div class="line"><span class="comment">/* The following ticks-per-second constants determine the speed of the app.</span></div>
<div class="line"><span class="comment">* The default (#if 1) is the SLOW speed for humans to see the blinking.</span></div>
<div class="line"><span class="comment">* Change the #if 1 into #if 0 for FAST speed appropriate for logic analyzers.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="preprocessor">#if 0</span></div>
<div class="line"><span class="preprocessor">    #define BSP_TICKS0_PER_SEC   2U</span></div>
<div class="line"><span class="preprocessor">    #define BSP_TICKS1_PER_SEC   20U</span></div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor">    #define BSP_TICKS0_PER_SEC   200U</span></div>
<div class="line"><span class="preprocessor">    #define BSP_TICKS1_PER_SEC   2000U</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line">. . .</div>
</div><!-- fragment --><p>The following logic analyzer trace shows the behavior of the low-power application at the faster time scale. The explanation section immediately following the tarce explains the most interesting points:</p>
<p><img src="exa_low-power_sig.png" alt="" class="inline" title="low-power application after pressing the SW1 button"/></p>
<dl class="tag">
<dt>0</dt>
<dd>The plot shows the logic-analyzer traces of the following signals (from the top): <b>SW1</b> button (active low), <b>Blinky1</b> (Blue-LED), <b>Blinky0</b> (Green-LED) and <b>Idle</b> (Red-LED). The Idle callback turns the <b>Red-LED</b> on when the system enters the low-power sleep mode and it turns the <b>Red-LED</b> off when the system is active.  </dd>
<dt>1</dt>
<dd>At this time the <b>SW1</b> button is depressed, which triggers an interrupt that activates both the slow and the fast clock tick rates. The clock tick interrupts trigger toggling of the <b>Blinky0</b> (Green-LED) at the slower tick rate-0 and <b>Blinky1</b> (Blue-LED) at the faster tick rate-1.  </dd>
<dt>2</dt>
<dd>The <b>Blinky1</b> (Blue-LED) stops toggling after 13 cycles. At this point also the <b>Idle</b> callback turns the <b>fast tick rate-1</b> off.  </dd>
<dt>3</dt>
<dd>The <b>Blinky0</b> (Green-LED) stops toggling after 4 cycles.  </dd>
<dt>4</dt>
<dd>The <b>Idle</b> callback turns the <b>slow tick rate-0</b> off. The system enters the low-power sleep mode without any clock ticks running and remains in this state until the <b>SW1</b> button is pressed again.  </dd>
</dl>
<div style="clear:both;"></div><dl class="section note"><dt>Note</dt><dd>The <b>Idle</b> line (Red-LED) goes down twice as fast as the changes in the state of the <b>Green-LED</b> or the <b>Blue-LED</b>. This is because the application uses timeouts of <b>2 clock ticks</b> for toggling these lines instead of just one clock tick, which then could be slower. This is not quite optimal for the energy dissipation (as the CPU is woken up twice as often as it needs to be), but it illustrates more accurately how the fixed clock rates work as well as the one-tick delay to enter the low-power sleep mode from the idle callback.</dd></dl>
<h2><a class="anchor" id="arm-cm_low_power_sm"></a>
State Machines</h2>
<p>The versions of this low-power example for the <b>QK</b> and <b>QV</b> kernels use two active objects <b>Blinky0</b> and <b>Blinky1</b>, which toggle the <b>Green-LED</b> at the slow tick rate 0, and the <b>Blue-LED</b> at the fast tick rate 1, respectively. The state machines of the Blinky0 and Blinky1 active objects are shown below:</p>
<p><img src="exa_low-power_sm.png" alt="" class="inline" title="state machines Blinky0 and Blinky1 active objects"/></p>
<dl class="tag">
<dt>0</dt>
<dd>The <b>Blinky0</b> state machine, in the entry action to the "active" state, calls <code>BSP_tickRate0_on()</code> to turn the tick rate-0 on. This is done <em>before</em> arming the time event <code>me-&gt;timeEvt0</code> that uses the clock rate-0.  </dd>
<dt>1</dt>
<dd>Similarly, the <b>Blinky1</b> state machine, in the entry action to the "active" state, calls <code>BSP_tickRate1_on()</code> to turn the tick rate-1 on. This is done <em>before</em> arming the time event <code>me-&gt;timeEvt1</code> that uses the clock rate-1.  </dd>
</dl>
<div style="clear:both;"></div><h2><a class="anchor" id="arm-cm_low_power_xt"></a>
Extended Thread (QXK)</h2>
<p>The version of this low-power example for the <b>QXK</b> kernel uses one active object <b>Blinky0</b> (with the state machine shown above), but instead of the Blinky1 active object, the QXK version uses an eXtended thread (::QXThread) called <b>XBlinky1</b>, with the code shown below:</p>
<div class="fragment"><div class="line"><span class="preprocessor">    #include &quot;qpc.h&quot;</span></div>
<div class="line"><span class="preprocessor">    #include &quot;low_power.h&quot;</span></div>
<div class="line"><span class="preprocessor">    #include &quot;bsp.h&quot;</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* local objects -----------------------------------------------------------*/</span></div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> XBlinky1_run(QXThread * <span class="keyword">const</span> me);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* global objects ----------------------------------------------------------*/</span></div>
<div class="line">    QXThread XT_Blinky1;</div>
<div class="line">    QXSemaphore XSEM_sw1;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/*..........................................................................*/</span></div>
<div class="line">    <span class="keywordtype">void</span> XBlinky1_ctor(<span class="keywordtype">void</span>) {</div>
<div class="line">        QXThread_ctor(&amp;XT_Blinky1,</div>
<div class="line">                      &amp;XBlinky1_run, <span class="comment">/* thread routine */</span></div>
<div class="line">                      1U); <span class="comment">/* associate the thread with tick rate-1 */</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/*..........................................................................*/</span></div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> XBlinky1_run(QXThread * <span class="keyword">const</span> me) {</div>
<div class="line">        <span class="keywordtype">bool</span> isActive = <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line">        (void)me; <span class="comment">/* unused parameter */</span></div>
<div class="line">        <span class="keywordflow">for</span> (;;) {</div>
<div class="line">            <span class="keywordflow">if</span> (!isActive) {</div>
<div class="line">[0]             QXSemaphore_wait(&amp;XSEM_sw1, <a class="code" href="namespace_q_p.html#a452f8d89a8280b84ab7856523951c40a">QXTHREAD_NO_TIMEOUT</a>);</div>
<div class="line">                isActive = <span class="keyword">true</span>;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span> {</div>
<div class="line">                <a class="code" href="16bit_2stdint_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> count;</div>
<div class="line">[1]             BSP_tickRate1_on();</div>
<div class="line">                <span class="keywordflow">for</span> (count = 13U; count &gt; 0U; --count) {</div>
<div class="line">                    BSP_led1_on();</div>
<div class="line">                    QXThread_delay(1U);</div>
<div class="line">                    BSP_led1_off();</div>
<div class="line">                    QXThread_delay(1U);</div>
<div class="line">                }</div>
<div class="line">                isActive = <span class="keyword">false</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="ttc" id="a16bit_2stdint_8h_html_aba7bc1797add20fe3efdf37ced1182c5"><div class="ttname"><a href="16bit_2stdint_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a></div><div class="ttdeci">unsigned char uint8_t</div><div class="ttdoc">exact-width 8-bit unsigned int</div><div class="ttdef"><b>Definition:</b> <a href="16bit_2stdint_8h_source.html#l00029">16bit/stdint.h:29</a></div></div>
<div class="ttc" id="anamespace_q_p_html_a452f8d89a8280b84ab7856523951c40a"><div class="ttname"><a href="namespace_q_p.html#a452f8d89a8280b84ab7856523951c40a">QP::QXTHREAD_NO_TIMEOUT</a></div><div class="ttdeci">static constexpr std::uint_fast16_t QXTHREAD_NO_TIMEOUT</div><div class="ttdoc">no-timeout sepcification when blocking on queues or semaphores</div><div class="ttdef"><b>Definition:</b> <a href="qxthread_8hpp_source.html#l00045">qxthread.hpp:45</a></div></div>
</div><!-- fragment --><dl class="tag">
<dt>0</dt>
<dd>The <b>XBlinky1</b> extended thread emulates the states with the <code>isActive</code> flag. When the flag is not set (meaning that the system is not active), the thread waits (and blocks) on the global semaphore <code>XSEM_sw1</code>.  </dd>
<dt>1</dt>
<dd>After the semaphore is signalled (from the GPIO interrupt in the BSP), the <b>XBlinky1</b> extened thread calls <code>BSP_tickRate1_on()</code> to turn the tick rate-1 on. This is done <em>before</em> later calling QXThread_delay() function, which in case uses the clock rate-1.  </dd>
</dl>
<div style="clear:both;"></div><h2><a class="anchor" id="arm-cm_low_power_idle"></a>
The Idle Callback (QK/QXK)</h2>
<p>The most important functionality in this low-power example is implemented in the <b>idle callback</b> located in the BSP (Board Support Package). The idle callback QK_onIdle() for the preemptive QK kernel and the idle callback QXK_onIdle() for the QXK kernel are almost identical and are explained in this section.</p>
<div class="fragment"><div class="line">[0] <span class="keywordtype">void</span> QXK_onIdle(<span class="keywordtype">void</span>) {</div>
<div class="line"> </div>
<div class="line">[1]     <a class="code" href="qk_2qf__port_8hpp.html#a88df5203e3a9716327b58923f5aaac80">QF_INT_DISABLE</a>();</div>
<div class="line">[2]     <span class="keywordflow">if</span> (((l_activeSet &amp; (1U &lt;&lt; SYSTICK_ACTIVE)) != 0U) <span class="comment">/* rate-0 enabled? */</span></div>
<div class="line">[3]         &amp;&amp; QF_noTimeEvtsActiveX(0U))  <span class="comment">/* no time events at rate-0? */</span></div>
<div class="line">        {</div>
<div class="line">            <span class="comment">/* safe to disable SysTick and interrupt */</span></div>
<div class="line">[4]         SysTick-&gt;CTRL &amp;= ~(SysTick_CTRL_TICKINT_Msk | SysTick_CTRL_ENABLE_Msk);</div>
<div class="line">[5]         l_activeSet &amp;= ~(1U &lt;&lt; SYSTICK_ACTIVE); <span class="comment">/* mark rate-0 as disabled */</span></div>
<div class="line">        }</div>
<div class="line">[6]     <span class="keywordflow">if</span> (((l_activeSet &amp; (1U &lt;&lt; TIMER0_ACTIVE)) != 0U) <span class="comment">/* rate-1 enabled? */</span></div>
<div class="line">[7]         &amp;&amp; QF_noTimeEvtsActiveX(1U))  <span class="comment">/* no time events at rate-1? */</span></div>
<div class="line">        {</div>
<div class="line">            <span class="comment">/* safe to disable Timer0 and interrupt */</span></div>
<div class="line">[8]         TIMER0-&gt;CTL  &amp;= ~(1U &lt;&lt; 0); <span class="comment">/* disable Timer0 */</span></div>
<div class="line">[9]         TIMER0-&gt;IMR  &amp;= ~(1U &lt;&lt; 0); <span class="comment">/* disable timer interrupt */</span></div>
<div class="line">[10]        l_activeSet &amp;= ~(1U &lt;&lt; TIMER0_ACTIVE); <span class="comment">/* mark rate-1 as disabled */</span></div>
<div class="line">        }</div>
<div class="line">[11]    <a class="code" href="qk_2qf__port_8hpp.html#ad2d11956704ad838c9c954368d3d37d5">QF_INT_ENABLE</a>();</div>
<div class="line"> </div>
<div class="line">[12]    GPIOF-&gt;DATA_Bits[LED_RED] = 0xFFU; <span class="comment">/* turn LED on, see NOTE2 */</span></div>
<div class="line">[13]    __WFI(); <span class="comment">// wait for interrupt */</span></div>
<div class="line">[14]    GPIOF-&gt;DATA_Bits[LED_RED] = 0x00U; <span class="comment">/* turn LED off, see NOTE2 */</span></div>
<div class="line">    }</div>
<div class="ttc" id="aqk_2qf__port_8hpp_html_a88df5203e3a9716327b58923f5aaac80"><div class="ttname"><a href="qk_2qf__port_8hpp.html#a88df5203e3a9716327b58923f5aaac80">QF_INT_DISABLE</a></div><div class="ttdeci">#define QF_INT_DISABLE()</div><div class="ttdef"><b>Definition:</b> <a href="qk_2qf__port_8hpp_source.html#l00043">qk/qf_port.hpp:43</a></div></div>
<div class="ttc" id="aqk_2qf__port_8hpp_html_ad2d11956704ad838c9c954368d3d37d5"><div class="ttname"><a href="qk_2qf__port_8hpp.html#ad2d11956704ad838c9c954368d3d37d5">QF_INT_ENABLE</a></div><div class="ttdeci">#define QF_INT_ENABLE()</div><div class="ttdef"><b>Definition:</b> <a href="qk_2qf__port_8hpp_source.html#l00044">qk/qf_port.hpp:44</a></div></div>
</div><!-- fragment --><dl class="tag">
<dt>0</dt>
<dd>The idle callback for QK and QXK are called from the idle loop with interrupts enabled.  </dd>
<dt>1</dt>
<dd>Interrupts are disabled to access the shared bitmask <code>l_activeSet</code>, which stores the information about active clock rates and peripherals. This bitmask is shared between the idle callback and the application-level threads.  </dd>
<dt>2</dt>
<dd>If the SYSTICK timer is active (source of the tick-0 rate)...  </dd>
<dt>3</dt>
<dd><p class="startdd">The <code>QF_noTimeEvtsActiveX(0)</code> function is called to check whether no time events are active at the clock rate-0.</p>
<blockquote class="doxtable">
<p><b>NOTE:</b> The QF_noTimeEvtsActiveX() function is designed to be called from a critical section, which is the case here. </p>
</blockquote>
</dd>
<dt>4</dt>
<dd>If both of these conditions hold, it is safe to turn the clock rate-0 off, which is done here.  </dd>
<dt>5</dt>
<dd>The bit indicating that SYSTICK timer is active is cleared in the <code>l_activeSet</code> bitmask.  </dd>
<dt>6</dt>
<dd>Simliarly, the bit corresponding to TIMER0 is checked in the <code>l_activeSet</code> bitmask.  </dd>
<dt>7</dt>
<dd>The <code>QF_noTimeEvtsActiveX(1)</code> function is called to check whether no time events are active at the clock rate-1.  </dd>
<dt>8-9</dt>
<dd>If both of these conditions hold, it is safe to turn the clock rate-1 off, which is done here.  </dd>
<dt>10</dt>
<dd>The bit indicating that TIMER0 timer is active is cleared in the <code>l_activeSet</code> bitmask.  </dd>
<dt>11</dt>
<dd>Interrupts are enabled, so the following code is no logner inside critical section  </dd>
<dt>12</dt>
<dd>The <b>Red-LED</b> is turned ON right before entering the low-power sleep mode  </dd>
<dt>13</dt>
<dd>The <code>__WFI()</code> instruction stops the CPU and enters the <b>low-power sleep mode</b>  </dd>
<dt>14</dt>
<dd>The <b>Red-LED</b> is turned off after waking up from the sleep mode  </dd>
</dl>
<div style="clear:both;"></div><h2><a class="anchor" id="arm-cm_low_power_idle-qv"></a>
The Idle Callback (QV)</h2>
<p>The idle callback QV_onIdle() for the cooperative QV kernel is slightly different, because it is called with interrupts <b>disabled</b>. The following listing shows the complete QV_onIdle() callback, with the most important points explained in the section below:</p>
<div class="fragment"><div class="line">[0] <span class="keywordtype">void</span> QV_onIdle(<span class="keywordtype">void</span>) { <span class="comment">/* NOTE: called with interrupts DISABLED */</span></div>
<div class="line"> </div>
<div class="line">[1]     <span class="keywordflow">if</span> (((l_activeSet &amp; (1U &lt;&lt; SYSTICK_ACTIVE)) != 0U) <span class="comment">/* rate-0 enabled? */</span></div>
<div class="line">[2]         &amp;&amp; QF_noTimeEvtsActiveX(0U))  <span class="comment">/* no time events at rate-0? */</span></div>
<div class="line">        {</div>
<div class="line">            <span class="comment">/* safe to disable SysTick and interrupt */</span></div>
<div class="line">            SysTick-&gt;CTRL &amp;= ~(SysTick_CTRL_TICKINT_Msk | SysTick_CTRL_ENABLE_Msk);</div>
<div class="line">            l_activeSet &amp;= ~(1U &lt;&lt; SYSTICK_ACTIVE); <span class="comment">/* mark rate-0 as disabled */</span></div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (((l_activeSet &amp; (1U &lt;&lt; TIMER0_ACTIVE)) != 0U) <span class="comment">/* rate-1 enabled? */</span></div>
<div class="line">            &amp;&amp; QF_noTimeEvtsActiveX(1U))  <span class="comment">/* no time events at rate-1? */</span></div>
<div class="line">        {</div>
<div class="line">            <span class="comment">/* safe to disable Timer0 and interrupt */</span></div>
<div class="line">            TIMER0-&gt;CTL  &amp;= ~(1U &lt;&lt; 0); <span class="comment">/* disable Timer0 */</span></div>
<div class="line">            TIMER0-&gt;IMR  &amp;= ~(1U &lt;&lt; 0); <span class="comment">/* disable timer interrupt */</span></div>
<div class="line">            l_activeSet &amp;= ~(1U &lt;&lt; TIMER0_ACTIVE); <span class="comment">/* mark rate-1 as disabled */</span></div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        GPIOF-&gt;DATA_Bits[LED_RED] = 0xFFU; <span class="comment">/* turn LED on, see NOTE2 */</span></div>
<div class="line">[3]     <a class="code" href="qv__port_8hpp.html#a63d09440889262e482687c417690fea4">QV_CPU_SLEEP</a>(); <span class="comment">/* atomically go to sleep and enable interrupts */</span></div>
<div class="line">        GPIOF-&gt;DATA_Bits[LED_RED] = 0x00U; <span class="comment">/* turn LED off, see NOTE2 */</span></div>
<div class="line">    }</div>
<div class="ttc" id="aqv__port_8hpp_html_a63d09440889262e482687c417690fea4"><div class="ttname"><a href="qv__port_8hpp.html#a63d09440889262e482687c417690fea4">QV_CPU_SLEEP</a></div><div class="ttdeci">#define QV_CPU_SLEEP()</div><div class="ttdoc">Macro to put the CPU to sleep safely in the cooperative.</div><div class="ttdef"><b>Definition:</b> <a href="qv__port_8hpp_source.html#l00052">qv_port.hpp:52</a></div></div>
</div><!-- fragment --><dl class="tag">
<dt>0</dt>
<dd>The idle callback for QV is called from the QV event-loop with interrupts <b>disabled</b>.  </dd>
<dt>1</dt>
<dd>The <code>l_activeSet</code> bitmask is tested right away, because interrupts are already disabled  </dd>
<dt>2</dt>
<dd><p class="startdd">The <code>QF_noTimeEvtsActiveX(0)</code> function is called to check whether no time events are active at the clock rate-0.</p>
<blockquote class="doxtable">
<p><b>NOTE:</b> The QF_noTimeEvtsActiveX() function is designed to be called from a critical section, which is the case here. </p>
</blockquote>
</dd>
<dt>3</dt>
<dd>The <a class="el" href="qv__port_8hpp.html#a63d09440889262e482687c417690fea4" title="Macro to put the CPU to sleep safely in the cooperative.">QV_CPU_SLEEP()</a> macro enters <b>low-power sleep mode</b> with interrupts still disabled. This port-specific macro is designed to re-anable interrupts <b>atomically</b> with entering the sleep mode.  </dd>
</dl>
<div style="clear:both;"></div> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
    <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
      <ul>
        <li class="footer">
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; 2005-2021 Quantum Leaps</a> &nbsp;| &nbsp; <a title="help" href="help.html">Using Online Help</a>&nbsp;| &nbsp;<a title="Doxygen" href="http://www.doxygen.nl">Generated with Doxygen</a>&nbsp; | &nbsp;<b>QP/C++ 6.9.3</b>
<hr class="footer"/><address class="footer"><small>
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; Quantum Leaps 2020</a> &nbsp;| &nbsp; <a title="help" href="help.html">Using Online Help</a>&nbsp;| &nbsp;<a title="Doxygen" href="http://www.doxygen.nl">Generated with Doxygen</a>&nbsp; | &nbsp;<b>QP/C++ 6.9.3</b>
</small></address>
        </li>
      </ul>
    </div>
    <script src="custom.js"></script>
  </body>
</html>
