<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QP/C++: QEQueue Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
  <a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">
    <img id="logo" src="img/logo_ql.png" alt="Quantum Leaps">
  </a>
  <span id="projectname">QP/C++</span>
  <span id="projectnumber">6.9.3</span>
           <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)"
               onblur="searchBox.OnSearchFieldFocus(false)"
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;"
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_q_p_1_1_q_e_queue.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0"
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">QEQueue Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Native <a class="el" href="class_q_p_1_1_q_f.html" title="QF services.">QF</a> Event Queue class.
 <a href="class_q_p_1_1_q_e_queue.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="qequeue_8hpp_source.html">qequeue.hpp</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for QEQueue:</div>
<div class="dyncontent">
<div class="center"><img src="class_q_p_1_1_q_e_queue__coll__graph.png" border="0" usemap="#a_q_e_queue_coll__map" alt="Collaboration graph"/></div>
<map name="a_q_e_queue_coll__map" id="a_q_e_queue_coll__map">
<area shape="rect" title="Native QF Event Queue class." alt="" coords="5,189,104,457"/>
<area shape="rect" href="struct_q_p_1_1_q_evt.html" title="QEvt base class." alt="" coords="17,5,92,112"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abf306af9180780ef54c58caa6a4c8b32"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_p_1_1_q_e_queue.html#abf306af9180780ef54c58caa6a4c8b32">QEQueue</a> (void) noexcept</td></tr>
<tr class="memdesc:abf306af9180780ef54c58caa6a4c8b32"><td class="mdescLeft">&#160;</td><td class="mdescRight">public default constructor  <a href="class_q_p_1_1_q_e_queue.html#abf306af9180780ef54c58caa6a4c8b32">More...</a><br /></td></tr>
<tr class="separator:abf306af9180780ef54c58caa6a4c8b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ee07175cee4d2095a786efd382af21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_p_1_1_q_e_queue.html#a77ee07175cee4d2095a786efd382af21">init</a> (<a class="el" href="struct_q_p_1_1_q_evt.html">QEvt</a> const *qSto[], <a class="el" href="32bit_2stdint_8h.html#a226d967fb6d06433caf43f20dc876aae">std::uint_fast16_t</a> const qLen) noexcept</td></tr>
<tr class="memdesc:a77ee07175cee4d2095a786efd382af21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the native <a class="el" href="class_q_p_1_1_q_f.html" title="QF services.">QF</a> event queue.  <a href="class_q_p_1_1_q_e_queue.html#a77ee07175cee4d2095a786efd382af21">More...</a><br /></td></tr>
<tr class="separator:a77ee07175cee4d2095a786efd382af21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7faed14a4cde24461001219cf38dca1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_p_1_1_q_e_queue.html#ab7faed14a4cde24461001219cf38dca1">post</a> (<a class="el" href="struct_q_p_1_1_q_evt.html">QEvt</a> const *const e, <a class="el" href="32bit_2stdint_8h.html#a226d967fb6d06433caf43f20dc876aae">std::uint_fast16_t</a> const margin, <a class="el" href="32bit_2stdint_8h.html#ad0906fbe05a45fbdb000c58fe8929e70">std::uint_fast8_t</a> const qs_id) noexcept</td></tr>
<tr class="memdesc:ab7faed14a4cde24461001219cf38dca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">"raw" thread-safe <a class="el" href="class_q_p_1_1_q_f.html" title="QF services.">QF</a> event queue implementation for the event posting (FIFO). You can call this function from any task context or ISR context. This function uses internally a critical section.  <a href="class_q_p_1_1_q_e_queue.html#ab7faed14a4cde24461001219cf38dca1">More...</a><br /></td></tr>
<tr class="separator:ab7faed14a4cde24461001219cf38dca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99fe8c234ef5275b0cd35b6c46a915f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_p_1_1_q_e_queue.html#a99fe8c234ef5275b0cd35b6c46a915f2">postLIFO</a> (<a class="el" href="struct_q_p_1_1_q_evt.html">QEvt</a> const *const e, <a class="el" href="32bit_2stdint_8h.html#ad0906fbe05a45fbdb000c58fe8929e70">std::uint_fast8_t</a> const qs_id) noexcept</td></tr>
<tr class="memdesc:a99fe8c234ef5275b0cd35b6c46a915f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">"raw" thread-safe <a class="el" href="class_q_p_1_1_q_f.html" title="QF services.">QF</a> event queue implementation for the First-In-First-Out (FIFO) event posting. You can call this function from any task context or ISR context. Please note that this function uses internally a critical section.  <a href="class_q_p_1_1_q_e_queue.html#a99fe8c234ef5275b0cd35b6c46a915f2">More...</a><br /></td></tr>
<tr class="separator:a99fe8c234ef5275b0cd35b6c46a915f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75617b7aeb5634cbb858c27c7c7a2281"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_q_p_1_1_q_evt.html">QEvt</a> const  *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_p_1_1_q_e_queue.html#a75617b7aeb5634cbb858c27c7c7a2281">get</a> (<a class="el" href="32bit_2stdint_8h.html#ad0906fbe05a45fbdb000c58fe8929e70">std::uint_fast8_t</a> const qs_id) noexcept</td></tr>
<tr class="memdesc:a75617b7aeb5634cbb858c27c7c7a2281"><td class="mdescLeft">&#160;</td><td class="mdescRight">"raw" thread-safe <a class="el" href="class_q_p_1_1_q_f.html" title="QF services.">QF</a> event queue implementation for the Last-In-First-Out (LIFO) event posting.  <a href="class_q_p_1_1_q_e_queue.html#a75617b7aeb5634cbb858c27c7c7a2281">More...</a><br /></td></tr>
<tr class="separator:a75617b7aeb5634cbb858c27c7c7a2281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03ea7ec89c338e5b92d38496177396d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_q_p.html#a0045d2024029c315adcc88a0acdb95f6">QEQueueCtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_p_1_1_q_e_queue.html#a03ea7ec89c338e5b92d38496177396d7">getNFree</a> (void) const noexcept</td></tr>
<tr class="memdesc:a03ea7ec89c338e5b92d38496177396d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">"raw" thread-safe <a class="el" href="class_q_p_1_1_q_f.html" title="QF services.">QF</a> event queue operation for obtaining the number of free entries still available in the queue.  <a href="class_q_p_1_1_q_e_queue.html#a03ea7ec89c338e5b92d38496177396d7">More...</a><br /></td></tr>
<tr class="separator:a03ea7ec89c338e5b92d38496177396d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c039e39d121eeab3d7f4ca6fe321859"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_q_p.html#a0045d2024029c315adcc88a0acdb95f6">QEQueueCtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_p_1_1_q_e_queue.html#a6c039e39d121eeab3d7f4ca6fe321859">getNMin</a> (void) const noexcept</td></tr>
<tr class="memdesc:a6c039e39d121eeab3d7f4ca6fe321859"><td class="mdescLeft">&#160;</td><td class="mdescRight">"raw" thread-safe <a class="el" href="class_q_p_1_1_q_f.html" title="QF services.">QF</a> event queue operation for obtaining the minimum number of free entries ever in the queue (a.k.a. "low-watermark").  <a href="class_q_p_1_1_q_e_queue.html#a6c039e39d121eeab3d7f4ca6fe321859">More...</a><br /></td></tr>
<tr class="separator:a6c039e39d121eeab3d7f4ca6fe321859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ef7d9a7ee76f0c416c5170a0007cfe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_p_1_1_q_e_queue.html#a16ef7d9a7ee76f0c416c5170a0007cfe">isEmpty</a> (void) const noexcept</td></tr>
<tr class="memdesc:a16ef7d9a7ee76f0c416c5170a0007cfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">"raw" thread-safe <a class="el" href="class_q_p_1_1_q_f.html" title="QF services.">QF</a> event queue operation to find out if the queue is empty  <a href="class_q_p_1_1_q_e_queue.html#a16ef7d9a7ee76f0c416c5170a0007cfe">More...</a><br /></td></tr>
<tr class="separator:a16ef7d9a7ee76f0c416c5170a0007cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a5bd77fcceea41a67477ebf91828ba04a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_p_1_1_q_e_queue.html#a5bd77fcceea41a67477ebf91828ba04a">QEQueue</a> (<a class="el" href="class_q_p_1_1_q_e_queue.html">QEQueue</a> const &amp;)=delete</td></tr>
<tr class="memdesc:a5bd77fcceea41a67477ebf91828ba04a"><td class="mdescLeft">&#160;</td><td class="mdescRight">disallow copying of <a class="el" href="class_q_p_1_1_q_e_queue.html" title="Native QF Event Queue class.">QEQueue</a>  <a href="class_q_p_1_1_q_e_queue.html#a5bd77fcceea41a67477ebf91828ba04a">More...</a><br /></td></tr>
<tr class="separator:a5bd77fcceea41a67477ebf91828ba04a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae2269f22904e8410b782cb2a389e76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_q_p_1_1_q_e_queue.html">QEQueue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_p_1_1_q_e_queue.html#a2ae2269f22904e8410b782cb2a389e76">operator=</a> (<a class="el" href="class_q_p_1_1_q_e_queue.html">QEQueue</a> const &amp;)=delete</td></tr>
<tr class="memdesc:a2ae2269f22904e8410b782cb2a389e76"><td class="mdescLeft">&#160;</td><td class="mdescRight">disallow assignment of <a class="el" href="class_q_p_1_1_q_e_queue.html" title="Native QF Event Queue class.">QEQueue</a>  <a href="class_q_p_1_1_q_e_queue.html#a2ae2269f22904e8410b782cb2a389e76">More...</a><br /></td></tr>
<tr class="separator:a2ae2269f22904e8410b782cb2a389e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a5384f08815940ae30e63d97d3bfe75e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_q_p_1_1_q_evt.html">QEvt</a> const  *volatile&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_p_1_1_q_e_queue.html#a5384f08815940ae30e63d97d3bfe75e5">m_frontEvt</a></td></tr>
<tr class="memdesc:a5384f08815940ae30e63d97d3bfe75e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to event at the front of the queue  <a href="class_q_p_1_1_q_e_queue.html#a5384f08815940ae30e63d97d3bfe75e5">More...</a><br /></td></tr>
<tr class="separator:a5384f08815940ae30e63d97d3bfe75e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d4ff97b5422b01577b17ef8ad0d459"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_q_p_1_1_q_evt.html">QEvt</a> const  **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_p_1_1_q_e_queue.html#a88d4ff97b5422b01577b17ef8ad0d459">m_ring</a></td></tr>
<tr class="memdesc:a88d4ff97b5422b01577b17ef8ad0d459"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to the start of the ring buffer  <a href="class_q_p_1_1_q_e_queue.html#a88d4ff97b5422b01577b17ef8ad0d459">More...</a><br /></td></tr>
<tr class="separator:a88d4ff97b5422b01577b17ef8ad0d459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb337e6f2960b8ce89aba87e50ba81b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_q_p.html#a0045d2024029c315adcc88a0acdb95f6">QEQueueCtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_p_1_1_q_e_queue.html#aedb337e6f2960b8ce89aba87e50ba81b">m_end</a></td></tr>
<tr class="memdesc:aedb337e6f2960b8ce89aba87e50ba81b"><td class="mdescLeft">&#160;</td><td class="mdescRight">offset of the end of the ring buffer from the start of the buffer  <a href="class_q_p_1_1_q_e_queue.html#aedb337e6f2960b8ce89aba87e50ba81b">More...</a><br /></td></tr>
<tr class="separator:aedb337e6f2960b8ce89aba87e50ba81b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c5e0cd6fcd39542534e8f014e11063"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_q_p.html#a0045d2024029c315adcc88a0acdb95f6">QEQueueCtr</a> volatile&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_p_1_1_q_e_queue.html#a02c5e0cd6fcd39542534e8f014e11063">m_head</a></td></tr>
<tr class="memdesc:a02c5e0cd6fcd39542534e8f014e11063"><td class="mdescLeft">&#160;</td><td class="mdescRight">offset to where next event will be inserted into the buffer  <a href="class_q_p_1_1_q_e_queue.html#a02c5e0cd6fcd39542534e8f014e11063">More...</a><br /></td></tr>
<tr class="separator:a02c5e0cd6fcd39542534e8f014e11063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad50086bee5b365c15b9946abfe17cc6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_q_p.html#a0045d2024029c315adcc88a0acdb95f6">QEQueueCtr</a> volatile&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_p_1_1_q_e_queue.html#ad50086bee5b365c15b9946abfe17cc6e">m_tail</a></td></tr>
<tr class="memdesc:ad50086bee5b365c15b9946abfe17cc6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">offset of where next event will be extracted from the buffer  <a href="class_q_p_1_1_q_e_queue.html#ad50086bee5b365c15b9946abfe17cc6e">More...</a><br /></td></tr>
<tr class="separator:ad50086bee5b365c15b9946abfe17cc6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3bca6fe537ee2e1f97003d2d9f9ba17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_q_p.html#a0045d2024029c315adcc88a0acdb95f6">QEQueueCtr</a> volatile&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_p_1_1_q_e_queue.html#af3bca6fe537ee2e1f97003d2d9f9ba17">m_nFree</a></td></tr>
<tr class="memdesc:af3bca6fe537ee2e1f97003d2d9f9ba17"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of free events in the ring buffer  <a href="class_q_p_1_1_q_e_queue.html#af3bca6fe537ee2e1f97003d2d9f9ba17">More...</a><br /></td></tr>
<tr class="separator:af3bca6fe537ee2e1f97003d2d9f9ba17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9a3b821ee67f93fca7284170124c8f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_q_p.html#a0045d2024029c315adcc88a0acdb95f6">QEQueueCtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_p_1_1_q_e_queue.html#aa9a3b821ee67f93fca7284170124c8f1">m_nMin</a></td></tr>
<tr class="memdesc:aa9a3b821ee67f93fca7284170124c8f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">minimum number of free events ever in the ring buffer.  <a href="class_q_p_1_1_q_e_queue.html#aa9a3b821ee67f93fca7284170124c8f1">More...</a><br /></td></tr>
<tr class="separator:aa9a3b821ee67f93fca7284170124c8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a9bff20005d080fc888fcbc59b4fd16ab"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_p_1_1_q_e_queue.html#a9bff20005d080fc888fcbc59b4fd16ab">QF</a></td></tr>
<tr class="separator:a9bff20005d080fc888fcbc59b4fd16ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd057458f70978840c6f18b891ea07f"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_p_1_1_q_e_queue.html#a1bd057458f70978840c6f18b891ea07f">QActive</a></td></tr>
<tr class="separator:a1bd057458f70978840c6f18b891ea07f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd06ce08115faa318198ade6659b7aa0"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_p_1_1_q_e_queue.html#afd06ce08115faa318198ade6659b7aa0">QXThread</a></td></tr>
<tr class="separator:afd06ce08115faa318198ade6659b7aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1396df55df06e8864fb859c6e6ebe2a0"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_p_1_1_q_e_queue.html#a1396df55df06e8864fb859c6e6ebe2a0">QTicker</a></td></tr>
<tr class="separator:a1396df55df06e8864fb859c6e6ebe2a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d22dce8191266e3f8cf2a622f4ef47d"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_p_1_1_q_e_queue.html#a2d22dce8191266e3f8cf2a622f4ef47d">QS</a></td></tr>
<tr class="separator:a2d22dce8191266e3f8cf2a622f4ef47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Native <a class="el" href="class_q_p_1_1_q_f.html" title="QF services.">QF</a> Event Queue class. </p>
<dl class="section user"><dt>Description</dt><dd>This structure describes the native <a class="el" href="class_q_p_1_1_q_f.html" title="QF services.">QF</a> event queue, which can be used as the event queue for active objects, or as a simple "raw" event queue for thread-safe event passing among non-framework entities, such as ISRs, device drivers, or other third-party components.<br  />
<br  />
The native <a class="el" href="class_q_p_1_1_q_f.html" title="QF services.">QF</a> event queue is configured by defining the macro <a class="el" href="qxk_8hpp.html#aee19c1d6e860d59dda6e539852b99dbe">QF_EQUEUE_TYPE</a> as <a class="el" href="class_q_p_1_1_q_e_queue.html" title="Native QF Event Queue class.">QP::QEQueue</a> in the specific <a class="el" href="class_q_p_1_1_q_f.html" title="QF services.">QF</a> port header file.<br  />
<br  />
The <a class="el" href="class_q_p_1_1_q_e_queue.html" title="Native QF Event Queue class.">QP::QEQueue</a> class contains only data members for managing an event queue, but does not contain the storage for the queue buffer, which must be provided externally during the queue initialization.<br  />
<br  />
The event queue can store only event pointers, not the whole events. The internal implementation uses the standard ring-buffer plus one external location that optimizes the queue operation for the most frequent case of empty queue.<br  />
<br  />
The <a class="el" href="class_q_p_1_1_q_e_queue.html" title="Native QF Event Queue class.">QP::QEQueue</a> class is used with two sets of functions. One set is for the active object event queue, which needs to block the active object task when the event queue is empty and unblock it when events are posted to the queue. The interface for the native active object event queue consists of the following functions: QP::QMActive::post(), <a class="el" href="class_q_p_1_1_q_active.html#a2275d125f8bb6e87a60a2c13ee4be7a2" title="Posts an event directly to the event queue of the active object using the Last-In-First-Out (LIFO) po...">QP::QMActive::postLIFO()</a>, and <a class="el" href="class_q_p_1_1_q_active.html#af2bded82b019e65bb15549f8909ee6a1" title="Get an event from the event queue of an active object.">QP::QMActive::get_()</a>. Additionally the function <a class="el" href="class_q_p_1_1_q_e_queue.html#a77ee07175cee4d2095a786efd382af21" title="Initializes the native QF event queue.">QP::QEQueue::init()</a> is used to initialize the queue.<br  />
<br  />
The other set of functions, uses this class as a simple "raw" event queue to pass events between entities other than active objects, such as ISRs. The "raw" event queue is not capable of blocking on the <a class="el" href="class_q_p_1_1_q_e_queue.html#a75617b7aeb5634cbb858c27c7c7a2281" title="&quot;raw&quot; thread-safe QF event queue implementation for the Last-In-First-Out (LIFO) event posting.">get()</a> operation, but is still thread-safe because it uses <a class="el" href="class_q_p_1_1_q_f.html" title="QF services.">QF</a> critical section to protect its integrity. The interface for the "raw" thread-safe queue consists of the following functions: <a class="el" href="class_q_p_1_1_q_e_queue.html#ab7faed14a4cde24461001219cf38dca1" title="&quot;raw&quot; thread-safe QF event queue implementation for the event posting (FIFO). You can call this funct...">QP::QEQueue::post()</a>, <a class="el" href="class_q_p_1_1_q_e_queue.html#a99fe8c234ef5275b0cd35b6c46a915f2" title="&quot;raw&quot; thread-safe QF event queue implementation for the First-In-First-Out (FIFO) event posting....">QP::QEQueue::postLIFO()</a>, and <a class="el" href="class_q_p_1_1_q_e_queue.html#a75617b7aeb5634cbb858c27c7c7a2281" title="&quot;raw&quot; thread-safe QF event queue implementation for the Last-In-First-Out (LIFO) event posting.">QP::QEQueue::get()</a>. Additionally the function <a class="el" href="class_q_p_1_1_q_e_queue.html#a77ee07175cee4d2095a786efd382af21" title="Initializes the native QF event queue.">QP::QEQueue::init()</a> is used to initialize the queue.<br  />
<br  />
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Most event queue operations (both the active object queues and the "raw" queues) internally use the <a class="el" href="class_q_p_1_1_q_f.html" title="QF services.">QF</a> critical section. You should be careful not to invoke those operations from other critical sections when nesting of critical sections is not supported. </dd></dl>

<p class="definition">Definition at line <a class="el" href="qequeue_8hpp_source.html#l00123">123</a> of file <a class="el" href="qequeue_8hpp_source.html">qequeue.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="abf306af9180780ef54c58caa6a4c8b32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf306af9180780ef54c58caa6a4c8b32">&#9670;&nbsp;</a></span>QEQueue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_q_p_1_1_q_e_queue.html">QEQueue</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>public default constructor </p>
<dl class="section user"><dt>Description</dt><dd>Default constructor </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__qeq_8cpp_source.html#l00058">58</a> of file <a class="el" href="qf__qeq_8cpp_source.html">qf_qeq.cpp</a>.</p>

</div>
</div>
<a id="a5bd77fcceea41a67477ebf91828ba04a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bd77fcceea41a67477ebf91828ba04a">&#9670;&nbsp;</a></span>QEQueue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_q_p_1_1_q_e_queue.html">QEQueue</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_q_p_1_1_q_e_queue.html">QEQueue</a> const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>disallow copying of <a class="el" href="class_q_p_1_1_q_e_queue.html" title="Native QF Event Queue class.">QEQueue</a> </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a77ee07175cee4d2095a786efd382af21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77ee07175cee4d2095a786efd382af21">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_p_1_1_q_evt.html">QEvt</a> const *&#160;</td>
          <td class="paramname"><em>qSto</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="32bit_2stdint_8h.html#a226d967fb6d06433caf43f20dc876aae">std::uint_fast16_t</a> const&#160;</td>
          <td class="paramname"><em>qLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the native <a class="el" href="class_q_p_1_1_q_f.html" title="QF services.">QF</a> event queue. </p>
<dl class="section user"><dt>Description</dt><dd>The parameters are as follows: <code>qSto</code>[] is the ring buffer storage, <code>qLen</code> is the length of the ring buffer in the units of event- pointers.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The actual capacity of the queue is qLen + 1, because of the extra location fornEvt_.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Initialize the event queue by giving it the storage for the ring buffer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">qSto</td><td>an array of pointers to <a class="el" href="struct_q_p_1_1_q_evt.html" title="QEvt base class.">QP::QEvt</a> to sereve as the ring buffer for the event queue </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qLen</td><td>the length of the qSto[] buffer (in <a class="el" href="struct_q_p_1_1_q_evt.html" title="QEvt base class.">QP::QEvt</a> pointers)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The actual capacity of the queue is qLen + 1, because of the extra location forntEvt.</dd>
<dd>
This function is also used to initialize the event queues of active objects in the built-int <a class="el" href="class_q_p_1_1_q_v.html" title="QV services.">QV</a>, <a class="el" href="class_q_p_1_1_q_k.html" title="QK services.">QK</a> and <a class="el" href="class_q_p_1_1_q_x_k.html" title="QXK services.">QXK</a> kernels, as well as other <a class="el" href="namespace_q_p.html" title="namespace associated with the QP/C++ framework">QP</a> ports to OSes/RTOSes that do provide a suitable message queue. </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__qeq_8cpp_source.html#l00084">84</a> of file <a class="el" href="qf__qeq_8cpp_source.html">qf_qeq.cpp</a>.</p>

</div>
</div>
<a id="ab7faed14a4cde24461001219cf38dca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7faed14a4cde24461001219cf38dca1">&#9670;&nbsp;</a></span>post()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool post </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_p_1_1_q_evt.html">QEvt</a> const *const&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="32bit_2stdint_8h.html#a226d967fb6d06433caf43f20dc876aae">std::uint_fast16_t</a> const&#160;</td>
          <td class="paramname"><em>margin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="32bit_2stdint_8h.html#ad0906fbe05a45fbdb000c58fe8929e70">std::uint_fast8_t</a> const&#160;</td>
          <td class="paramname"><em>qs_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>"raw" thread-safe <a class="el" href="class_q_p_1_1_q_f.html" title="QF services.">QF</a> event queue implementation for the event posting (FIFO). You can call this function from any task context or ISR context. This function uses internally a critical section. </p>
<dl class="section user"><dt>Description</dt><dd>The argument <code>margin</code> specifies the minimum number of free entries in the queue that must be available for posting to succeed. The function returns true (success) if the posting succeeded (with the provided margin) and false (failure) when the posting fails.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function raises an assertion if the <code>margin</code> is zero and the queue becomes full and cannot accept the event.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_q_p_1_1_q_e_queue.html#a99fe8c234ef5275b0cd35b6c46a915f2" title="&quot;raw&quot; thread-safe QF event queue implementation for the First-In-First-Out (FIFO) event posting....">QP::QEQueue::postLIFO()</a>, <a class="el" href="class_q_p_1_1_q_e_queue.html#a75617b7aeb5634cbb858c27c7c7a2281" title="&quot;raw&quot; thread-safe QF event queue implementation for the Last-In-First-Out (LIFO) event posting.">QP::QEQueue::get()</a></dd></dl>
<dl class="section user"><dt>Description</dt><dd>Post an event to the "raw" thread-safe event queue using the First-In-First-Out (FIFO) order.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>pointer to the event to be posted to the queue </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">margin</td><td>number of required free slots in the queue after posting the event. The special value <a class="el" href="namespace_q_p.html#a0a6f5f86430ebc107a239e6795f5b183" title="special value of margin that causes asserting failure in case event allocation or event posting fails">QP::QF_NO_MARGIN</a> means that this function will assert if posting </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qs_id</td><td>QS-id of this state machine (for <a class="el" href="class_q_p_1_1_q_s.html" title="QS logging facilities.">QS</a> local filter)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="namespace_q_p.html#a0a6f5f86430ebc107a239e6795f5b183" title="special value of margin that causes asserting failure in case event allocation or event posting fails">QP::QF_NO_MARGIN</a> value of the <code>margin</code> argument is special and denotes situation when the <a class="el" href="class_q_p_1_1_q_e_queue.html#ab7faed14a4cde24461001219cf38dca1" title="&quot;raw&quot; thread-safe QF event queue implementation for the event posting (FIFO). You can call this funct...">post()</a> operation is assumed to succeed (event delivery guarantee). An assertion fires, when the event cannot be delivered in this case.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>'true' (success) when the posting succeeded with the provided margin and 'false' (failure) when the posting fails.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function can be called from any task context or ISR context.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_q_p_1_1_q_e_queue.html#a99fe8c234ef5275b0cd35b6c46a915f2" title="&quot;raw&quot; thread-safe QF event queue implementation for the First-In-First-Out (FIFO) event posting....">QP::QEQueue::postLIFO()</a>, <a class="el" href="class_q_p_1_1_q_e_queue.html#a75617b7aeb5634cbb858c27c7c7a2281" title="&quot;raw&quot; thread-safe QF event queue implementation for the Last-In-First-Out (LIFO) event posting.">QP::QEQueue::get()</a> </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>event must be valid</dd></dl>
<dl class="section note"><dt>Note</dt><dd>assert if event cannot be posted and dropping events is not acceptable</dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__qeq_8cpp_source.html#l00122">122</a> of file <a class="el" href="qf__qeq_8cpp_source.html">qf_qeq.cpp</a>.</p>

</div>
</div>
<a id="a99fe8c234ef5275b0cd35b6c46a915f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99fe8c234ef5275b0cd35b6c46a915f2">&#9670;&nbsp;</a></span>postLIFO()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void postLIFO </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_p_1_1_q_evt.html">QEvt</a> const *const&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="32bit_2stdint_8h.html#ad0906fbe05a45fbdb000c58fe8929e70">std::uint_fast8_t</a> const&#160;</td>
          <td class="paramname"><em>qs_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>"raw" thread-safe <a class="el" href="class_q_p_1_1_q_f.html" title="QF services.">QF</a> event queue implementation for the First-In-First-Out (FIFO) event posting. You can call this function from any task context or ISR context. Please note that this function uses internally a critical section. </p>
<dl class="section note"><dt>Note</dt><dd>The function raises an assertion if the native <a class="el" href="class_q_p_1_1_q_f.html" title="QF services.">QF</a> queue becomes full and cannot accept the event.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_q_p_1_1_q_e_queue.html#a99fe8c234ef5275b0cd35b6c46a915f2" title="&quot;raw&quot; thread-safe QF event queue implementation for the First-In-First-Out (FIFO) event posting....">QP::QEQueue::postLIFO()</a>, <a class="el" href="class_q_p_1_1_q_e_queue.html#a75617b7aeb5634cbb858c27c7c7a2281" title="&quot;raw&quot; thread-safe QF event queue implementation for the Last-In-First-Out (LIFO) event posting.">QP::QEQueue::get()</a></dd></dl>
<dl class="section user"><dt>Description</dt><dd>Post an event to the "raw" thread-safe event queue using the Last-In-First-Out (LIFO) order.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>pointer to the event to be posted to the queue </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qs_id</td><td>QS-id of this state machine (for <a class="el" href="class_q_p_1_1_q_s.html" title="QS logging facilities.">QS</a> local filter)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>The LIFO policy should be used only with great <b>caution</b>, because it alters the order of events in the queue.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function can be called from any task context or ISR context.</dd>
<dd>
This function is used for the "raw" thread-safe queues and <b>not</b> for the queues of active objects.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_q_p_1_1_q_e_queue.html#ab7faed14a4cde24461001219cf38dca1" title="&quot;raw&quot; thread-safe QF event queue implementation for the event posting (FIFO). You can call this funct...">QP::QEQueue::post()</a>, <a class="el" href="class_q_p_1_1_q_e_queue.html#a75617b7aeb5634cbb858c27c7c7a2281" title="&quot;raw&quot; thread-safe QF event queue implementation for the Last-In-First-Out (LIFO) event posting.">QP::QEQueue::get()</a>, <a class="el" href="class_q_p_1_1_q_active.html#a29446ebb1a76be27c27f62bf89cc07e4" title="Defer an event to a given separate event queue.">QP::QActive::defer()</a> </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>the queue must be able to accept the event (cannot overflow)</dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__qeq_8cpp_source.html#l00221">221</a> of file <a class="el" href="qf__qeq_8cpp_source.html">qf_qeq.cpp</a>.</p>

</div>
</div>
<a id="a75617b7aeb5634cbb858c27c7c7a2281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75617b7aeb5634cbb858c27c7c7a2281">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_q_p_1_1_q_evt.html">QEvt</a> const  * get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="32bit_2stdint_8h.html#ad0906fbe05a45fbdb000c58fe8929e70">std::uint_fast8_t</a> const&#160;</td>
          <td class="paramname"><em>qs_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>"raw" thread-safe <a class="el" href="class_q_p_1_1_q_f.html" title="QF services.">QF</a> event queue implementation for the Last-In-First-Out (LIFO) event posting. </p>
<dl class="section note"><dt>Note</dt><dd>The LIFO policy should be used only with great caution because it alters order of events in the queue. </dd>
<dd>
The function raises an assertion if the native <a class="el" href="class_q_p_1_1_q_f.html" title="QF services.">QF</a> queue becomes full and cannot accept the event. You can call this function from any task context or ISR context. Please note that this function uses internally a critical section.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_q_p_1_1_q_e_queue.html#ab7faed14a4cde24461001219cf38dca1" title="&quot;raw&quot; thread-safe QF event queue implementation for the event posting (FIFO). You can call this funct...">QP::QEQueue::post()</a>, <a class="el" href="class_q_p_1_1_q_e_queue.html#a99fe8c234ef5275b0cd35b6c46a915f2" title="&quot;raw&quot; thread-safe QF event queue implementation for the First-In-First-Out (FIFO) event posting....">QP::QEQueue::postLIFO()</a>, <a class="el" href="class_q_p_1_1_q_e_queue.html#a75617b7aeb5634cbb858c27c7c7a2281" title="&quot;raw&quot; thread-safe QF event queue implementation for the Last-In-First-Out (LIFO) event posting.">QP::QEQueue::get()</a></dd></dl>
<dl class="section user"><dt>Description</dt><dd>Retrieves an event from the front of the "raw" thread-safe queue and returns a pointer to this event to the caller.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">qs_id</td><td>QS-id of this state machine (for <a class="el" href="class_q_p_1_1_q_s.html" title="QS logging facilities.">QS</a> local filter)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to event at the front of the queue, if the queue is not empty and NULL if the queue is empty.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>this function is used for the "raw" thread-safe queues and <b>not</b> for the queues of active objects.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_q_p_1_1_q_e_queue.html#ab7faed14a4cde24461001219cf38dca1" title="&quot;raw&quot; thread-safe QF event queue implementation for the event posting (FIFO). You can call this funct...">QP::QEQueue::post()</a>, <a class="el" href="class_q_p_1_1_q_e_queue.html#a99fe8c234ef5275b0cd35b6c46a915f2" title="&quot;raw&quot; thread-safe QF event queue implementation for the First-In-First-Out (FIFO) event posting....">QP::QEQueue::postLIFO()</a>, <a class="el" href="class_q_p_1_1_q_active.html#aa436248a33030f8d4cc68591a2bfae98" title="Recall a deferred event from a given event queue.">QP::QActive::recall()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__qeq_8cpp_source.html#l00287">287</a> of file <a class="el" href="qf__qeq_8cpp_source.html">qf_qeq.cpp</a>.</p>

</div>
</div>
<a id="a03ea7ec89c338e5b92d38496177396d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03ea7ec89c338e5b92d38496177396d7">&#9670;&nbsp;</a></span>getNFree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_q_p.html#a0045d2024029c315adcc88a0acdb95f6">QEQueueCtr</a> getNFree </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>"raw" thread-safe <a class="el" href="class_q_p_1_1_q_f.html" title="QF services.">QF</a> event queue operation for obtaining the number of free entries still available in the queue. </p>
<dl class="section note"><dt>Note</dt><dd>This operation needs to be used with caution because the number of free entries can change unexpectedly. The main intent for using this operation is in conjunction with event deferral. In this case the queue is accessed only from a single thread (by a single AO), so the number of free entries cannot change unexpectedly.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_q_p_1_1_q_active.html#a29446ebb1a76be27c27f62bf89cc07e4" title="Defer an event to a given separate event queue.">QP::QMActive::defer()</a>, <a class="el" href="class_q_p_1_1_q_active.html#aa436248a33030f8d4cc68591a2bfae98" title="Recall a deferred event from a given event queue.">QP::QMActive::recall()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="qequeue_8hpp_source.html#l00225">225</a> of file <a class="el" href="qequeue_8hpp_source.html">qequeue.hpp</a>.</p>

</div>
</div>
<a id="a6c039e39d121eeab3d7f4ca6fe321859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c039e39d121eeab3d7f4ca6fe321859">&#9670;&nbsp;</a></span>getNMin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_q_p.html#a0045d2024029c315adcc88a0acdb95f6">QEQueueCtr</a> getNMin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>"raw" thread-safe <a class="el" href="class_q_p_1_1_q_f.html" title="QF services.">QF</a> event queue operation for obtaining the minimum number of free entries ever in the queue (a.k.a. "low-watermark"). </p>
<dl class="section user"><dt>Description</dt><dd>This operation needs to be used with caution because the "low-watermark" can change unexpectedly. The main intent for using this operation is to get an idea of queue usage to size the queue adequately.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum number of free entries ever in the queue since init. </dd></dl>

<p class="definition">Definition at line <a class="el" href="qequeue_8hpp_source.html#l00240">240</a> of file <a class="el" href="qequeue_8hpp_source.html">qequeue.hpp</a>.</p>

</div>
</div>
<a id="a16ef7d9a7ee76f0c416c5170a0007cfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16ef7d9a7ee76f0c416c5170a0007cfe">&#9670;&nbsp;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isEmpty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>"raw" thread-safe <a class="el" href="class_q_p_1_1_q_f.html" title="QF services.">QF</a> event queue operation to find out if the queue is empty </p>
<dl class="section note"><dt>Note</dt><dd>This operation needs to be used with caution because the queue status can change unexpectedly. The main intent for using this operation is in conjunction with event deferral. In this case the queue is accessed only from a single thread (by a single AO), so no other entity can post events to the queue.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_q_p_1_1_q_active.html#a29446ebb1a76be27c27f62bf89cc07e4" title="Defer an event to a given separate event queue.">QP::QMActive::defer()</a>, <a class="el" href="class_q_p_1_1_q_active.html#aa436248a33030f8d4cc68591a2bfae98" title="Recall a deferred event from a given event queue.">QP::QMActive::recall()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="qequeue_8hpp_source.html#l00254">254</a> of file <a class="el" href="qequeue_8hpp_source.html">qequeue.hpp</a>.</p>

</div>
</div>
<a id="a2ae2269f22904e8410b782cb2a389e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ae2269f22904e8410b782cb2a389e76">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_q_p_1_1_q_e_queue.html">QEQueue</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_q_p_1_1_q_e_queue.html">QEQueue</a> const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>disallow assignment of <a class="el" href="class_q_p_1_1_q_e_queue.html" title="Native QF Event Queue class.">QEQueue</a> </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a9bff20005d080fc888fcbc59b4fd16ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bff20005d080fc888fcbc59b4fd16ab">&#9670;&nbsp;</a></span>QF</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="class_q_p_1_1_q_f.html">QF</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="qequeue_8hpp_source.html#l00265">265</a> of file <a class="el" href="qequeue_8hpp_source.html">qequeue.hpp</a>.</p>

</div>
</div>
<a id="a1bd057458f70978840c6f18b891ea07f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bd057458f70978840c6f18b891ea07f">&#9670;&nbsp;</a></span>QActive</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="class_q_p_1_1_q_active.html">QActive</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="qequeue_8hpp_source.html#l00266">266</a> of file <a class="el" href="qequeue_8hpp_source.html">qequeue.hpp</a>.</p>

</div>
</div>
<a id="afd06ce08115faa318198ade6659b7aa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd06ce08115faa318198ade6659b7aa0">&#9670;&nbsp;</a></span>QXThread</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="class_q_p_1_1_q_x_thread.html">QXThread</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="qequeue_8hpp_source.html#l00267">267</a> of file <a class="el" href="qequeue_8hpp_source.html">qequeue.hpp</a>.</p>

</div>
</div>
<a id="a1396df55df06e8864fb859c6e6ebe2a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1396df55df06e8864fb859c6e6ebe2a0">&#9670;&nbsp;</a></span>QTicker</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="class_q_p_1_1_q_ticker.html">QTicker</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="qequeue_8hpp_source.html#l00268">268</a> of file <a class="el" href="qequeue_8hpp_source.html">qequeue.hpp</a>.</p>

</div>
</div>
<a id="a2d22dce8191266e3f8cf2a622f4ef47d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d22dce8191266e3f8cf2a622f4ef47d">&#9670;&nbsp;</a></span>QS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="class_q_p_1_1_q_s.html">QS</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="qequeue_8hpp_source.html#l00269">269</a> of file <a class="el" href="qequeue_8hpp_source.html">qequeue.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="a5384f08815940ae30e63d97d3bfe75e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5384f08815940ae30e63d97d3bfe75e5">&#9670;&nbsp;</a></span>m_frontEvt</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_q_p_1_1_q_evt.html">QEvt</a> const* volatile m_frontEvt</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>pointer to event at the front of the queue </p>
<dl class="section user"><dt>Description</dt><dd>All incoming and outgoing events pass through the m_frontEvt location. When the queue is empty (which is most of the time), the extra m_frontEvt location allows to bypass the ring buffer altogether, greatly optimizing the performance of the queue. Only bursts of events engage the ring buffer.<br  />
<br  />
The additional role of this attribute is to indicate the empty status of the queue. The queue is empty if the m_frontEvt location is NULL. </dd></dl>

<p class="definition">Definition at line <a class="el" href="qequeue_8hpp_source.html#l00136">136</a> of file <a class="el" href="qequeue_8hpp_source.html">qequeue.hpp</a>.</p>

</div>
</div>
<a id="a88d4ff97b5422b01577b17ef8ad0d459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88d4ff97b5422b01577b17ef8ad0d459">&#9670;&nbsp;</a></span>m_ring</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_q_p_1_1_q_evt.html">QEvt</a> const** m_ring</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>pointer to the start of the ring buffer </p>

<p class="definition">Definition at line <a class="el" href="qequeue_8hpp_source.html#l00139">139</a> of file <a class="el" href="qequeue_8hpp_source.html">qequeue.hpp</a>.</p>

</div>
</div>
<a id="aedb337e6f2960b8ce89aba87e50ba81b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedb337e6f2960b8ce89aba87e50ba81b">&#9670;&nbsp;</a></span>m_end</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_q_p.html#a0045d2024029c315adcc88a0acdb95f6">QEQueueCtr</a> m_end</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>offset of the end of the ring buffer from the start of the buffer </p>

<p class="definition">Definition at line <a class="el" href="qequeue_8hpp_source.html#l00142">142</a> of file <a class="el" href="qequeue_8hpp_source.html">qequeue.hpp</a>.</p>

</div>
</div>
<a id="a02c5e0cd6fcd39542534e8f014e11063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c5e0cd6fcd39542534e8f014e11063">&#9670;&nbsp;</a></span>m_head</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_q_p.html#a0045d2024029c315adcc88a0acdb95f6">QEQueueCtr</a> volatile m_head</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>offset to where next event will be inserted into the buffer </p>

<p class="definition">Definition at line <a class="el" href="qequeue_8hpp_source.html#l00145">145</a> of file <a class="el" href="qequeue_8hpp_source.html">qequeue.hpp</a>.</p>

</div>
</div>
<a id="ad50086bee5b365c15b9946abfe17cc6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad50086bee5b365c15b9946abfe17cc6e">&#9670;&nbsp;</a></span>m_tail</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_q_p.html#a0045d2024029c315adcc88a0acdb95f6">QEQueueCtr</a> volatile m_tail</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>offset of where next event will be extracted from the buffer </p>

<p class="definition">Definition at line <a class="el" href="qequeue_8hpp_source.html#l00148">148</a> of file <a class="el" href="qequeue_8hpp_source.html">qequeue.hpp</a>.</p>

</div>
</div>
<a id="af3bca6fe537ee2e1f97003d2d9f9ba17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3bca6fe537ee2e1f97003d2d9f9ba17">&#9670;&nbsp;</a></span>m_nFree</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_q_p.html#a0045d2024029c315adcc88a0acdb95f6">QEQueueCtr</a> volatile m_nFree</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>number of free events in the ring buffer </p>

<p class="definition">Definition at line <a class="el" href="qequeue_8hpp_source.html#l00151">151</a> of file <a class="el" href="qequeue_8hpp_source.html">qequeue.hpp</a>.</p>

</div>
</div>
<a id="aa9a3b821ee67f93fca7284170124c8f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9a3b821ee67f93fca7284170124c8f1">&#9670;&nbsp;</a></span>m_nMin</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_q_p.html#a0045d2024029c315adcc88a0acdb95f6">QEQueueCtr</a> m_nMin</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>minimum number of free events ever in the ring buffer. </p>
<dl class="section note"><dt>Note</dt><dd>this attribute remembers the low-watermark of the ring buffer, which provides a valuable information for sizing event queues. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_q_p_1_1_q_f.html#a2661f3a8d818b3e3eebaabda9b4ced5a" title="This function returns the minimum of free entries of the given event queue.">QP::QF::getQueueMin()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="qequeue_8hpp_source.html#l00157">157</a> of file <a class="el" href="qequeue_8hpp_source.html">qequeue.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="qequeue_8hpp_source.html">qequeue.hpp</a></li>
<li><a class="el" href="qf__qeq_8cpp_source.html">qf_qeq.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
    <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
      <ul>
        <li class="navelem"><a class="el" href="namespace_q_p.html">QP</a></li><li class="navelem"><a class="el" href="class_q_p_1_1_q_e_queue.html">QEQueue</a></li>
        <li class="footer">
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; 2005-2021 Quantum Leaps</a> &nbsp;| &nbsp; <a title="help" href="help.html">Using Online Help</a>&nbsp;| &nbsp;<a title="Doxygen" href="http://www.doxygen.nl">Generated with Doxygen</a>&nbsp; | &nbsp;<b>QP/C++ 6.9.3</b>
<hr class="footer"/><address class="footer"><small>
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; Quantum Leaps 2020</a> &nbsp;| &nbsp; <a title="help" href="help.html">Using Online Help</a>&nbsp;| &nbsp;<a title="Doxygen" href="http://www.doxygen.nl">Generated with Doxygen</a>&nbsp; | &nbsp;<b>QP/C++ 6.9.3</b>
</small></address>
        </li>
      </ul>
    </div>
    <script src="custom.js"></script>
  </body>
</html>
