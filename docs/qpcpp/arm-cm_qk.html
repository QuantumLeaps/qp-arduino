<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QP/C++: Preemptive Non-Blocking QK Kernel</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
  <a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">
    <img id="logo" src="img/logo_ql.png" alt="Quantum Leaps">
  </a>
  <span id="projectname">QP/C++</span>
  <span id="projectnumber">6.9.3</span>
           <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)"
               onblur="searchBox.OnSearchFieldFocus(false)"
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;"
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('arm-cm_qk.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0"
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Preemptive Non-Blocking QK Kernel </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#arm-cm_qk-synopsis">Synopsis of the QK Port on ARM Cortex-M</a><ul><li class="level2"><a href="#arm-cm_qk-preempt">Preemption Scenarios in QK on ARM Cortex-M</a></li>
</ul>
</li>
<li class="level1"><a href="#arm-cm_qk-qf_port">The qf_port.h Header File</a></li>
<li class="level1"><a href="#arm-cm_qk-qk_impl">QK Port Implementation for ARM Cortex-M</a><ul><li class="level2"><a href="#arm-cm_qk_port-asm_init">QK_init() Implementation</a></li>
<li class="level2"><a href="#arm-cm_qk_port-asm_pendsv">PendSV_Handler() Implementation</a></li>
<li class="level2"><a href="#arm-cm_qk_port-asm_nmi">NMI_Handler() Implementation</a></li>
</ul>
</li>
<li class="level1"><a href="#arm-cm_qk-isr">Writing ISRs for QK</a></li>
<li class="level1"><a href="#arm-cm_qk-fpu">Using the FPU in the QK Port (Cortex-M4F/M7)</a><ul><li class="level2"><a href="#arm-cm_qk-fpu_1thread">FPU used in ONE thread only and not in any ISR</a></li>
<li class="level2"><a href="#arm-cm_qk-fpu_nthreadd">FPU used in more than one thread only or the ISR</a></li>
</ul>
</li>
<li class="level1"><a href="#arm-cm_qk-idle">QK Idle Processing Customization in QK_onIdle()</a></li>
<li class="level1"><a href="#arm-cm_qk-testing">Testing QK Preemption Scenarios</a><ul><li class="level2"><a href="#arm-cm_qk-test-isr">Interrupt Nesting Test</a></li>
<li class="level2"><a href="#arm-cm_qk-test-thread">Thread Preemption Test</a></li>
<li class="level2"><a href="#arm-cm_qk-test-fpu">Testing the FPU (Cortex-M4F/M7)</a></li>
<li class="level2"><a href="#arm-cm_qk-test-other">Other Tests</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>The <a class="el" href="group__qk.html">preemptive, non-blocking QK kernel</a> is specifically designed to execute non-blocking active objects. QK runs active objects in the same way as prioritized interrupt controller (such as NVIC in ARM Cortex-M) runs interrupts using the <b>single stack</b> (MSP on Cortex-M). This section explains how the <a class="el" href="group__qk.html">preemptive non-blocking QK kernel</a> works on ARM Cortex-M. </p>
<dl class="section remark"><dt>Remarks</dt><dd>In a QK port, the only components requiring platform-specific porting are QF and QV itself. The other two components: QEP and QS require merely recompilation and will not be discussed here. With the QV port you're not using the QV or QXK kernels. The QK port to ARM Cortex-M is located in the folder <span class="img folder">/ports/arm-cm/qk/</span>.</dd></dl>
<h1><a class="anchor" id="arm-cm_qk-synopsis"></a>
Synopsis of the QK Port on ARM Cortex-M</h1>
<p>The ARM Cortex-M architecture is designed primarily for the traditional real-time kernels that use multiple per-thread stacks. Therefore, implementation of the non-blocking, single-stack kernel like QK is a bit more involved on Cortex-M than other CPUs and works as follows:</p>
<ol type="1">
<li>The ARM Cortex-M processor executes the QK application code (active objects) in the Privileged Thread mode, which is exactly the mode entered out of reset. The exceptions (including all interrupts) are always processed in the Privileged Handler mode.</li>
<li>QK uses only the Main Stack Pointer (QK is a single stack kernel). The Process Stack Pointer is not used and is not initialized.</li>
<li>ARM Cortex-M enters interrupt context without disabling interrupts (without setting the PRIMASK bit or the BASEPRI register). Generally, you should not disable interrupts inside your ISRs. In particular, the <a class="el" href="namespace_q_p.html" title="namespace associated with the QP/C++ framework">QP</a> services QF_PUBLISH(), QF_TICK_X(), and QACTIVE_POST() should be called with interrupts enabled, to avoid nesting of critical sections. (NOTE: If you donâ€™t wish an interrupt to be preempted by another interrupt, you can always prioritize that interrupt in the NVIC to a higher level &ndash; use a lower numerical value of priority).</li>
<li>The QK port uses the PendSV exception (number 14) and the NMI exception (number 2) to perform asynchronous preemption and return to the preempted thread, respectively (see Chapter 10 in [<a href="https://state-machine.com/psicc2/" target="_blank" class="extern">PSiCC2</a>]). The startup code must initialize the Interrupt Vector Table with the addresses of <code>PendSV_Handler()</code> and <code>NMI_Handler()</code> exception handlers. <br  />
<blockquote class="doxtable">
<p>NOTE: QK uses only the CMSIS-compliant exception and interrupt names, such as <code>PendSV_Handler</code>, <code>NMI_Handler</code>, etc.<br  />
NOTE: The QK port specifically does <b>not</b> use the SVC exception (Supervisor Call). This makes the QK ports compatible with various "hypervisors" (such as mbed uVisor or Nordic SoftDevice), which use the SVC exception. </p>
</blockquote>
</li>
<li>The QF_init() function calls the function QK_init() to set the priority of the PendSV exception to the lowest level in the whole system (0xFF). The function QK_init() additionally sets the interrupt priority of all IRQs available in the MCU to the safe value of <a class="el" href="arm-cm_qv.html#QF_BASEPRI">QF_BASEPRI</a> (for ARM-v7 architecture).</li>
<li>It is strongly recommended that you do not assign the lowest priority (0xFF) to any interrupt in your application. With 3 MSB-bits of priority, this leaves the following 7 priority levels for you (listed from the lowest to the highest urgency): 0xC0, 0xA0, 0x80, 0x60, 0x40, 0x20, and 0x00 (the highest priority).</li>
<li>Before returning, every "kernel aware" ISR must check whether an active object has been activated that has a higher priority than the currently running active object. If this is the case, the ISR must set the PensSV pending flag in the NVIC. All this is accomplished in the macro <a class="el" href="qk__port_8hpp.html#a18f2cc4dd2d00e3d5efb593d0754a95b" title="Define the ISR exit sequence, if the compiler supports writing interrupts in C++.">QK_ISR_EXIT()</a>, which must be called just before exiting every ISRs.</li>
<li>In ARM Cortex-M the whole prioritization of interrupts, including the PendSV exception, is performed entirely by the NVIC. Because the PendSV has the lowest priority in the system, the NVIC tail-chains to the PendSV exception only after exiting the last nested interrupt.</li>
<li>The pushing of the 8 registers comprising the ARM Cortex-M interrupt stack frame upon entry to NMI exception is wasteful in a single-stack kernel, but is necessary to perform full interrupt return to the preempted context through the NMI's return.</li>
</ol>
<h2><a class="anchor" id="arm-cm_qk-preempt"></a>
Preemption Scenarios in QK on ARM Cortex-M</h2>
<p>The "synchronous preemption" occurs when one (low-priority) thread is preempted by another (high-priority) thread. QK handles this case as a regular function call. This function call happens inside the QActive post function:</p>
<p><a class="anchor" id="arm-cm_qk-synch-fig"></a></p><div class="image">
<img src="qk_synch.gif" alt=""/>
<div class="caption">
Synchronous preemption scenario in QK</div></div>
<p>The "asynchronous preemption" occurs when an interrupt posts an event to a higher-priority thread than the currently executing. In ARM Cortex-M, this preemption is hanlded in the <code>PendSV</code> exception handler:</p>
<p><a class="anchor" id="arm-cm_qk-arm-cm-fig"></a></p><div class="image">
<img src="qk_arm-cm.gif" alt=""/>
<div class="caption">
Asynchronous preemption scenarios in QK</div></div>
<ul class="tag">
<li>
<span class="tag">0</span> The timeline begins with the QK executing the idle loop.  </li>
<li>
<span class="tag">1</span> At some point an interrupt occurs and the CPU immediately suspends the idle loop, pushes the interrupt stack frame to the Main Stack and starts executing the ISR.  </li>
<li>
<span class="tag">2</span> The ISR performs its work, and in QK always must call the <a class="el" href="qk__port_8hpp.html#a18f2cc4dd2d00e3d5efb593d0754a95b" title="Define the ISR exit sequence, if the compiler supports writing interrupts in C++.">QK_ISR_EXIT()</a> macro, which calls the QK scheduler (<a class="el" href="qk_8hpp.html#afe93da1e870c6b1c749d69b01847e85e" title="QK scheduler finds the highest-priority thread ready to run.">QK_sched_()</a>) to determine if there is a higher-priority AO to run. If so, the macro sets the pending flag for the PendSV exception in the NVIC. The priority of the PendSV exception is configured to be the lowest of all exceptions (0xFF), so the ISR continues executing while PendSV exception remains pending. At the ISR return, the ARM Cortex-M CPU performs tail-chaining to the pending PendSV exception.  </li>
<li>
<span class="tag">3</span> The PendSV exception is entered via tail-chaining.  </li>
<li>
<span class="tag">4</span> The job of the PendSV exception is to run the QK "activator" (<a class="el" href="qk_8hpp.html#a66f8c70043c85b83fee5fc6eab93d8ba" title="QK activator activates the next active object. The activated AO preempts.">QK_activate_()</a>), which in turn runs all threads. <blockquote class="doxtable">
<p>NOTE: The QK activator must run in the thread context, while PendSV executes in the exception context. The change of the context is accomplished by <b>returning</b> from the PendSV exception directly to the QK "activator". To return directly to the QK activator, PendSV synthesizes an exception stack frame, which contains the exception return address set to <a class="el" href="qk_8hpp.html#a66f8c70043c85b83fee5fc6eab93d8ba" title="QK activator activates the next active object. The activated AO preempts.">QK_activate_()</a>. </p>
</blockquote>
The QK "activator" enables interrupts and calls the Low-priority thread (a regular C function call). The Low-priority thread (active object) starts running.  </li>
<li>
<span class="tag">5</span> Some time later a low-priority interrupt occurs. The Low-priority thread is suspended and the CPU pushes the interrupt stack frame to the Main Stack and starts executing the ISR.  </li>
<li>
<span class="tag">6</span> Before the Low-priority ISR completes, it too gets preempted by a High-priority ISR. The CPU pushes another interrupt stack frame and starts executing the High-priority ISR.  </li>
<li>
<span class="tag">7</span> The High-priority ISR sets the pending flag for the PendSV exception by means of the <a class="el" href="qk__port_8hpp.html#a18f2cc4dd2d00e3d5efb593d0754a95b" title="Define the ISR exit sequence, if the compiler supports writing interrupts in C++.">QK_ISR_EXIT()</a> macro. When the High-priority ISR returns, the NVIC does not tail-chain to the PendSV exception, because a higher-priority ISR than PendSV is still active.  </li>
<li>
<span class="tag">8</span> The NVIC performs an exception return to the preempted Low-priority interrupt, which finally completes.  </li>
<li>
<span class="tag">9</span> Upon the exit from the Low-priority ISR, it too sets the pending flag for the PendSV exception by means of the <a class="el" href="qk__port_8hpp.html#a18f2cc4dd2d00e3d5efb593d0754a95b" title="Define the ISR exit sequence, if the compiler supports writing interrupts in C++.">QK_ISR_EXIT()</a> macro. The PendSV is already pended from the High-priority interrupt, so pending is again is redundant, but it is not an error.  </li>
<li>
<span class="tag">10</span> The NVIC performs tail-chaining to the PendSV exception.  </li>
<li>
<span class="tag">11</span> The PendSV exception returns to the QK activator as previously described. The QK activator detects that the High-priority thread is ready to run and launches the High-priority thread (normal C-function call). The High-priority thread runs to completion and returns to the activator.  </li>
<li>
<span class="tag">12</span> The QK activator does not find any more higher-priority threads to execute and needs to return to the preempted thread. The only way to restore the interrupted context in ARM Cortex-M is through the interrupt return, but the thread is executing outside of the interrupt context (in fact, threads are executing in the Privileged Thread mode). The thread enters the Handler mode by pending the NMI exception. <blockquote class="doxtable">
<p>NOTE: The NMI exception is pended while interrupts are still disabled. This is not a problem, because NMI cannot be masked by disabling interrupts, so it runs without any problems. </p>
</blockquote>
</li>
<li>
<span class="tag">13</span> The only job of the NMI exception is to discard its own interrupt stack frame, re-enable interrupts, and return using the interrupt stack frame that has been on the stack from the moment of thread preemption.  </li>
<li>
<span class="tag">14</span> The Low-priority thread, which has been preempted all that time, resumes and finally runs to completion and returns to the QK activator. The QK activaotr does not find any more threads to launch and causes the NMI exception to return to the preempted thread.  </li>
<li>
<span class="tag">15</span> The NMI exception discards its own interrupt stack frame and returns using the interrupt stack frame from the preempted thread context  </li>
</ul>
<h1><a class="anchor" id="arm-cm_qk-qf_port"></a>
The qf_port.h Header File</h1>
<p>The QF header file for the ARM Cortex-M port is located in <span class="img file_h">/ports/arm-cm/qk/gnu/qf_port.h</span>. This file is almost identical to the <a class="el" href="arm-cm_qv.html#arm-cm_qv-qf_port">QV port</a>, except the header file in the QK port includes <code>qk_port.h</code> header file instead of <code>qv_porth</code>. The most important function of <span class="img file_h">qk_port.h</span> is specifying interrupt entry and exit.</p>
<dl class="section note"><dt>Note</dt><dd>As any preemptive kernel, QK needs to be notified about entering the interrupt context and about exiting an interrupt context in order to perform a context switch, if necessary.</dd></dl>
<p><a class="anchor" id="arm-cm_qk_port-code"></a><b>Listing: qk_port.h header file for ARM Cortex-M</b> </p><div class="fragment"><div class="line">    <span class="comment">/* determination if the code executes in the ISR context */</span></div>
<div class="line">[1] #define <a class="code" href="qk_8hpp.html#a4396c0ed924c1f24fd798c572b3e4c18">QK_ISR_CONTEXT_</a>() (QK_get_IPSR() != (<a class="code" href="16bit_2stdint_8h.html#a33594304e786b158f3fb30289278f5af">uint32_t</a>)0)</div>
<div class="line"> </div>
<div class="line">    __attribute__((always_inline))</div>
<div class="line">[2] <span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="16bit_2stdint_8h.html#a33594304e786b158f3fb30289278f5af">uint32_t</a> QK_get_IPSR(<span class="keywordtype">void</span>) {</div>
<div class="line">        <a class="code" href="16bit_2stdint_8h.html#a33594304e786b158f3fb30289278f5af">uint32_t</a> regIPSR;</div>
<div class="line">        __asm <span class="keyword">volatile</span> (<span class="stringliteral">&quot;mrs %0,ipsr&quot;</span> : <span class="stringliteral">&quot;=r&quot;</span> (regIPSR));</div>
<div class="line">        <span class="keywordflow">return</span> regIPSR;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* QK interrupt entry and exit */</span></div>
<div class="line">[3] #define <a class="code" href="qk__port_8hpp.html#ad3a6c9c79a8f39f1299196922e3eb6b5">QK_ISR_ENTRY</a>() ((void)0)</div>
<div class="line"> </div>
<div class="line">[4] #define <a class="code" href="qk__port_8hpp.html#a18f2cc4dd2d00e3d5efb593d0754a95b">QK_ISR_EXIT</a>()  do { \</div>
<div class="line">[5]     <a class="code" href="qk_2qf__port_8hpp.html#a88df5203e3a9716327b58923f5aaac80">QF_INT_DISABLE</a>(); \</div>
<div class="line">[6]     <span class="keywordflow">if</span> (<a class="code" href="qk_8hpp.html#afe93da1e870c6b1c749d69b01847e85e">QK_sched_</a>() != (<a class="code" href="16bit_2stdint_8h.html#ad0906fbe05a45fbdb000c58fe8929e70">uint_fast8_t</a>)0) { \</div>
<div class="line">[7]        (*<a class="code" href="qep_8hpp.html#ad28acca1ff94561bd0f1dbc5f2532d49">Q_UINT2PTR_CAST</a>(<a class="code" href="16bit_2stdint_8h.html#a33594304e786b158f3fb30289278f5af">uint32_t</a>, 0xE000ED04U) = (<a class="code" href="16bit_2stdint_8h.html#a33594304e786b158f3fb30289278f5af">uint32_t</a>)(1U &lt;&lt; 28)); \</div>
<div class="line">        } \</div>
<div class="line">[8]     <a class="code" href="qk_2qf__port_8hpp.html#ad2d11956704ad838c9c954368d3d37d5">QF_INT_ENABLE</a>(); \</div>
<div class="line">    } <span class="keywordflow">while</span> (0)</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* initialization of the QK kernel */</span></div>
<div class="line">[9] #define QK_INIT() QK_init()</div>
<div class="line">    <span class="keywordtype">void</span> QK_init(<span class="keywordtype">void</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="preprocessor">#include &quot;qk.h&quot;</span> <span class="comment">/* QK platform-independent public interface */</span><span class="preprocessor"></span></div>
<div class="ttc" id="a16bit_2stdint_8h_html_a33594304e786b158f3fb30289278f5af"><div class="ttname"><a href="16bit_2stdint_8h.html#a33594304e786b158f3fb30289278f5af">uint32_t</a></div><div class="ttdeci">unsigned long int uint32_t</div><div class="ttdoc">exact-width 32-bit unsigned int</div><div class="ttdef"><b>Definition:</b> <a href="16bit_2stdint_8h_source.html#l00031">16bit/stdint.h:31</a></div></div>
<div class="ttc" id="a16bit_2stdint_8h_html_ad0906fbe05a45fbdb000c58fe8929e70"><div class="ttname"><a href="16bit_2stdint_8h.html#ad0906fbe05a45fbdb000c58fe8929e70">uint_fast8_t</a></div><div class="ttdeci">unsigned int uint_fast8_t</div><div class="ttdoc">fast at-least 8-bit unsigned int</div><div class="ttdef"><b>Definition:</b> <a href="16bit_2stdint_8h_source.html#l00036">16bit/stdint.h:36</a></div></div>
<div class="ttc" id="aqep_8hpp_html_ad28acca1ff94561bd0f1dbc5f2532d49"><div class="ttname"><a href="qep_8hpp.html#ad28acca1ff94561bd0f1dbc5f2532d49">Q_UINT2PTR_CAST</a></div><div class="ttdeci">#define Q_UINT2PTR_CAST(type_, uint_)</div><div class="ttdoc">Perform cast from unsigned integer uint_ to pointer of type type_.</div><div class="ttdef"><b>Definition:</b> <a href="qep_8hpp_source.html#l00117">qep.hpp:117</a></div></div>
<div class="ttc" id="aqk_2qf__port_8hpp_html_a88df5203e3a9716327b58923f5aaac80"><div class="ttname"><a href="qk_2qf__port_8hpp.html#a88df5203e3a9716327b58923f5aaac80">QF_INT_DISABLE</a></div><div class="ttdeci">#define QF_INT_DISABLE()</div><div class="ttdef"><b>Definition:</b> <a href="qk_2qf__port_8hpp_source.html#l00043">qk/qf_port.hpp:43</a></div></div>
<div class="ttc" id="aqk_2qf__port_8hpp_html_ad2d11956704ad838c9c954368d3d37d5"><div class="ttname"><a href="qk_2qf__port_8hpp.html#ad2d11956704ad838c9c954368d3d37d5">QF_INT_ENABLE</a></div><div class="ttdeci">#define QF_INT_ENABLE()</div><div class="ttdef"><b>Definition:</b> <a href="qk_2qf__port_8hpp_source.html#l00044">qk/qf_port.hpp:44</a></div></div>
<div class="ttc" id="aqk_8hpp_html_a4396c0ed924c1f24fd798c572b3e4c18"><div class="ttname"><a href="qk_8hpp.html#a4396c0ed924c1f24fd798c572b3e4c18">QK_ISR_CONTEXT_</a></div><div class="ttdeci">#define QK_ISR_CONTEXT_()</div><div class="ttdoc">Internal port-specific macro that reports the execution context.</div><div class="ttdef"><b>Definition:</b> <a href="qk_8hpp_source.html#l00173">qk.hpp:173</a></div></div>
<div class="ttc" id="aqk_8hpp_html_afe93da1e870c6b1c749d69b01847e85e"><div class="ttname"><a href="qk_8hpp.html#afe93da1e870c6b1c749d69b01847e85e">QK_sched_</a></div><div class="ttdeci">std::uint_fast8_t QK_sched_(void) noexcept</div><div class="ttdoc">QK scheduler finds the highest-priority thread ready to run.</div><div class="ttdef"><b>Definition:</b> <a href="qk_8cpp_source.html#l00329">qk.cpp:329</a></div></div>
<div class="ttc" id="aqk__port_8hpp_html_a18f2cc4dd2d00e3d5efb593d0754a95b"><div class="ttname"><a href="qk__port_8hpp.html#a18f2cc4dd2d00e3d5efb593d0754a95b">QK_ISR_EXIT</a></div><div class="ttdeci">#define QK_ISR_EXIT()</div><div class="ttdoc">Define the ISR exit sequence, if the compiler supports writing interrupts in C++.</div><div class="ttdef"><b>Definition:</b> <a href="qk__port_8hpp_source.html#l00067">qk_port.hpp:67</a></div></div>
<div class="ttc" id="aqk__port_8hpp_html_ad3a6c9c79a8f39f1299196922e3eb6b5"><div class="ttname"><a href="qk__port_8hpp.html#ad3a6c9c79a8f39f1299196922e3eb6b5">QK_ISR_ENTRY</a></div><div class="ttdeci">#define QK_ISR_ENTRY()</div><div class="ttdoc">Define the ISR entry sequence, if the compiler supports writing interrupts in C++.</div><div class="ttdef"><b>Definition:</b> <a href="qk__port_8hpp_source.html#l00056">qk_port.hpp:56</a></div></div>
</div><!-- fragment --><ul class="tag">
<li>
<span class="tag">1</span> The macro <code>QK_ISR_CONTEXT()</code> returns true when the code executes in the ISR context and false otherwise. The macro takes advantage of the ARM Cortex-M register IPSR, which is non-zero when the CPU executes an exception (or interrupt) and is zero when the CPU is executing thread code. <blockquote class="doxtable">
<p>NOTE: QK needs to distinguish between ISR and thread contexts, because threads need to perform synchronous context switch (when a higher-priority thread becomes ready to run), while ISRs should not do that. </p>
</blockquote>
</li>
<li>
<span class="tag">2</span> The inline function <code>QK_get_IPSR()</code> obtains the IPSR register and returns it to the caller. This function is defined explicitly for the GNU-ARM toolchain, but many other toolchains provide this function as an intrinsic, built-in facility.  </li>
<li>
<span class="tag">3</span> The <code><a class="el" href="qk__port_8hpp.html#ad3a6c9c79a8f39f1299196922e3eb6b5" title="Define the ISR entry sequence, if the compiler supports writing interrupts in C++.">QK_ISR_ENTRY()</a></code> macro notifies QK about entering an ISR. The macro is empty, because the determination of the ISR vs thread context is performed independently in the <code>QK_ISR_CONTEXT()</code> macro (see above).  </li>
<li>
<span class="tag">4</span> The <code><a class="el" href="qk__port_8hpp.html#a18f2cc4dd2d00e3d5efb593d0754a95b" title="Define the ISR exit sequence, if the compiler supports writing interrupts in C++.">QK_ISR_EXIT()</a></code> macro notifies QK about exiting an ISR.  </li>
<li>
<span class="tag">5</span> Interrupts are disabled before calling QK scheduler.  </li>
<li>
<span class="tag">6</span> The QK scheduler is called to find out whether an active object of a higher priority than the current one needs activation. The <code><a class="el" href="qk_8hpp.html#afe93da1e870c6b1c749d69b01847e85e" title="QK scheduler finds the highest-priority thread ready to run.">QK_sched_()</a></code> function returns non zero value if this is the case.  </li>
<li>
<span class="tag">7</span> If asynchronous preemption becomes necessary, the code sets the PENDSV Pend bit(28) in the ICSR register (Interrupt Control and State Register). The register is mapped at address 0xE000ED04 in all ARM Cortex-M cores.  </li>
<li>
<span class="tag">8</span> The interrupts are re-enabled after they have been disabled in step [5]. <blockquote class="doxtable">
<p>NOTE: Because the priority of the PendSV exception is the lowest of all interrupts, it is actually triggered only after all nested interrupts exit. The PendSV exception is then entered through the efficient <b>tail-chaining</b> process, which eliminates the restoring and re-entering the interrupt context. </p>
</blockquote>
</li>
</ul>
<h1><a class="anchor" id="arm-cm_qk-qk_impl"></a>
QK Port Implementation for ARM Cortex-M</h1>
<p>The QK port to ARM Cortex-M requires coding the PendSV and NMI exceptions in assembly. This ARM Cortex-M-specific code, as well as QK initialization (<code>QK_init()</code>) is located in the file <span class="img file">Â­ports/arm-cm/Â­qk/Â­gnu/qk_port.c</span></p>
<dl class="section note"><dt>Note</dt><dd>The single assembly module <code>qk_port.s</code> contains common code for all Cortex-M variants (Architecture v6M and v7M) as well as options with and without the VFP. The CPU variants are distinguished by conditional compilation, when necessary.</dd></dl>
<h2><a class="anchor" id="arm-cm_qk_port-asm_init"></a>
QK_init() Implementation</h2>
<p><b>Listing: QK_init() function in qk_port.c file</b> </p><div class="fragment"><div class="line">[1] <span class="keywordtype">void</span> QK_init(<span class="keywordtype">void</span>) {</div>
<div class="line"> </div>
<div class="line">[2] #<span class="keywordflow">if</span> (__ARM_ARCH != 6) <span class="comment">/* NOT Cortex-M0/M0+/M1 (v6-M, v6S-M)? */</span></div>
<div class="line"> </div>
<div class="line">        <a class="code" href="16bit_2stdint_8h.html#a33594304e786b158f3fb30289278f5af">uint32_t</a> n;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* set exception priorities to QF_BASEPRI...</span></div>
<div class="line"><span class="comment">        * SCB_SYSPRI1: Usage-fault, Bus-fault, Memory-fault</span></div>
<div class="line"><span class="comment">        */</span></div>
<div class="line">[3]     SCB_SYSPRI[1] |= (QF_BASEPRI &lt;&lt; 16) | (QF_BASEPRI &lt;&lt; 8) | QF_BASEPRI;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* SCB_SYSPRI2: SVCall */</span></div>
<div class="line">[4]     SCB_SYSPRI[2] |= (QF_BASEPRI &lt;&lt; 24);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* SCB_SYSPRI3:  SysTick, PendSV, Debug */</span></div>
<div class="line">[5]     SCB_SYSPRI[3] |= (QF_BASEPRI &lt;&lt; 24) | (QF_BASEPRI &lt;&lt; 16) | QF_BASEPRI;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* set all implemented IRQ priories to QF_BASEPRI... */</span></div>
<div class="line">[6]     n = 8U + ((*SCnSCB_ICTR &amp; 0x7U) &lt;&lt; 3); <span class="comment">/* (# NVIC_PRIO registers)/4 */</span></div>
<div class="line">        <span class="keywordflow">do</span> {</div>
<div class="line">            --n;</div>
<div class="line">[7]         NVIC_IP[n] = (QF_BASEPRI &lt;&lt; 24) | (QF_BASEPRI &lt;&lt; 16)</div>
<div class="line">                         | (QF_BASEPRI &lt;&lt; 8) | QF_BASEPRI;</div>
<div class="line">        } <span class="keywordflow">while</span> (n != 0);</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">    #endif </span><span class="comment">/* NOT Cortex-M0/M0+/M1(v6-M, v6S-M) */</span><span class="preprocessor"></span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* SCB_SYSPRI3: PendSV set to the lowest priority 0xFF */</span></div>
<div class="line">[8]     SCB_SYSPRI[3] |= (0xFFU &lt;&lt; 16);</div>
<div class="line">    }</div>
</div><!-- fragment --><ul class="tag">
<li>
<span class="tag">1</span> The QK_init() function is called from QF_init() to perform initialization specific to the QK kernel.  </li>
<li>
<span class="tag">2</span> If the ARM Architecture is NOT v6 (Cortex-M0/M0+), that is for Cortex-M3/M4/M7, the function initializes the exception priorities of PendSV and NMI as well as interrupt priorities of all IRQs available in a given MCU. (NOTE: for Cortex-M0/M0+, this initialization is not needed, as the CPU does not support the BASEPRI register and the only way to disable interrupts is via the PRIMASK register. In this case, all interrupts are "kernel-aware" and there is no need to initialize interrupt priorities to a safe value.  </li>
<li>
<span class="tag">3</span> Exception priorities of Usage-fault, Bus-fault, and Memory-fault are set to <a class="el" href="arm-cm_qv.html#QF_BASEPRI">QF_BASEPRI</a>.  </li>
<li>
<span class="tag">4</span> Exception priorities of SVCall is set to <a class="el" href="arm-cm_qv.html#QF_BASEPRI">QF_BASEPRI</a>.  </li>
<li>
<p class="startli"><span class="tag">5</span> Exception priorities of SysTick, PendSV and Debug are set to <a class="el" href="arm-cm_qv.html#QF_BASEPRI">QF_BASEPRI</a>.</p>
<blockquote class="doxtable">
<p><b>NOTE:</b> the exception priority of PedSV is later changed to 0xFF in step [8] </p>
</blockquote>
</li>
<li>
<span class="tag">6</span> The number of implemented interrupts is extraced fom SCnSCB_ICTR register.  </li>
<li>
<span class="tag">7</span> Exception priorities of all implemented interrupts are set to <a class="el" href="arm-cm_qv.html#QF_BASEPRI">QF_BASEPRI</a>.  </li>
<li>
<span class="tag">8</span> Exception priority of PendSV is set to 0xFF, which is the lowest interrupt priority in the system.  </li>
</ul>
<h2><a class="anchor" id="arm-cm_qk_port-asm_pendsv"></a>
PendSV_Handler() Implementation</h2>
<p><b>Listing: PendSV_Handler() and Thread_ret() functions in qk_port.c file</b> </p><div class="fragment"><div class="line"> [1] __attribute__ ((naked))</div>
<div class="line"> [2] <span class="keywordtype">void</span> PendSV_Handler(<span class="keywordtype">void</span>) {</div>
<div class="line"> [3] __asm <span class="keyword">volatile</span> (</div>
<div class="line"> </div>
<div class="line">         <span class="comment">/* Prepare constants in registers before entering critical section */</span></div>
<div class="line"> [4]     <span class="stringliteral">&quot;  LDR     r3,=&quot;</span> STRINGIFY(NVIC_ICSR) <span class="stringliteral">&quot;\n&quot;</span> <span class="comment">/* Interrupt Control and State */</span></div>
<div class="line"> [5]     <span class="stringliteral">&quot;  MOV     r1,#1            \n&quot;</span></div>
<div class="line"> [6]     <span class="stringliteral">&quot;  LSL     r1,r1,#27        \n&quot;</span> <span class="comment">/* r0 := (1 &lt;&lt; 27) (UNPENDSVSET bit) */</span></div>
<div class="line"> </div>
<div class="line">         <span class="comment">/*&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; CRITICAL SECTION BEGIN &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;*/</span></div>
<div class="line"><span class="preprocessor">     #if (__ARM_ARCH == 6)               </span><span class="comment">/* Cortex-M0/M0+/M1 (v6-M, v6S-M)? */</span><span class="preprocessor"></span></div>
<div class="line"> [7]     <span class="stringliteral">&quot;  CPSID   i                \n&quot;</span> <span class="comment">/* disable interrupts (set PRIMASK) */</span></div>
<div class="line"><span class="preprocessor">     #else                               </span><span class="comment">/* M3/M4/M7 */</span><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor">     #if (__ARM_FP != 0)                 </span><span class="comment">/* if VFP available... */</span><span class="preprocessor"></span></div>
<div class="line"> [8]     <span class="stringliteral">&quot;  PUSH    {r0,lr}          \n&quot;</span> <span class="comment">/* ... push lr plus stack-aligner */</span></div>
<div class="line"><span class="preprocessor">     #endif                              </span><span class="comment">/* VFP available */</span><span class="preprocessor"></span></div>
<div class="line"> [9]     <span class="stringliteral">&quot;  MOV     r0,#&quot;</span> STRINGIFY(QF_BASEPRI) <span class="stringliteral">&quot;\n&quot;</span></div>
<div class="line">[10]     <span class="stringliteral">&quot;  CPSID   i                \n&quot;</span> <span class="comment">/* disable interrutps with BASEPRI */</span></div>
<div class="line">[11]     <span class="stringliteral">&quot;  MSR     BASEPRI,r0       \n&quot;</span> <span class="comment">/* apply the Cortex-M7 erraturm */</span></div>
<div class="line">[12]     <span class="stringliteral">&quot;  CPSIE   i                \n&quot;</span> <span class="comment">/* 837070, see ARM-AT610-611. */</span></div>
<div class="line"><span class="preprocessor">     #endif                              </span><span class="comment">/* M3/M4/M7 */</span><span class="preprocessor"></span></div>
<div class="line"> </div>
<div class="line">         <span class="comment">/* The PendSV exception handler can be preempted by an interrupt,</span></div>
<div class="line"><span class="comment">         * which might pend PendSV exception again. The following write to</span></div>
<div class="line"><span class="comment">         * ICSR[27] un-pends any such spurious instance of PendSV.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">[13]     <span class="stringliteral">&quot;  STR     r1,[r3]          \n&quot;</span> <span class="comment">/* ICSR[27] := 1 (unpend PendSV) */</span></div>
<div class="line"> </div>
<div class="line">         <span class="comment">/* The QK activator must be called in a Thread mode, while this code</span></div>
<div class="line"><span class="comment">         * executes in the Handler mode of the PendSV exception. The switch</span></div>
<div class="line"><span class="comment">         * to the Thread mode is accomplished by returning from PendSV using</span></div>
<div class="line"><span class="comment">         * a fabricated exception stack frame, where the return address is</span></div>
<div class="line"><span class="comment">         * QK_activate_().</span></div>
<div class="line"><span class="comment">         *</span></div>
<div class="line"><span class="comment">         * returns with interrupts DISABLED.</span></div>
<div class="line"><span class="comment">         * NOTE: the QK activator is called with interrupts DISABLED and also</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">[14]     <span class="stringliteral">&quot;  LSR     r3,r1,#3         \n&quot;</span> <span class="comment">/* r3 := (r1 &gt;&gt; 3), set the T bit (new xpsr) */</span></div>
<div class="line">[15]     <span class="stringliteral">&quot;  LDR     r2,=QK_activate_ \n&quot;</span> <span class="comment">/* address of QK_activate_ */</span></div>
<div class="line">[16]     <span class="stringliteral">&quot;  SUB     r2,r2,#1         \n&quot;</span> <span class="comment">/* align Thumb-address at halfword (new pc) */</span></div>
<div class="line"> </div>
<div class="line">[17]     <span class="stringliteral">&quot;  LDR     r1,=Thread_ret   \n&quot;</span> <span class="comment">/* return address after the call   (new lr) */</span></div>
<div class="line">[18]     <span class="stringliteral">&quot;  SUB     sp,sp,#8*4       \n&quot;</span> <span class="comment">/* reserve space for exception stack frame */</span></div>
<div class="line">[19]     <span class="stringliteral">&quot;  ADD     r0,sp,#5*4       \n&quot;</span> <span class="comment">/* r0 := 5 registers below the SP */</span></div>
<div class="line">[20]     <span class="stringliteral">&quot;  STM     r0!,{r1-r3}      \n&quot;</span> <span class="comment">/* save xpsr,pc,lr */</span></div>
<div class="line"> </div>
<div class="line">[21]     <span class="stringliteral">&quot;  MOV     r0,#6            \n&quot;</span></div>
<div class="line">[22]     <span class="stringliteral">&quot;  MVN     r0,r0            \n&quot;</span> <span class="comment">/* r0 := ~6 == 0xFFFFFFF9 */</span></div>
<div class="line">[23]     <span class="stringliteral">&quot;  BX      r0               \n&quot;</span> <span class="comment">/* exception-return to the QK activator */</span></div>
<div class="line">         );</div>
<div class="line">     }</div>
<div class="line"> </div>
<div class="line"><span class="comment">     /****************************************************************************/</span></div>
<div class="line">     __attribute__ ((naked))</div>
<div class="line">[24] <span class="keywordtype">void</span> Thread_ret(<span class="keywordtype">void</span>) {</div>
<div class="line">     __asm <span class="keyword">volatile</span> (</div>
<div class="line"> </div>
<div class="line">         <span class="comment">/* After the QK activator returns, we need to resume the preempted</span></div>
<div class="line"><span class="comment">         * thread. However, this must be accomplished by a return-from-exception,</span></div>
<div class="line"><span class="comment">         * while we are still in the thread context. The switch to the exception</span></div>
<div class="line"><span class="comment">         * context is accomplished by triggering the NMI exception.</span></div>
<div class="line"><span class="comment">         * NOTE: The NMI exception is triggered with nterrupts DISABLED,</span></div>
<div class="line"><span class="comment">         * because QK activator disables interrutps before return.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line"> </div>
<div class="line">         <span class="comment">/* before triggering the NMI exception, make sure that the</span></div>
<div class="line"><span class="comment">         * VFP stack frame will NOT be used...</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line"><span class="preprocessor">     #if (__ARM_FP != 0)                 </span><span class="comment">/* if VFP available... */</span><span class="preprocessor"></span></div>
<div class="line">[25]     <span class="stringliteral">&quot;  MRS     r0,CONTROL       \n&quot;</span> <span class="comment">/* r0 := CONTROL */</span></div>
<div class="line">[26]     <span class="stringliteral">&quot;  BICS    r0,r0,#4         \n&quot;</span> <span class="comment">/* r0 := r0 &amp; ~4 (FPCA bit) */</span></div>
<div class="line">[27]     <span class="stringliteral">&quot;  MSR     CONTROL,r0       \n&quot;</span> <span class="comment">/* CONTROL := r0 (clear CONTROL[2] FPCA bit) */</span></div>
<div class="line">[28]     <span class="stringliteral">&quot;  ISB                      \n&quot;</span> <span class="comment">/* ISB after MSR CONTROL (ARM AN321,Sect.4.16) */</span></div>
<div class="line"><span class="preprocessor">     #endif                              </span><span class="comment">/* VFP available */</span><span class="preprocessor"></span></div>
<div class="line"> </div>
<div class="line">         <span class="comment">/* trigger NMI to return to preempted task...</span></div>
<div class="line"><span class="comment">         * NOTE: The NMI exception is triggered with nterrupts DISABLED</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">[29]     <span class="stringliteral">&quot;  LDR     r0,=0xE000ED04   \n&quot;</span> <span class="comment">/* Interrupt Control and State Register */</span></div>
<div class="line">[30]     <span class="stringliteral">&quot;  MOV     r1,#1            \n&quot;</span></div>
<div class="line">[31]     <span class="stringliteral">&quot;  LSL     r1,r1,#31        \n&quot;</span> <span class="comment">/* r1 := (1 &lt;&lt; 31) (NMI bit) */</span></div>
<div class="line">[32]     <span class="stringliteral">&quot;  STR     r1,[r0]          \n&quot;</span> <span class="comment">/* ICSR[31] := 1 (pend NMI) */</span></div>
<div class="line">[33]     <span class="stringliteral">&quot;  B       .                \n&quot;</span> <span class="comment">/* wait for preemption by NMI */</span></div>
<div class="line">         );</div>
<div class="line">     }</div>
</div><!-- fragment --><ul class="tag">
<li>
<span class="tag">1</span> Attribute <code>naked</code> means that the GNU-ARM compiler won't generate any entry/exit code for this function.  </li>
<li>
<span class="tag">2</span> <code>PendSV_Handler</code> is a CMSIS-complinat name of the PendSV exception handler. The <code>PendSV_Handler</code> exception is always entered via tail-chaining from the last nested interrupt.  </li>
<li>
<span class="tag">3</span> Entire body of this function will be defined in this one inline-assembly instruction.  </li>
<li>
<span class="tag">4,5,6</span> Before interrupts are disabled, the following constants are loaded into registers: address of ICSR into r3 and (1&lt;&lt;27) into r1.  </li>
</ul>
<p><b>For the ARMv6-M architecture (Cortex-M0/M0+)...</b> </p><ul class="tag">
<li>
<span class="tag">7</span> Interrupts are globally disabled by setting PRIMASK (see Section 3)  </li>
</ul>
<p><b>Otherwise, for the ARMv7-M architecture (Cortex-M3/4/7) and when the <code>__ARM_FP</code> macro is defined...</b> </p><blockquote class="doxtable">
<p>NOTE: The symbol <code>__ARM_FP</code> is defined by the GNU-ARM compiler when the compile options indicate that the ARM FPU is used. </p>
</blockquote>
<ul class="tag">
<li>
<span class="tag">8</span> The lr register (EXC_RETURN) is pushed to the stack along with r0, to keep the stack aligned at 8-byte boundary. <blockquote class="doxtable">
<p>NOTE: In the presence of the FPU (Cortex-M4F/M7), the EXC_RETURN[4] bit carries the information about the stack frame format used, whereas EXC_RETURN[4] ==0 means that the stack contains room for the S0-S15 and FPSCR registers in addition to the usual R0-R3,R12,LR,PC,xPSR registers. This information must be preserved, in order to properly return from the exception at the end. </p>
</blockquote>
</li>
<li>
<span class="tag">9</span> For the ARMv7-M architecture (Cortex-M3/M4), interrupts are selectively disabled by setting the BASEPRI register. <blockquote class="doxtable">
<p>NOTE: The value moved to BASEPRI must be identical to the <a class="el" href="arm-cm_qv.html#QF_BASEPRI">QF_BASEPRI</a> macro defined in <code>qf_port.h</code>. </p>
</blockquote>
</li>
<li>
<span class="tag">10</span> Before setting the BASEPRI register, interrupts are disabled with the PRIMASK register, which is the recommended workaround for the Cortex-M7 r0p1 hardware bug, as described in the ARM Ltd. [<a class="el" href="arm-cm.html#ARM-AT610-611">ARM-AT610-611</a>], Erratum 837070.  </li>
<li>
<span class="tag">11</span> The BASEPRI register is set to the <a class="el" href="arm-cm_qv.html#QF_BASEPRI">QF_BASEPRI</a> value.  </li>
<li>
<span class="tag">12</span> After setting the BASEPRI register, interrupts are re-anabed with the PRIMASK register, which is the recommended workaround for the Cortex-M7 r0p1 hardware bug, as described in the ARM Ltd. [<a class="el" href="arm-cm.html#ARM-AT610-611">ARM-AT610-611</a>], Erratum 837070.  </li>
<li>
<span class="tag">13</span> The PendSV exception is <b>explicitly</b> un-pended. <blockquote class="doxtable">
<p>NOTE: The PendSV exception handler can be preempted by an interrupt, which might pend PendSV exception again. This would trigger PendSV incorrectly again immediately after calling QK activator. </p>
</blockquote>
</li>
</ul>
<p>The following code [14-23] fabricates an exception stack frame, to perform an exception-return to the QK activator without destroying the original exception stack frame of the PendSV exception. This is necessary to preserve the context of the preempted code. </p><ul class="tag">
<li>
<span class="tag">14</span> The value (1 &lt;&lt; 24) is synthesized in r3 from the value (1 &lt;&lt; 27) already available in r1. This value is going to be stacked and later restored to xPSR register (only the T bit set).  </li>
<li>
<span class="tag">15</span> The address of the QK activator function <code><a class="el" href="qk_8hpp.html#a66f8c70043c85b83fee5fc6eab93d8ba" title="QK activator activates the next active object. The activated AO preempts.">QK_activate_()</a></code> is loaded into r2. This will be pushed to the stack as the PC register value.  </li>
<li>
<span class="tag">16</span> The address of the QK activator function <code><a class="el" href="qk_8hpp.html#a66f8c70043c85b83fee5fc6eab93d8ba" title="QK activator activates the next active object. The activated AO preempts.">QK_activate_()</a></code> in r2 is adjusted to be half-word aligned instead of being an odd THUMB address. <blockquote class="doxtable">
<p>NOTE: This is necessary, because the value will be loaded directly to the PC, which cannot accept odd values. </p>
</blockquote>
</li>
<li>
<span class="tag">17</span> The address of the <code>Thread_ret()</code> function is loaded into r1. This will be pushed to the stack as the lr register value. <blockquote class="doxtable">
<p>NOTE: The address of the <code>Thread_ret</code> label must be a THUMB address, that is, the least-significant bit of this address must be set (this address must be odd number). This is essential for the correct return of the QK activator with setting the THUMB bit in the PSR. Without the LS-bit set, the ARM Cortex-M CPU will clear the T bit in the PSR and cause the Hard Fault. The GNU-ARM assembler/linker will synthesize the correct THUMB address of the svc_ret label only if this label is declared with the <code>.type Thread_ret , function</code> attribute (see step [23]). </p>
</blockquote>
</li>
<li>
<span class="tag">18</span> The stack pointer is adjusted to leave room for 8 registers.  </li>
<li>
<span class="tag">19</span> The top of stack, adjusted by 5 registers, (r0, r1, r2, r3, and r12) is stored to r0.  </li>
<li>
<span class="tag">20</span> The values of xpsr, pc, and lr prepared in r3, r2, and r1, respectively, are pushed on the top of stack (now in r0). This operation completes the synthesis of the exception stack frame. After this step the stack looks as follows: <pre>
Hi memory
           (optionally S0-S15, FPSCR), if EXC_RETURN[4]==0
           xPSR
           pc (interrupt return address)
           lr
           r12
           r3
           r2
           r1
           r0
           EXC_RETURN (pushed in step [7] if FPU is present)
old SP --&gt; "aligner"  (pushed in step [7] if FPU is present)
           xPSR == 0x01000000
           PC == QK_activate_
           lr == Thread_ret
           r12  don't care
           r3   don't care
           r2   don't care
           r1   don't care
    SP --&gt; r0   don't care
Low memory
</pre>  </li>
<li>
<p class="startli"><span class="tag">21-22</span> The special exception-return value 0xFFFFFFF9 is synthesized in r0 (two instructions are used to make the code compatible with Cortex-M0, which has no barrel shifter). </p><blockquote class="doxtable">
<p>NOTE: the r0 register is used instead of lr because the Cortex-M0 instruction set cannot manipulate the higher-registers (r9-r15). NOTE: The exception-return value is consistent with the synthesized stack-frame with the lr[4] bit set to 1, which means that the FPU registers are not included in this stack frame. </p>
</blockquote>
<p class="endli"></p>
</li>
<li>
<p class="startli"><span class="tag">23</span> PendSV exception returns using the special value of the r0 register of 0xFFFFFFF9 (return to Privileged Thread mode using the Main Stack pointer). The synthesized stack frame causes actually a function call to QK_sched_ function in C. </p><blockquote class="doxtable">
<p>NOTE: The return from the PendSV exception just executed switches the ARM Cortex-M core to the Privileged Thread mode. The QK_sched_ function internally re-enables interrupts before launching any thread, so the threads always run in the Thread mode with interrupts enabled and can be preempted by interrupts of any priority. NOTE: In the presence of the FPU, the exception-return to the QK activator does not change any of the FPU status bit, such as CONTROL.FPCA or LSPACT. </p>
</blockquote>
<p class="endli"></p>
</li>
<li>
<span class="tag">24</span> The <code>Thread_ret</code> function is the place, where the QK activator <code><a class="el" href="qk_8hpp.html#a66f8c70043c85b83fee5fc6eab93d8ba" title="QK activator activates the next active object. The activated AO preempts.">QK_activate_()</a></code> returns to, because this return address is pushed to the stack in step [16]. Please note that the address of the <code>Thread_ret</code> label must be a THUMB address.  </li>
<li>
<span class="tag">25-28</span> If the FPU is present, the read-modify-write code clears the CONTROL[2] bit [2]. This bit, called CONTROL.FPCA (Floating Point Active), would cause generating the FPU-type stack frame, which you want to avoid in this case (because the NMI exception will certainly not use the FPU). <blockquote class="doxtable">
<p>NOTE: Clearing the CONTROL.FPCA bit occurs with interrupts disabled, so it is protected from a context switch. </p>
</blockquote>
</li>
<li>
<span class="tag">28-32</span> The asynchronous NMI exception is triggered by setting ICSR[31]. The job of this exception is to put the CPU into the exception mode and correctly return to the thread level.  </li>
<li>
<span class="tag">33</span> This endless loop should not be reached, because the NMI exception should preempt the code immediately after step [31]  </li>
</ul>
<h2><a class="anchor" id="arm-cm_qk_port-asm_nmi"></a>
NMI_Handler() Implementation</h2>
<p><b>Listing: NMI_Handler() function in qk_port.c file</b> </p><div class="fragment"><div class="line">    __attribute__ ((naked))</div>
<div class="line">[1] <span class="keywordtype">void</span> NMI_Handler(<span class="keywordtype">void</span>) {</div>
<div class="line">    __asm <span class="keyword">volatile</span> (</div>
<div class="line"> </div>
<div class="line">[2]     <span class="stringliteral">&quot;  ADD     sp,sp,#(8*4)     \n&quot;</span> <span class="comment">/* remove one 8-register exception frame */</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">    #if (__ARM_ARCH == 6)               </span><span class="comment">/* Cortex-M0/M0+/M1 (v6-M, v6S-M)? */</span><span class="preprocessor"></span></div>
<div class="line">[3]     <span class="stringliteral">&quot;  CPSIE   i                \n&quot;</span> <span class="comment">/* enable interrupts (clear PRIMASK) */</span></div>
<div class="line">[4]     <span class="stringliteral">&quot;  BX      lr               \n&quot;</span> <span class="comment">/* return to the preempted task */</span></div>
<div class="line"><span class="preprocessor">    #else                               </span><span class="comment">/* M3/M4/M7 */</span><span class="preprocessor"></span></div>
<div class="line">[5]     <span class="stringliteral">&quot;  MOV     r0,#0            \n&quot;</span></div>
<div class="line">[6]     <span class="stringliteral">&quot;  MSR     BASEPRI,r0       \n&quot;</span> <span class="comment">/* enable interrupts (clear BASEPRI) */</span></div>
<div class="line"><span class="preprocessor">    #if (__ARM_FP != 0)                 </span><span class="comment">/* if VFP available... */</span><span class="preprocessor"></span></div>
<div class="line">[7]     <span class="stringliteral">&quot;  POP     {r0,pc}          \n&quot;</span> <span class="comment">/* pop stack aligner and EXC_RETURN to PC */</span></div>
<div class="line"><span class="preprocessor">    #else                               </span><span class="comment">/* no VFP */</span><span class="preprocessor"></span></div>
<div class="line">[8]     <span class="stringliteral">&quot;  BX      lr               \n&quot;</span> <span class="comment">/* return to the preempted task */</span></div>
<div class="line"><span class="preprocessor">    #endif                              </span><span class="comment">/* no VFP */</span><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor">    #endif                              </span><span class="comment">/* M3/M4/M7 */</span><span class="preprocessor"></span></div>
<div class="line">        );</div>
<div class="line">    }</div>
</div><!-- fragment --><ul class="tag">
<li>
<span class="tag">1</span> The <code>NMI_Handler</code> is the CMSIS-compliant name of the NMI exception handler. This exception is triggered after returning from the QK activator in step [31] of the previous listing. The job of NMI is to discard its own stack frame and cause the exception-return to the original preempted thread context. The stack contents just after entering NMI is shown below: <pre>
Hi memory
           (optionally S0-S15, FPSCR), if EXC_RETURN[4]==0
           xPSR
           pc (interrupt return address)
           lr
           r12
           r3
           r2
           r1
           r0
old SP --&gt; EXC_RETURN (pushed in PendSV [7] if FPU is present)
           "aligner"  (pushed in PendSV [7] if FPU is present)
           xPSR don't care
           PC   don't care
           lr   don't care
           r12  don't care
           r3   don't care
           r2   don't care
           r1   don't care
    SP --&gt; r0   don't care
Low memory
</pre>  </li>
<li>
<span class="tag">2</span> The stack pointer is adjusted to un-stack the 8 registers of the interrupt stack frame corresponding to the NMI exception itself. This moves the stack pointer from the "old SP" to "SP" in the picture above, which "uncovers" the original exception stack frame left by the PendSV exception.  </li>
<li>
<span class="tag">3</span> For ARMv6-M, interrupts are enabled by clearing the PRIMASK.  </li>
<li>
<span class="tag">4</span> For ARMv6-M, The NMI exception returns to the preempted thread using the standard EXC_RETURN, which is in lr.  </li>
<li>
<span class="tag">5-6</span> For the ARMv7-M, interrupts are enabled by writing 0 into the BASEPRI register.  </li>
<li>
<span class="tag">7</span> If the FPU is used, the EXC_RETURN and the "stack aligner" saved in PendSV step [7] are popped from the stack into r0 and pc, respectively. Updating the pc causes the return from PendSV.  </li>
<li>
<span class="tag">8</span> Otherwise, NMI returns to the preempted thread using the standard EXC_RETURN, which is in lr.  </li>
</ul>
<p><a class="anchor" id="qk_stack-detail"></a></p><div class="image">
<img src="qk_stack-detail.gif" alt=""/>
<div class="caption">
Detailed stack allocation in QK for ARM Cortex-M</div></div>
<h1><a class="anchor" id="arm-cm_qk-isr"></a>
Writing ISRs for QK</h1>
<p>The ARM Cortex-M CPU is designed to use regular C functions as exception and interrupt service routines (ISRs).</p>
<dl class="section note"><dt>Note</dt><dd>The ARM EABI (Embedded Application Binary Interface) requires the stack be 8-byte aligned, whereas some compilers guarantee only 4-byte alignment. For that reason, some compilers (e.g., GNU-ARM) provide a way to designate ISR functions as interrupts. For example, the GNU-ARM compiler provides the <code>__attribute__((__interrupt__))</code> designation that will guarantee the 8-byte stack alignment.</dd></dl>
<p>Typically, ISRs are application-specific (with the main purpose to produce events for active objects). Therefore, ISRs are not part of the generic <a class="el" href="namespace_q_p.html" title="namespace associated with the QP/C++ framework">QP</a> port, but rather part of the BSP (Board Support Package).</p>
<p>The following listing shows an example of the <code>SysTick_Handler()</code> ISR (from the DPP example application). This ISR calls the <code>QF_TICK_X()</code> macro to perform QF time-event management.</p>
<p><a class="anchor" id="arm-cm_qk-isr-code"></a><b>Listing: An ISR header for QK</b> </p><div class="fragment"><div class="line">    <span class="keywordtype">void</span> SysTick_Handler(<span class="keywordtype">void</span>) __attribute__((__interrupt__));</div>
<div class="line">    <span class="keywordtype">void</span> SysTick_Handler(<span class="keywordtype">void</span>) {</div>
<div class="line">         ~ ~ ~</div>
<div class="line">[1]      <a class="code" href="qk__port_8hpp.html#ad3a6c9c79a8f39f1299196922e3eb6b5">QK_ISR_ENTRY</a>();   <span class="comment">/* inform QK about entering an ISR */</span></div>
<div class="line">         ~ ~ ~</div>
<div class="line">         QF_TICK_X(0U, &amp;l_SysTick_Handler); <span class="comment">/* process all armed time events */</span></div>
<div class="line">         ~ ~ ~</div>
<div class="line">[2]      <a class="code" href="qk__port_8hpp.html#a18f2cc4dd2d00e3d5efb593d0754a95b">QK_ISR_EXIT</a>();    <span class="comment">/* inform QK about exiting an ISR */</span></div>
<div class="line">    }</div>
</div><!-- fragment --><ul class="tag">
<li>
<span class="tag">1</span> Every ISR for QK must call <code><a class="el" href="qk__port_8hpp.html#ad3a6c9c79a8f39f1299196922e3eb6b5" title="Define the ISR entry sequence, if the compiler supports writing interrupts in C++.">QK_ISR_ENTRY()</a></code> before calling any <a class="el" href="namespace_q_p.html" title="namespace associated with the QP/C++ framework">QP</a> API  </li>
<li>
<span class="tag">2</span> Every ISR for QK must call <code><a class="el" href="qk__port_8hpp.html#a18f2cc4dd2d00e3d5efb593d0754a95b" title="Define the ISR exit sequence, if the compiler supports writing interrupts in C++.">QK_ISR_EXIT()</a></code> right before exiting to let the QK kernel schedule an asynchronous preemption, if necessary.  </li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The QK port to ARM Cortex-M complies with the requirement of the ARM-EABI to preserve stack pointer alignment at <b>8-byte boundary</b>. Also, all <a class="el" href="namespace_q_p.html" title="namespace associated with the QP/C++ framework">QP</a> examples for ARM Cortex-M comply with the CMSIS naming convention for all exception handlers and IRQ handlers.</dd></dl>
<h1><a class="anchor" id="arm-cm_qk-fpu"></a>
Using the FPU in the QK Port (Cortex-M4F/M7)</h1>
<p>If you have the Cortex-M4F CPU and your application uses the hardware FPU, it should be enabled because it is turned off out of reset. The CMSIS-compliant way of turning the FPU on looks as follows:</p>
<pre class="fragment">    SCB-&gt;CPACR |= (0xFU &lt;&lt; 20);
</pre><dl class="section note"><dt>Note</dt><dd>The FPU must be enabled before executing any floating point instruction. An attempt to execute a floating point instruction will fault if the FPU is not enabled.</dd></dl>
<p>Depending on wheter or not you use the FPU in your ISRs, the "Vanilla" <a class="el" href="namespace_q_p.html" title="namespace associated with the QP/C++ framework">QP</a> port allows you to configure the FPU in various ways, as described in the following sub-sections.</p>
<h2><a class="anchor" id="arm-cm_qk-fpu_1thread"></a>
FPU used in ONE thread only and not in any ISR</h2>
<p>If you use the FPU only at a single thread (active object) and none of your ISRs use the FPU, you can setup the FPU not to use the automatic state preservation and not to use the lazy stacking feature as follows:</p>
<pre class="fragment">    FPU-&gt;FPCCR &amp;= ~((1U &lt;&lt; FPU_FPCCR_ASPEN_Pos) | (1U &lt;&lt; FPU_FPCCR_LSPEN_Pos));
</pre><p>With this setting, the Cortex-M4F processor handles the ISRs in the exact-same way as Cortex-M0-M3, that is, only the standard interrupt frame with R0-R3,R12,LR,PC,xPSR is used. This scheme is the fastest and incurs no additional CPU cycles to save and restore the FPU registers.</p>
<dl class="section note"><dt>Note</dt><dd>This FPU setting will lead to FPU errors, if more than one thread or any of the ISRs indeed start to use the FPU</dd></dl>
<h2><a class="anchor" id="arm-cm_qk-fpu_nthreadd"></a>
FPU used in more than one thread only or the ISR</h2>
<p>If you use the FPU in more than one of the threads (active objects) or in any of your ISRs, you should setup the FPU to use the automatic state preservation and the lazy stacking feature as follows: </p><pre class="fragment">FPU-&gt;FPCCR |= (1U &lt;&lt; FPU_FPCCR_ASPEN_Pos) | (1U &lt;&lt; FPU_FPCCR_LSPEN_Pos);
</pre><p> This is actually the default setting of the hardware FPU and is recommended for the QK port, because it is safer in view of code evolution. Future changes to the application can easily introduce FPU use in multiple active objects, which would be unsafe if the FPU context was not preserved automatically.</p>
<dl class="section note"><dt>Note</dt><dd>As described in the ARM Application Note "Cortex-M4(F) Lazy Stacking and Context Switching" [<a class="el" href="arm-cm.html#ARM-AN298">ARM-AN298</a>], the FPU automatic state saving requires more stack plus additional CPU time to save the FPU registers, but only when the FPU is actually used.</dd></dl>
<h1><a class="anchor" id="arm-cm_qk-idle"></a>
QK Idle Processing Customization in QK_onIdle()</h1>
<p>QK can very easily detect the situation when no events are available, in which case QK calls the <code>QK_onIdle()</code> callback. You can use <code>QK_onIdle()</code> to suspended the CPU to save power, if your CPU supports such a power-saving mode. Please note that <code>QK_onIdle()</code> is called repetitively from an endless loop, which is the QK idle-thread. The <code>QK_onIdle()</code> callback is called with interrupts <b>enabled</b> (which is in contrast to the <a class="el" href="arm-cm_qv.html#arm-cm_qv-idle">QV_onIdle() callback</a> used in the non-preemptive configuration).</p>
<p>The THUMB-2 instruction set used exclusively in ARM Cortex-M provides a special instruction WFI (Wait-for-Interrupt) for stopping the CPU clock, as described in the "ARMv7-M Reference Manual" [ARM 06a]. The following listing shows the <code>QK_onIdle()</code> callback that puts ARM Cortex-M into a low-power mode.</p>
<p><a class="anchor" id="arm-cm_qk_onidle-code"></a><b>Listing: QV_onIdle() for ARM Cortex-M</b> </p><div class="fragment"><div class="line">[1] <span class="keywordtype">void</span> QK_onIdle(<span class="keywordtype">void</span>) {</div>
<div class="line">         ~ ~ ~</div>
<div class="line">[2] #<span class="keywordflow">if</span> defined NDEBUG</div>
<div class="line">        <span class="comment">/* Put the CPU and peripherals to the low-power mode.</span></div>
<div class="line"><span class="comment">        * you might need to customize the clock management for your application,</span></div>
<div class="line"><span class="comment">        * see the datasheet for your particular Cortex-M3 MCU.</span></div>
<div class="line"><span class="comment">        */</span></div>
<div class="line">[3]     __WFI(); <span class="comment">/* Wait-For-Interrupt */</span></div>
<div class="line"><span class="preprocessor">    #endif</span></div>
<div class="line"><span class="preprocessor">    }</span></div>
</div><!-- fragment --><ul class="tag">
<li>
<span class="tag">1</span> The preemptive QK kernel calls the <code>QK_onIdle()</code> callback with interrupts enabled.  </li>
<li>
<span class="tag">2</span> The sleep mode is used only in the non-debug configuration, because sleep mode stops CPU clock, which can interfere with debugging.  </li>
<li>
<span class="tag">3</span> The <code>WFI</code> instruction is generated using inline assembly.  </li>
</ul>
<h1><a class="anchor" id="arm-cm_qk-testing"></a>
Testing QK Preemption Scenarios</h1>
<p>The <code>bsp.c</code> file included in the <span class="img folder">examples/arm-cm/dpp_ek-tm4c123gxl/qk</span> directory contains special instrumentation (an ISR designed for testing) for convenient testing of <a class="el" href="arm-cm_qk.html#arm-cm_qk-arm-cm-fig">various preemption scenarios in QK</a>.</p>
<p>The technique described in this section will allow you to trigger an interrupt at any machine instruction and observe the preemption it causes. The interrupt used for the testing purposes is the GPIOA interrupt (INTID == 0). The ISR for this interrupt is shown below:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> GPIOPortA_IRQHandler(<span class="keywordtype">void</span>) {</div>
<div class="line">    <a class="code" href="qk__port_8hpp.html#ad3a6c9c79a8f39f1299196922e3eb6b5">QK_ISR_ENTRY</a>(); <span class="comment">/* inform QK about entering an ISR */</span></div>
<div class="line">    QACTIVE_POST(AO_Table, <a class="code" href="qf_8hpp.html#abd823f3a9e8b3206a3460a108d5fa3e3">Q_NEW</a>(QEvt, MAX_PUB_SIG), <span class="comment">/* for testing... */</span></div>
<div class="line">                 &amp;l_GPIOPortA_IRQHandler);</div>
<div class="line">    <a class="code" href="qk__port_8hpp.html#a18f2cc4dd2d00e3d5efb593d0754a95b">QK_ISR_EXIT</a>();  <span class="comment">/* inform QK about exiting an ISR */</span></div>
<div class="line">}</div>
<div class="ttc" id="aqf_8hpp_html_abd823f3a9e8b3206a3460a108d5fa3e3"><div class="ttname"><a href="qf_8hpp.html#abd823f3a9e8b3206a3460a108d5fa3e3">Q_NEW</a></div><div class="ttdeci">#define Q_NEW(evtT_, sig_)</div><div class="ttdoc">Allocate a dynamic event.</div><div class="ttdef"><b>Definition:</b> <a href="qf_8hpp_source.html#l00715">qf.hpp:715</a></div></div>
</div><!-- fragment --><p><code>GPIOPortA_IRQHandler()</code>, as all interrupts in the system, invokes the macros <a class="el" href="qk__port_8hpp.html#ad3a6c9c79a8f39f1299196922e3eb6b5" title="Define the ISR entry sequence, if the compiler supports writing interrupts in C++.">QK_ISR_ENTRY()</a> and <a class="el" href="qk__port_8hpp.html#a18f2cc4dd2d00e3d5efb593d0754a95b" title="Define the ISR exit sequence, if the compiler supports writing interrupts in C++.">QK_ISR_EXIT()</a>, and also posts an event to the Table active object, which has higher priority than any of the Philo active object.</p>
<p>The figure below hows how to trigger the GPIOA interrupt from the CCS debugger. From the debugger you need to first open the register window and select NVIC registers from the drop-down list (see right-bottom corner of Figure 6).You scroll to the NVIC_SW_TRIG register, which denotes the Software Trigger Interrupt Register in the NVIC. This write-only register is useful for software-triggering various interrupts by writing various masks to it. To trigger the GPIOA interrupt you need to write 0x00 to the NVIC_SW_TRIG by clicking on this field, entering the value, and pressing the Enter key.</p>
<div class="image">
<img src="arm-cm_qk_test-ccs.png" alt=""/>
<div class="caption">
Triggering the GPIOA interrupt from Eclipse debugger</div></div>
<p>The general testing strategy is to break into the application at an interesting place for preemption, set breakpoints to verify which path through the code is taken, and trigger the GPIO interrupt. Next, you need to free-run the code (donâ€™t use single stepping) so that the NVIC can perform prioritization. You observe the order in which the breakpoints are hit. This procedure will become clearer after a few examples.</p>
<h2><a class="anchor" id="arm-cm_qk-test-isr"></a>
Interrupt Nesting Test</h2>
<p>The first interesting test is verifying the correct tail-chaining to the PendSV exception after the interrupt nesting occurs, as shown in <a class="el" href="arm-cm_qk.html#arm-cm_qk-synch-fig">Synchronous Preemption in QK</a>. To test this scenario, you place a breakpoint inside the <code>GPIOPortA_IRQHandler()</code> and also inside the <code>SysTick_Handler()</code> ISR. When the breakpoint is hit, you remove the original breakpoint and place another breakpoint at the very next machine instruction (use the Disassembly window) and also another breakpoint on the first instruction of the <code>QK_PendSV</code> handler. Next you trigger the PIOINT0 interrupt per the instructions given in the previous section. You hit the Run button.</p>
<p>The pass criteria of this test are as follows:</p>
<ol type="1">
<li>The first breakpoint hit is the one inside the <code>GPIOPortA_IRQHandler()</code> function, which means that GPIO ISR preempted the SysTick ISR.</li>
<li>The second breakpoint hit is the one in the <code>SysTick_Handler()</code>, which means that the SysTick ISR continues after the PIOINT0 ISR completes.</li>
<li>The last breakpoint hit is the one in <code>PendSV_Handler()</code> exception handler, which means that the PendSV exception is tail-chained only after all interrupts are processed. You need to remove all breakpoints before proceeding to the next test.</li>
</ol>
<h2><a class="anchor" id="arm-cm_qk-test-thread"></a>
Thread Preemption Test</h2>
<p>The next interesting test is verifying that threads can preempt each other. You set a breakpoint anywhere in the Philosopher state machine code. You run the application until the breakpoint is hit. After this happens, you remove the original breakpoint and place another breakpoint at the very next machine instruction (use the Disassembly window). You also place a breakpoint inside the <code>GPIOPortA_IRQHandler()</code> interrupt handler and on the first instruction of the <code>PendSV_Handler()</code> handler. Next you trigger the GPIOA interrupt per the instructions given in the previous section. You hit the Run button.</p>
<p>The pass criteria of this test are as follows:</p>
<ol type="1">
<li>The first breakpoint hit is the one inside the <code>GPIOPortA_IRQHandler()</code> function, which means that GPIO ISR preempted the Philo thread.</li>
<li>The second breakpoint hit is the one in <code>PendSV_Handler()</code> exception handler, which means that the PendSV exception is activated before the control returns to the preempted Philosopher thread.</li>
<li>After hitting the breakpoint in <code>PendSV_Handler()</code>, you single step into <code><a class="el" href="qk_8hpp.html#a66f8c70043c85b83fee5fc6eab93d8ba" title="QK activator activates the next active object. The activated AO preempts.">QK_activate_()</a></code>. You verify that the activator invokes a state handler from the Table state machine. This proves that the Table thread preempts the Philo thread.</li>
<li>After this you free-run the application and verify that the next breakpoint hit is the one inside the Philosopher state machine. This validates that the preempted thread continues executing only after the preempting thread (the Table state machine) completes.</li>
</ol>
<h2><a class="anchor" id="arm-cm_qk-test-fpu"></a>
Testing the FPU (Cortex-M4F/M7)</h2>
<p>In order to test the FPU, the Board Support Package (BSP) for the Cortex-M4F EK-TM4C123GXL board uses the FPU in the following contexts:</p>
<ul>
<li>In the idle loop via the <code>QK_onIdle()</code> callback (<a class="el" href="namespace_q_p.html" title="namespace associated with the QP/C++ framework">QP</a> priority 0)</li>
<li>In the thread level via the <code>BSP_random()</code> function called from all five Philo active objects (<a class="el" href="namespace_q_p.html" title="namespace associated with the QP/C++ framework">QP</a> priorities 1-5).</li>
<li>In the thread level via the <code>BSP_displayPhiloStat()</code> function called from the Table active object (<a class="el" href="namespace_q_p.html" title="namespace associated with the QP/C++ framework">QP</a> priorty 6)</li>
<li>In the ISR level via the <code>SysTick_Handler()</code> ISR (priority above all threads)</li>
</ul>
<p>To test the FPU, you could step through the code in the debugger and verify that the expected FPU-type exception stack frame is used and that the FPU registers are saved and restored by the "lazy stacking feature" when the FPU is actually used.</p>
<p>Next, you can selectively comment out the FPU code at various levels of priority and verify that the QK context switching works as expected with both types of exception stak frames (with and without the FPU).</p>
<h2><a class="anchor" id="arm-cm_qk-test-other"></a>
Other Tests</h2>
<p>Other interesting tests that you can perform include changing priority of the GPIOA interrupt to be lower than the priority of SysTick to verify that the PendSV is still activated only after all interrupts complete.</p>
<p>In yet another test you could post an event to Philosopher active object rather than Table active object from the <code>GPIOPortA_IRQHandler()</code> function to verify that the QK activator will not preempt the Philosopher thread by itself. Rather the next event will be queued and the Philosopher thread will process the queued event only after completing the current event processing.</p>
<hr  />
<p><b>Next:</b> <a class="el" href="arm-cm_qxk.html">Preemptive "Dual-Mode" QXK Kernel</a></p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
    <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
      <ul>
        <li class="footer">
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; 2005-2021 Quantum Leaps</a> &nbsp;| &nbsp; <a title="help" href="help.html">Using Online Help</a>&nbsp;| &nbsp;<a title="Doxygen" href="http://www.doxygen.nl">Generated with Doxygen</a>&nbsp; | &nbsp;<b>QP/C++ 6.9.3</b>
<hr class="footer"/><address class="footer"><small>
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; Quantum Leaps 2020</a> &nbsp;| &nbsp; <a title="help" href="help.html">Using Online Help</a>&nbsp;| &nbsp;<a title="Doxygen" href="http://www.doxygen.nl">Generated with Doxygen</a>&nbsp; | &nbsp;<b>QP/C++ 6.9.3</b>
</small></address>
        </li>
      </ul>
    </div>
    <script src="custom.js"></script>
  </body>
</html>
