<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QP/C++: API Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
  <a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">
    <img id="logo" src="img/logo_ql.png" alt="Quantum Leaps">
  </a>
  <span id="projectname">QP/C++</span>
  <span id="projectnumber">6.9.3</span>
           <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)"
               onblur="searchBox.OnSearchFieldFocus(false)"
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;"
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('api.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0"
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">API Reference </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#api_qep">QEP (Hierarchical State Machines)</a><ul><li class="level2"><a href="#api_qep_hsm">Hierarchical State Machines</a></li>
</ul>
</li>
<li class="level1"><a href="#api_qf">QF (Active Object Framework)</a><ul><li class="level2"><a href="#api_qf_act">Active Objects</a></li>
<li class="level2"><a href="#api_qf_ps">Publish-Subscribe</a></li>
<li class="level2"><a href="#api_qf_evt">Dynamic Events</a></li>
<li class="level2"><a href="#api_qf_time">Time Events</a></li>
<li class="level2"><a href="#api_qf_queue">Event Queues (raw thread-safe)</a></li>
<li class="level2"><a href="#api_qf_mem">Memory Pools</a></li>
</ul>
</li>
<li class="level1"><a href="#api_qs">QS (&quot;Quantum Spy&quot; Software Tracing)</a><ul><li class="level2"><a href="#api_qs_ini">QS Initialization and Control</a></li>
<li class="level2"><a href="#api_qs_rx">QS Receive-Channel (QS-RX)</a></li>
<li class="level2"><a href="#api_qs_filter">QS Filters</a></li>
<li class="level2"><a href="#api_qs_dict">QS Dictionaries</a></li>
<li class="level2"><a href="#api_qs_user">QS Application-Specific Records</a></li>
</ul>
</li>
<li class="level1"><a href="#api_qv">QV (Cooperative Kernel)</a><ul><li class="level2"><a href="#api_qv_init">Kernel Initialization and Control</a></li>
</ul>
</li>
<li class="level1"><a href="#api_qk">QK (Preemptive Run-to-Completion Kernel)</a><ul><li class="level2"><a href="#api_qk_ctrl">Kernel Initialization and Control</a></li>
<li class="level2"><a href="#api_qk_isr">Interrupt Management</a></li>
</ul>
</li>
<li class="level1"><a href="#api_qxk">QXK (Preemptive Dual-Mode Run-to-Completion/Blocking RTOS Kernel)</a><ul><li class="level2"><a href="#api_qxk_ctrl">Kernel Initialization and Control</a></li>
<li class="level2"><a href="#api_qxk_isr">Interrupt Management</a></li>
<li class="level2"><a href="#api_qxk_xthr">Extended Thread Management</a></li>
<li class="level2"><a href="#api_qxk_sema">Semaphores</a></li>
<li class="level2"><a href="#api_qxk_mutex">Mutexes</a></li>
<li class="level2"><a href="#api_qxk_queue">Message Queues</a></li>
<li class="level2"><a href="#api_qxk_mem">Memory Pools</a></li>
<li class="level2"><a href="#api_qxk_tls">Thread-Local Storage</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="api_qep"></a>
QEP (Hierarchical State Machines)</h1>
<p><a class="el" href="class_q_p_1_1_q_e_p.html" title="Provides miscellaneous QEP services.">QEP</a> is a universal, UML-compliant event processor that enables developers to code UML state machines in highly readable ANSI-C, in which every state machine element is mapped to code precisely, unambiguously, and exactly once (traceability). <a class="el" href="class_q_p_1_1_q_e_p.html" title="Provides miscellaneous QEP services.">QEP</a> fully supports hierarchical state nesting, which is the fundamental mechanism for reusing behavior across many states instead of repeating the same actions and transitions over and over again.</p>
<h2><a class="anchor" id="api_qep_hsm"></a>
Hierarchical State Machines</h2>
<ul>
<li><a class="el" href="class_q_p_1_1_q_hsm.html" title="Hierarchical State Machine base class.">QHsm</a> class</li>
<li><a class="el" href="class_q_p_1_1_q_hsm.html#af86853ccd1fb112ab6a6ae0089a9f606" title="Protected constructor of QHsm.">QHsm::QHsm()</a></li>
<li><a class="el" href="class_q_p_1_1_q_hsm.html#a8eaa1eb21e68e8dd26f080624cad83cd" title="executes the top-most initial transition in QP::QHsm">QHsm::init()</a></li>
<li><a class="el" href="class_q_p_1_1_q_hsm.html#a4be5d9e5ceb53df30eb02f299e5a41fc" title="Dispatches an event to QHsm.">QHsm::dispatch()</a></li>
<li><a class="el" href="class_q_p_1_1_q_hsm.html#ad723869e5257b9977d917593a38bdf56" title="Tests if a given state is part of the current active state configuration.">QHsm::isIn()</a></li>
<li><a class="el" href="class_q_p_1_1_q_hsm.html#ac46d83d0f84d0a808ab653235b3e8ec1" title="Obtain the current state (state handler function)">QHsm::state()</a></li>
<li><a class="el" href="class_q_p_1_1_q_hsm.html#a5aa539b182024035d3c5f9312cde5209" title="the top-state.">QHsm::top()</a></li>
<li><a class="el" href="class_q_p_1_1_q_msm.html" title="QM State Machine implementation strategy.">QMsm</a> class</li>
<li><a class="el" href="class_q_p_1_1_q_hsm.html#a1a118e7d4b06531bb12af376149bdd93">QMsm::QMsm()</a></li>
<li><a class="el" href="class_q_p_1_1_q_msm.html#aecd7c807d27c7067a189f7bab4fd0a03" title="Tests if a given state is part of the active state configuration.">QMsm::isInState()</a></li>
<li><a class="el" href="class_q_p_1_1_q_msm.html#aa8eefebb5bbc57e0c8b53355f3ac9ae7" title="Return the current active state object (read only)">QMsm::stateObj()</a></li>
<li><a class="el" href="qep_8hpp.html#a6531b0ab582f41275f19d28ac91d9e4f" title="Macro to perform casting to QStateHandler.">Q_STATE_CAST()</a></li>
<li><a class="el" href="qep_8hpp.html#a9f117cb1bc50e9ef4dcc933533ccdd7f" title="Perform downcast of an event onto a subclass of QEvt class_.">Q_EVT_CAST()</a></li>
</ul>
<h1><a class="anchor" id="api_qf"></a>
QF (Active Object Framework)</h1>
<p><a class="el" href="class_q_p_1_1_q_f.html" title="QF services.">QF</a> is a portable, event-driven, real-time framework for execution of active objects (concurrent state machines) specifically designed for real-time embedded (RTE) systems.</p>
<h2><a class="anchor" id="api_qf_act"></a>
Active Objects</h2>
<ul>
<li><a class="el" href="class_q_p_1_1_q_active.html" title="QActive active object (based on QP::QHsm implementation)">QActive</a> class</li>
<li><a class="el" href="class_q_p_1_1_q_hsm.html#a1bd057458f70978840c6f18b891ea07f">QActive::QActive()</a></li>
<li><a class="el" href="class_q_p_1_1_q_active.html#ad30cc525bc2eb71b4821409bfddd45c3" title="Starts execution of an active object and registers the object with the framework.">QActive::start()</a></li>
<li>QActive:: <a class="el" href="qf_8hpp.html#a46e898fd379bdf4753e803b10d2c6f8f" title="Invoke the direct event posting facility QP::QActive::post_().">POST()</a></li>
<li>QActive:: <a class="el" href="qf_8hpp.html#ae774afb3828695a8e6c5797de441dd2e" title="Invoke the direct event posting facility QP::QActive::post_() without delivery guarantee.">POST_X()</a></li>
<li><a class="el" href="class_q_p_1_1_q_active.html#a2275d125f8bb6e87a60a2c13ee4be7a2" title="Posts an event directly to the event queue of the active object using the Last-In-First-Out (LIFO) po...">QActive::postLIFO()</a></li>
<li><a class="el" href="class_q_p_1_1_q_active.html#a29446ebb1a76be27c27f62bf89cc07e4" title="Defer an event to a given separate event queue.">QActive::defer()</a></li>
<li><a class="el" href="class_q_p_1_1_q_active.html#aa436248a33030f8d4cc68591a2bfae98" title="Recall a deferred event from a given event queue.">QActive::recall()</a></li>
<li><a class="el" href="class_q_p_1_1_q_active.html#ad4a2e6ce9a7570c608ec12ae47b34a63" title="Flush the specified deferred queue &#39;eq&#39;.">QActive::flushDeferred()</a></li>
<li><a class="el" href="class_q_p_1_1_q_active.html#aacf6bf8e121fea8b0a92d7197b73fe27" title="Stops execution of an active object and removes it from the framework&#39;s supervision.">QActive::stop()</a></li>
<li><a class="el" href="class_q_p_1_1_q_m_active.html" title="QMActive active object (based on QP::QMsm implementation)">QMActive</a> class</li>
<li><a class="el" href="class_q_p_1_1_q_hsm.html#aeaacb1c675b8deca87da1a3569110f64">QMActive::QMActive()</a></li>
</ul>
<h2><a class="anchor" id="api_qf_ps"></a>
Publish-Subscribe</h2>
<ul>
<li><a class="el" href="namespace_q_p.html#abf70f82ef06023008c568e80e1e85ad9" title="Subscriber List.">QSubscrList</a> (Subscriber List struct)</li>
<li><a class="el" href="class_q_p_1_1_q_f.html#a26009462ff1baafe3c177c8118f874d2" title="Publish-subscribe initialization.">QF::psInit()</a></li>
<li>QF:: <a class="el" href="qf_8hpp.html#ac809aab93c0c4cb303ecc39b8e3825e2" title="Invoke the event publishing facility QP::QF::publish_(). This macro.">PUBLISH()</a></li>
<li><a class="el" href="class_q_p_1_1_q_active.html#a4d6ba98d91cbeb20aba270abd1017674" title="Subscribes for delivery of signal sig to the active object.">QActive::subscribe()</a></li>
<li><a class="el" href="class_q_p_1_1_q_active.html#ad823695206df424327ddadd050cceca3" title="Un-subscribes from the delivery of signal sig to the active object.">QActive::unsubscribe()</a></li>
<li><a class="el" href="class_q_p_1_1_q_active.html#a448420136ea32898d0f5a0e05bc01b1e" title="Un-subscribes from the delivery of all signals to the active object.">QActive::unsubscribeAll()</a></li>
</ul>
<h2><a class="anchor" id="api_qf_evt"></a>
Dynamic Events</h2>
<ul>
<li><a class="el" href="struct_q_p_1_1_q_evt.html" title="QEvt base class.">QEvt</a> class</li>
<li><a class="el" href="qf_8hpp.html#abd823f3a9e8b3206a3460a108d5fa3e3" title="Allocate a dynamic event.">Q_NEW()</a></li>
<li><a class="el" href="qf_8hpp.html#aa52b4d3c43a262022392c6e11be06436" title="Allocate a dynamic event (non-asserting version).">Q_NEW_X()</a></li>
<li><a class="el" href="qf_8hpp.html#a10162978b156ab5d2fd2e3a7aa744ac0" title="Create a new reference of the current event e *‍/.">Q_NEW_REF()</a></li>
<li><a class="el" href="qf_8hpp.html#aaed009a86c52cf2b8d811389fabb5f23" title="Delete the event reference *‍/.">Q_DELETE_REF()</a></li>
<li><a class="el" href="class_q_p_1_1_q_f.html#a7d5f70fa40bdb5a9ed3524c5309be685" title="Recycle a dynamic event.">QF::gc()</a></li>
</ul>
<h2><a class="anchor" id="api_qf_time"></a>
Time Events</h2>
<ul>
<li><a class="el" href="class_q_p_1_1_q_time_evt.html" title="Time Event class.">QTimeEvt</a> class</li>
<li>QTimeEvt::QTimeEvt(QActive * const, enum_t const, uint_fast8_t const)</li>
<li><a class="el" href="class_q_p_1_1_q_time_evt.html#a8cb134ea948e3a716b64d2233f161bf9" title="Arm a time event (one shot or periodic) for event posting.">QTimeEvt::armX()</a></li>
<li><a class="el" href="class_q_p_1_1_q_time_evt.html#ab90f9368f80d3d78fc717bb1d66d5af4" title="Disarm a time event.">QTimeEvt::disarm()</a></li>
<li><a class="el" href="class_q_p_1_1_q_time_evt.html#ad00418ce8c9be452afcf943cfc8bed11" title="Rearm a time event.">QTimeEvt::rearm()</a></li>
<li>QTimeEvt::ctr()</li>
<li><a class="el" href="class_q_p_1_1_q_ticker.html" title="Ticker Active Object class.">QTicker</a> active object</li>
<li>QF:: <a class="el" href="qf_8hpp.html#acb95c078f4da69732d4bfee44e3c52e4" title="Invoke the system clock tick processing for rate 0.">TICK()</a></li>
<li>QF:: <a class="el" href="qf_8hpp.html#a9a12c5b2f250d8d874a2ec0ba72a0676" title="Invoke the system clock tick processing QP::QF::tickX_().">TICK_X()</a></li>
</ul>
<h2><a class="anchor" id="api_qf_queue"></a>
Event Queues (raw thread-safe)</h2>
<ul>
<li><a class="el" href="class_q_p_1_1_q_e_queue.html" title="Native QF Event Queue class.">QEQueue</a> class</li>
<li><a class="el" href="class_q_p_1_1_q_e_queue.html#a77ee07175cee4d2095a786efd382af21" title="Initializes the native QF event queue.">QEQueue::init()</a></li>
<li><a class="el" href="class_q_p_1_1_q_e_queue.html#ab7faed14a4cde24461001219cf38dca1" title="&quot;raw&quot; thread-safe QF event queue implementation for the event posting (FIFO). You can call this funct...">QEQueue::post()</a></li>
<li><a class="el" href="class_q_p_1_1_q_e_queue.html#a99fe8c234ef5275b0cd35b6c46a915f2" title="&quot;raw&quot; thread-safe QF event queue implementation for the First-In-First-Out (FIFO) event posting....">QEQueue::postLIFO()</a></li>
<li><a class="el" href="class_q_p_1_1_q_e_queue.html#a75617b7aeb5634cbb858c27c7c7a2281" title="&quot;raw&quot; thread-safe QF event queue implementation for the Last-In-First-Out (LIFO) event posting.">QEQueue::get()</a></li>
<li><a class="el" href="class_q_p_1_1_q_e_queue.html#a03ea7ec89c338e5b92d38496177396d7" title="&quot;raw&quot; thread-safe QF event queue operation for obtaining the number of free entries still available i...">QEQueue::getNFree()</a></li>
<li><a class="el" href="class_q_p_1_1_q_e_queue.html#a6c039e39d121eeab3d7f4ca6fe321859" title="&quot;raw&quot; thread-safe QF event queue operation for obtaining the minimum number of free entries ever in t...">QEQueue::getNMin()</a></li>
<li><a class="el" href="class_q_p_1_1_q_e_queue.html#a16ef7d9a7ee76f0c416c5170a0007cfe" title="&quot;raw&quot; thread-safe QF event queue operation to find out if the queue is empty">QEQueue::isEmpty()</a></li>
<li><a class="el" href="namespace_q_p.html#a0045d2024029c315adcc88a0acdb95f6" title="The data type to store the ring-buffer counters based on the macro QF_EQUEUE_CTR_SIZE.">QEQueueCtr()</a></li>
</ul>
<h2><a class="anchor" id="api_qf_mem"></a>
Memory Pools</h2>
<ul>
<li><a class="el" href="class_q_p_1_1_q_m_pool.html" title="Native QF memory pool class.">QMPool</a> class</li>
<li><a class="el" href="class_q_p_1_1_q_m_pool.html#a5c9795bf9d76d4a6c30c2e341c182dfa" title="Initializes the native QF event pool.">QMPool::init()</a></li>
<li><a class="el" href="class_q_p_1_1_q_m_pool.html#a84c87743569aa2a26a2b5d7fbbef9d42" title="Obtains a memory block from a memory pool.">QMPool::get()</a></li>
<li><a class="el" href="class_q_p_1_1_q_m_pool.html#a1eefaa351313ea39462395eb58a584eb" title="Returns a memory block back to a memory pool.">QMPool::put()</a></li>
</ul>
<h1><a class="anchor" id="api_qs"></a>
QS ("Quantum Spy" Software Tracing)</h1>
<p><a class="el" href="class_q_p_1_1_q_s.html" title="QS logging facilities.">QS</a> is a software tracing system that enables developers to monitor live event-driven <a class="el" href="namespace_q_p.html" title="namespace associated with the QP/C++ framework">QP</a> applications with minimal target system resources and without stopping or significantly slowing down the code. <a class="el" href="class_q_p_1_1_q_s.html" title="QS logging facilities.">QS</a> is an ideal tool for testing, troubleshooting, and optimizing <a class="el" href="namespace_q_p.html" title="namespace associated with the QP/C++ framework">QP</a> applications. <a class="el" href="class_q_p_1_1_q_s.html" title="QS logging facilities.">QS</a> can even be used to support acceptance testing in product manufacturing.</p>
<h2><a class="anchor" id="api_qs_ini"></a>
QS Initialization and Control</h2>
<ul>
<li><a class="el" href="qs_8hpp.html#af22371611fe57862a37eb785debb7921" title="Initialize the QS facility.">QS_INIT()</a></li>
<li><a class="el" href="class_q_p_1_1_q_s.html#ae1c016cb1d1695e891c08e7a5b79dbd7" title="Initialize the QS data buffer.">QS::initBuf()</a></li>
<li><a class="el" href="class_q_p_1_1_q_s.html#a21e8691dd17745c64376520f9b8b7e40" title="Byte-oriented interface to the QS data buffer.">QS::getByte()</a></li>
<li><a class="el" href="class_q_p_1_1_q_s.html#a53f614113cf6affb446c6b59e5cc0aa1" title="Block-oriented interface to the QS data buffer.">QS::getBlock()</a></li>
<li><a class="el" href="class_q_p_1_1_q_s.html#ac981334651d6ea5b4ff42af489b5ad6e" title="Callback to startup the QS facility.">QS::onStartup()</a></li>
<li><a class="el" href="class_q_p_1_1_q_s.html#a30d8a524f6a45b2cf7cc3d476c0a24a9" title="Callback to cleanup the QS facility.">QS::onCleanup()</a></li>
<li><a class="el" href="class_q_p_1_1_q_s.html#a590c14b05b834a6394d4b8651aa7440b" title="Callback to flush the QS trace data to the host.">QS::onFlush()</a></li>
<li><a class="el" href="class_q_p_1_1_q_s.html#a6214f9da271194f8fa3387ebe33b005e" title="Callback to obtain a timestamp for a QS record.">QS::onGetTime()</a></li>
</ul>
<h2><a class="anchor" id="api_qs_rx"></a>
QS Receive-Channel (QS-RX)</h2>
<ul>
<li><a class="el" href="class_q_p_1_1_q_s.html#ad860ac46b6e7129c852a3d698e897a92" title="Initialize the QS RX data buffer.">QS::rxInitBuf()</a></li>
<li><a class="el" href="class_q_p_1_1_q_s.html#a4f4b53d7de15843549f8a451b56ec7b1" title="Put one byte into the QS RX lock-free buffer.">QS::rxPut()</a></li>
<li><a class="el" href="class_q_p_1_1_q_s.html#af020d4ec84353830d38105323f821db5" title="Parse all bytes present in the QS RX data buffer.">QS::rxParse()</a></li>
<li><a class="el" href="class_q_p_1_1_q_s.html#ad4e3ed9f48e3852d66cec4072af6edb4" title="Callback function to execute user commands (to be implemented in BSP)">QS::onCommand()</a></li>
</ul>
<h2><a class="anchor" id="api_qs_filter"></a>
QS Filters</h2>
<ul>
<li><a class="el" href="qpcpp_8hpp.html#ab1daab0f67adda321cd13b42c6042023">QS_FILTER_ON()</a></li>
<li><a class="el" href="qpcpp_8hpp.html#ae3d7888f95ecf7b24005a618ebc0ef89">QS_FILTER_OFF()</a></li>
<li><a class="el" href="qpcpp_8hpp.html#a17b622a80eec603c8cd1d81f3b319a42">QS_FILTER_SM_OBJ()</a></li>
<li><a class="el" href="qpcpp_8hpp.html#a2b49bf6045b1294330455dd0b4fcab88">QS_FILTER_AO_OBJ()</a></li>
<li><a class="el" href="qpcpp_8hpp.html#a454d7a3704c3c4e88d0a75fc476b22f3">QS_FILTER_MP_OBJ()</a></li>
<li><a class="el" href="qpcpp_8hpp.html#a7f5219a0712d857d7f6f7fded97bdf00">QS_FILTER_EQ_OBJ()</a></li>
<li><a class="el" href="qpcpp_8hpp.html#acb795d05dcf49796febfcb6d30ab7969">QS_FILTER_TE_OBJ()</a></li>
<li><a class="el" href="qpcpp_8hpp.html#aa6a82e6fda0dd1bb27a1ea0ca485a8a1">QS_FILTER_AP_OBJ()</a></li>
</ul>
<h2><a class="anchor" id="api_qs_dict"></a>
QS Dictionaries</h2>
<ul>
<li><a class="el" href="qs_8hpp.html#a9a8e26a01678f160bf35fd0bda6bfe8b" title="Output signal dictionary record.">QS_SIG_DICTIONARY()</a></li>
<li><a class="el" href="qs_8hpp.html#a034206ff7f20a4e6426a5f554434643b" title="Output object dictionary record.">QS_OBJ_DICTIONARY()</a></li>
<li><a class="el" href="qs_8hpp.html#a3b1ab21c174f2bec448edec8865a8529" title="Output function dictionary record.">QS_FUN_DICTIONARY()</a></li>
<li><a class="el" href="qs_8hpp.html#ae75893daa66c6d0b5a6dfb8f3fca1196" title="Output user QS record dictionary record.">QS_USR_DICTIONARY()</a></li>
</ul>
<h2><a class="anchor" id="api_qs_user"></a>
QS Application-Specific Records</h2>
<ul>
<li><a class="el" href="namespace_q_p.html#a2ee815d414fbd802853c730489f13f45a48cec974671d01f280b2b1a33225d176" title="the first record available to QS users">QS_USER</a> enumeration</li>
<li><a class="el" href="qpcpp_8hpp.html#ad99a023424e53db53e3a0bd6befe3f8e">QS_BEGIN()</a></li>
<li><a class="el" href="qs_8hpp.html#a2ed1002d3dda6d95f9f64c59b8453c71" title="End a QS record with exiting critical section.">QS_END()</a></li>
<li><a class="el" href="qs_8hpp.html#a129128a3bb20d0b9286ff7c68f1401ab" title="Output formatted std::uint8_t to the QS record.">QS_U8()</a> / <a class="el" href="qs_8hpp.html#a0d9567f774207e262ceafde8e8069385" title="Output formatted std::int8_t to the QS record.">QS_I8()</a></li>
<li><a class="el" href="qs_8hpp.html#a3b053b820c90aac6aa7e10adb76a18a5" title="Output formatted std::uint16_t to the QS record.">QS_U16()</a> / <a class="el" href="qs_8hpp.html#aa56a51195cc2819fb2612e3c24723bae" title="Output formatted std::int16_t to the QS record.">QS_I16()</a></li>
<li><a class="el" href="qs_8hpp.html#a17e249417c7e49c8e2913b17696acbc0" title="Output formatted std::uint32_t to the QS record.">QS_U32()</a> / <a class="el" href="qs_8hpp.html#aa3e19e4d0d7a2075951ac5c3fe389936" title="Output formatted std::int32_t to the QS record.">QS_I32()</a></li>
<li><a class="el" href="qpcpp_8hpp.html#a583642dd30cadd5b785592f6352bdef2">QS_U32_HEX()</a></li>
<li><a class="el" href="qs_8hpp.html#a7ad67719163eea844e44bee7f0478c0a" title="Output formatted zero-terminated ASCII string to the QS record.">QS_STR()</a></li>
<li><a class="el" href="qs_8hpp.html#a68d599cd42fd0fec8cca70251361d8cc" title="Output formatted memory block of up to 255 bytes to the QS record.">QS_MEM()</a></li>
</ul>
<h1><a class="anchor" id="api_qv"></a>
QV (Cooperative Kernel)</h1>
<p><a class="el" href="class_q_p_1_1_q_v.html" title="QV services.">QV</a> is a simple <b>cooperative</b> kernel (previously called "Vanilla" kernel). This kernel executes active objects one at a time, with priority-based scheduling performed before processing of each event. Due to naturally short duration of event processing in state machines, the simple <a class="el" href="class_q_p_1_1_q_v.html" title="QV services.">QV</a> kernel is often adequate for many real-time systems.</p>
<p>The <a class="el" href="class_q_p_1_1_q_v.html" title="QV services.">QV</a> scheduler is engaged after every RTC step of any active object to choose the next active object to execute. The <a class="el" href="class_q_p_1_1_q_v.html" title="QV services.">QV</a> scheduler always chooses the highest-priority active object that has any events in its event queue. The <a class="el" href="class_q_p_1_1_q_v.html" title="QV services.">QV</a> scheduler then extracts the next event from this queue and dispatches it to the state machine associated with the active object. The state machine runs to completion, after which the <a class="el" href="class_q_p_1_1_q_v.html" title="QV services.">QV</a> scheduler runs and the cycle repeats.</p>
<p>Please note that because the state machines always return to the <a class="el" href="class_q_p_1_1_q_v.html" title="QV services.">QV</a> scheduler after each RTC step, a single stack can be used to process all state machines (memory-friendly architecture).</p>
<p>The <a class="el" href="class_q_p_1_1_q_v.html" title="QV services.">QV</a> scheduler can also very easily detect when all event queues are empty, at which point it can call the idle callback to let the application put the CPU and peripherals to a low-power sleep mode (power-friendly architecture).</p>
<p>Given the simplicity, portability, and low-resource consumption, the <a class="el" href="class_q_p_1_1_q_v.html" title="QV services.">QV</a> scheduler is very attractive. It allows you to partition the problem into active objects and execute these active objects orderly. The task-level response of this scheduler is the longest RTC step in the whole system, but because event-driven active objects don’t block, the RTC steps tend to be very short (typically just a few microseconds). Also, often you can break up longer RTC steps into shorter pieces, by posting an event to self and returning (“Reminder” state pattern). The self-posted event then triggers the continuation of longer processing.</p>
<h2><a class="anchor" id="api_qv_init"></a>
Kernel Initialization and Control</h2>
<ul>
<li>QV_INIT()</li>
<li><a href="qv_8c.html#a779a1bc9482e2d489dc87751cd100fdb"><b>QF_run()</b></a></li>
<li><a class="el" href="class_q_p_1_1_q_v.html#ac183489a298b22f2c25fb70491cadcce" title="QV idle callback (customized in BSPs for QK)">QV::onIdle()</a></li>
<li><a class="el" href="qv__port_8hpp.html#a63d09440889262e482687c417690fea4" title="Macro to put the CPU to sleep safely in the cooperative.">QV_CPU_SLEEP()</a></li>
<li>QV::getVersion()</li>
</ul>
<h1><a class="anchor" id="api_qk"></a>
QK (Preemptive Run-to-Completion Kernel)</h1>
<p><a class="el" href="class_q_p_1_1_q_k.html" title="QK services.">QK</a> is a tiny <b>preemptive</b>, priority-based, non-blocking kernel designed specifically for executing active objects. <a class="el" href="class_q_p_1_1_q_k.html" title="QK services.">QK</a> runs active objects in the same way as prioritized interrupt controller (such as NVIC in ARM Cortex-M) runs interrupts using the single stack. Active objects process their events in run-to-completion (RTC) fashion and remove themselves from the call stack, the same way as nested interrupts remove themselves from the stack upon completion. At the same time high-priority active objects can preempt lower-priority active objects, just like interrupts can preempt each other under a prioritized interrupt controller. <a class="el" href="class_q_p_1_1_q_k.html" title="QK services.">QK</a> meets all the requirement of the Rate Monotonic Scheduling (a.k.a. Rate Monotonic Analysis RMA) and can be used in hard real-time systems.</p>
<h2><a class="anchor" id="api_qk_ctrl"></a>
Kernel Initialization and Control</h2>
<ul>
<li>QK_INIT()</li>
<li><a href="qk_8c.html#a779a1bc9482e2d489dc87751cd100fdb"><b>QF_run()</b></a></li>
<li><a class="el" href="class_q_p_1_1_q_k.html#ac183489a298b22f2c25fb70491cadcce" title="QK idle callback (customized in BSPs for QK)">QK::onIdle()</a></li>
<li><a class="el" href="class_q_p_1_1_q_k.html#a5c49ed626f6699644beec500fe028bbd" title="QK selective scheduler lock.">QK::schedLock()</a></li>
<li><a class="el" href="class_q_p_1_1_q_k.html#a7e62ef374df0a3f426fd95f1e76396b9" title="QK selective scheduler unlock.">QK::schedUnlock()</a></li>
<li><a class="el" href="class_q_p_1_1_q_k.html#a7a98fb8c8780e79fdc88c3bc9c4accb2" title="get the current QK version number string of the form X.Y.Z">QK::getVersion()</a></li>
</ul>
<h2><a class="anchor" id="api_qk_isr"></a>
Interrupt Management</h2>
<ul>
<li><a class="el" href="qk__port_8hpp.html#ad3a6c9c79a8f39f1299196922e3eb6b5" title="Define the ISR entry sequence, if the compiler supports writing interrupts in C++.">QK_ISR_ENTRY()</a></li>
<li><a class="el" href="qk__port_8hpp.html#a18f2cc4dd2d00e3d5efb593d0754a95b" title="Define the ISR exit sequence, if the compiler supports writing interrupts in C++.">QK_ISR_EXIT()</a></li>
</ul>
<h1><a class="anchor" id="api_qxk"></a>
QXK (Preemptive Dual-Mode Run-to-Completion/Blocking RTOS Kernel)</h1>
<p><a class="el" href="class_q_p_1_1_q_x_k.html" title="QXK services.">QXK</a> is a small, preemptive, priority-based, dual-mode <b>blocking</b> kernel that executes active objects like the <a class="el" href="group__qk.html">QK kernel</a>, but can also execute traditional <b>blocking</b> threads (extended threads). In this respect, <a class="el" href="class_q_p_1_1_q_x_k.html" title="QXK services.">QXK</a> behaves exactly as a conventional <b>RTOS</b> (Real-Time Operating System). <a class="el" href="class_q_p_1_1_q_x_k.html" title="QXK services.">QXK</a> has been designed specifically for mixing event-driven active objects with traditional blocking code, such as commercial middleware (TCP/IP stacks, UDP stacks, embedded file systems, etc.) or legacy software.</p>
<h2><a class="anchor" id="api_qxk_ctrl"></a>
Kernel Initialization and Control</h2>
<ul>
<li>QXK_INIT()</li>
<li><a href="qxk_8c.html#a779a1bc9482e2d489dc87751cd100fdb"><b>QF_run()</b></a></li>
<li><a class="el" href="class_q_p_1_1_q_x_k.html#ac183489a298b22f2c25fb70491cadcce" title="QXK idle callback (customized in BSPs for QXK)">QXK::onIdle()</a></li>
<li><a class="el" href="class_q_p_1_1_q_x_k.html#a5c49ed626f6699644beec500fe028bbd" title="QXK selective scheduler lock.">QXK::schedLock()</a></li>
<li><a class="el" href="class_q_p_1_1_q_x_k.html#a7e62ef374df0a3f426fd95f1e76396b9" title="QXK selective scheduler unlock.">QXK::schedUnlock()</a></li>
<li>QXK::getVersion()</li>
</ul>
<h2><a class="anchor" id="api_qxk_isr"></a>
Interrupt Management</h2>
<ul>
<li><a class="el" href="qxk__port_8hpp.html#a9a4f06cd5bb50808046fe459a23aca9d" title="Define the ISR entry sequence, if the compiler supports writing interrupts in C++.">QXK_ISR_ENTRY()</a></li>
<li><a class="el" href="qxk__port_8hpp.html#a98abaa40c6aaacf63e565782ec4a2cfb" title="Define the ISR exit sequence, if the compiler supports writing interrupts in C++.">QXK_ISR_EXIT()</a></li>
</ul>
<h2><a class="anchor" id="api_qxk_xthr"></a>
Extended Thread Management</h2>
<ul>
<li><a class="el" href="class_q_p_1_1_q_x_thread.html" title="Extended (blocking) thread of the QXK preemptive kernel.">QXThread</a> class</li>
<li><a class="el" href="class_q_p_1_1_q_hsm.html#afd06ce08115faa318198ade6659b7aa0">QXThread::QXThread()</a></li>
<li><a class="el" href="class_q_p_1_1_q_x_thread.html#a1fea8d85fabfe07b934f8a7c396b365b" title="Starts execution of an extended thread and registers the thread with the framework.">QXThread::start()</a></li>
<li><a class="el" href="class_q_p_1_1_q_x_thread.html#a7f4cee6eaea7c867c7a9592232052050" title="delay (block) the current extended thread for a specified # ticks">QXThread::delay()</a></li>
<li><a class="el" href="class_q_p_1_1_q_x_thread.html#a9d2cd3e3c5dbc11cf4323649d7af3457" title="cancel the delay">QXThread::delayCancel()</a></li>
<li><a class="el" href="class_q_p_1_1_q_x_thread.html#ae4a644af2db1379f568c0c67ddc74b17" title="obtain a message from the private message queue (block if no messages)">QXThread::queueGet()</a></li>
<li>Q_XTHREAD_CAST()</li>
</ul>
<h2><a class="anchor" id="api_qxk_sema"></a>
Semaphores</h2>
<ul>
<li><a class="el" href="class_q_p_1_1_q_x_semaphore.html" title="Counting Semaphore of the QXK preemptive kernel.">QXSemaphore</a> class (Semaphore Control Block)</li>
<li><a class="el" href="class_q_p_1_1_q_x_semaphore.html#aee04c046bd6e10430c11c29530ad9236" title="initialize the counting semaphore">QXSemaphore::init()</a></li>
<li><a class="el" href="class_q_p_1_1_q_x_semaphore.html#a1076047c54b71d8135feb06eedfdb444" title="wait (block) on the semaphore">QXSemaphore::wait()</a></li>
<li><a class="el" href="class_q_p_1_1_q_x_semaphore.html#afdf929d9acbbc94b7262364ef570d631" title="try wait on the semaphore (non-blocking)">QXSemaphore::tryWait()</a></li>
<li><a class="el" href="class_q_p_1_1_q_x_semaphore.html#a48e4edb5679474f5855ae10f4a533394" title="signal (unblock) the semaphore">QXSemaphore::signal()</a></li>
</ul>
<h2><a class="anchor" id="api_qxk_mutex"></a>
Mutexes</h2>
<ul>
<li><a class="el" href="class_q_p_1_1_q_x_mutex.html" title="Priority Ceiling Mutex the QXK preemptive kernel.">QXMutex</a> class (Mutex Control Block)</li>
<li><a class="el" href="class_q_p_1_1_q_x_mutex.html#aa0d18323a440f7c8e472bfbb35bed699" title="initialize the QXK priority-ceiling mutex QP::QXMutex">QXMutex::init()</a></li>
<li><a class="el" href="class_q_p_1_1_q_x_mutex.html#ae81960cd55154c38cd4bae8c45d5d92e" title="lock the QXK priority-ceiling mutex QP::QXMutex">QXMutex::lock()</a></li>
<li><a class="el" href="class_q_p_1_1_q_x_mutex.html#a30320de572c7553068917c3be1de2c23" title="try to lock the QXK priority-ceiling mutex QP::QXMutex">QXMutex::tryLock()</a></li>
<li><a class="el" href="class_q_p_1_1_q_x_mutex.html#aa56e3d64a49a635d8be305e283a86c79" title="unlock the QXK priority-ceiling mutex QP::QXMutex">QXMutex::unlock()</a></li>
</ul>
<h2><a class="anchor" id="api_qxk_queue"></a>
Message Queues</h2>
<ul>
<li>QXThread:: <a class="el" href="qf_8hpp.html#a46e898fd379bdf4753e803b10d2c6f8f" title="Invoke the direct event posting facility QP::QActive::post_().">POST()</a></li>
<li>QXThread:: <a class="el" href="qf_8hpp.html#ae774afb3828695a8e6c5797de441dd2e" title="Invoke the direct event posting facility QP::QActive::post_() without delivery guarantee.">POST_X()</a></li>
<li><a class="el" href="class_q_p_1_1_q_x_thread.html#ae4a644af2db1379f568c0c67ddc74b17" title="obtain a message from the private message queue (block if no messages)">QXThread::queueGet()</a> - waiting (blocking) on message queue</li>
</ul>
<h2><a class="anchor" id="api_qxk_mem"></a>
Memory Pools</h2>
<ul>
<li><a class="el" href="class_q_p_1_1_q_m_pool.html" title="Native QF memory pool class.">QMPool</a> class</li>
<li><a class="el" href="class_q_p_1_1_q_m_pool.html#a5c9795bf9d76d4a6c30c2e341c182dfa" title="Initializes the native QF event pool.">QMPool::init()</a></li>
<li><a class="el" href="class_q_p_1_1_q_m_pool.html#a84c87743569aa2a26a2b5d7fbbef9d42" title="Obtains a memory block from a memory pool.">QMPool::get()</a></li>
<li><a class="el" href="class_q_p_1_1_q_m_pool.html#a1eefaa351313ea39462395eb58a584eb" title="Returns a memory block back to a memory pool.">QMPool::put()</a></li>
</ul>
<h2><a class="anchor" id="api_qxk_tls"></a>
Thread-Local Storage</h2>
<ul>
<li><a class="el" href="qxk_8hpp.html#a256950f60e40a9e8aa63e7fd77133ed4" title="return the currently executing active-object/thread">QXK_current()</a></li>
<li><a class="el" href="qxk_8hpp.html#a0c95c457d7b8d19f6588e1bb9f1af829" title="Access Thread-Local Storage (TLS) and cast it on the given type_.">QXK_TLS()</a></li>
</ul>
<hr  />
<p><b>Next:</b> <a class="el" href="exa.html">Examples</a></p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
    <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
      <ul>
        <li class="footer">
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; 2005-2021 Quantum Leaps</a> &nbsp;| &nbsp; <a title="help" href="help.html">Using Online Help</a>&nbsp;| &nbsp;<a title="Doxygen" href="http://www.doxygen.nl">Generated with Doxygen</a>&nbsp; | &nbsp;<b>QP/C++ 6.9.3</b>
<hr class="footer"/><address class="footer"><small>
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; Quantum Leaps 2020</a> &nbsp;| &nbsp; <a title="help" href="help.html">Using Online Help</a>&nbsp;| &nbsp;<a title="Doxygen" href="http://www.doxygen.nl">Generated with Doxygen</a>&nbsp; | &nbsp;<b>QP/C++ 6.9.3</b>
</small></address>
        </li>
      </ul>
    </div>
    <script src="custom.js"></script>
  </body>
</html>
