//.$file${.::blinky2.ino} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//
// Model: blinky2.qm
// File:  ${.::blinky2.ino}
//
// This code has been generated by QM 5.1.3 <www.state-machine.com/qm/>.
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// This program is open source software: you can redistribute it and/or
// modify it under the terms of the GNU General Public License as published
// by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
// or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
// for more details.
//
//.$endhead${.::blinky2.ino} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#include "qpcpp.hpp"  // QP-C++ framework

using namespace QP;

enum BlinkySignals {
    TIMEOUT_SIG = Q_USER_SIG,
    MAX_SIG
};

enum {
    TICKS_PER_SEC = 100, // number of system clock ticks per second
    LED2_PIN = 12,
};

//============================================================================
// genearate declarations of all opaque AO pointers
//.$declare${AOs::AO_Blinky} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
extern QP::QActive * const AO_Blinky;
//.$enddecl${AOs::AO_Blinky} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//.$declare${AOs::AO_Blinky2} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
extern QP::QActive * const AO_Blinky2;
//.$enddecl${AOs::AO_Blinky2} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//...

//............................................................................
void setup() {
    QF::init(); // initialize the framework

    // initialize the hardware used in this sketch...
    // NOTE: interrupts are configured and started later in QF::onStartup()
    pinMode(LED_BUILTIN, OUTPUT);
    pinMode(LED2_PIN, OUTPUT);

    // statically allocate event queue buffer for the Blinky AO
    static QEvt const *blinky_queueSto[10];
    AO_Blinky->start(1U, // priority
                     blinky_queueSto, Q_DIM(blinky_queueSto),
                     (void *)0, 0U); // no stack

    static QEvt const *blinky2_queueSto[10];
    AO_Blinky2->start(2U, // priority
                     blinky2_queueSto, Q_DIM(blinky2_queueSto),
                     (void *)0, 0U); // no stack
}

//............................................................................
void loop() {
    QF::run(); // run the QF/C++ framework
}

//============================================================================
// QF callbacks...

// ATSAM3X timer used for the system clock tick
// NOTE: re-define the macros to use a different timer/channel
#define TIMER           TC1
#define TIMER_CLCK_HZ   650000
#define TIMER_CHANNEL   0
#define TIMER_IRQn      TC3_IRQn
#define TIMER_HANDLER   TC3_Handler

// interrupts.................................................................
void TIMER_HANDLER(void) {
    TC_GetStatus(TIMER, TIMER_CHANNEL);  // clear the interrupt source
    QF::TICK_X(0, (void *)0); // process time events for tick rate 0
}
//............................................................................
void QF::onStartup(void) {
    // configure the timer-counter channel........
    pmc_set_writeprotect(false);   // disable write protection
    pmc_enable_periph_clk(TIMER_IRQn); // enable peripheral clock
    TC_Configure(TIMER, TIMER_CHANNEL,
                 TC_CMR_WAVE           // WAVE mode
                 | TC_CMR_WAVSEL_UP_RC // count-up with trigger on RC compare
                 | TC_CMR_TCCLKS_TIMER_CLOCK4);  // internal Clock4
    TC_SetRC(TIMER, TIMER_CHANNEL,
             TIMER_CLCK_HZ / TICKS_PER_SEC); // set the RC compare value
    TC_Start(TIMER, TIMER_CHANNEL);
    // enable interrrupt for RC compare
    TIMER->TC_CHANNEL[TIMER_CHANNEL].TC_IER = TC_IER_CPCS;
    TIMER->TC_CHANNEL[TIMER_CHANNEL].TC_IDR = ~TC_IER_CPCS;
    pmc_set_writeprotect(true); // enable write protection

    // explicitly set the NVIC priorities for all kernel AWARE interrupts
    NVIC_SetPriority(TIMER_IRQn,  QF_AWARE_ISR_CMSIS_PRI);
    // ...

    // enable the interrupt in the NVIC
    NVIC_EnableIRQ(TIMER_IRQn);
    // ...
}
//............................................................................
void QV::onIdle(void) { // called with interrupts DISABLED
#ifdef NDEBUG
    // Put the CPU and peripherals to the low-power mode. You might
    // need to customize the clock management for your application,
    // see the datasheet for your particular MCU.
    QV_CPU_SLEEP();  // atomically go to sleep and enable interrupts
#else
    QF_INT_ENABLE(); // simply re-enable interrupts
#endif
}
//............................................................................
extern "C"  Q_NORETURN Q_onAssert(char const * const module, int location) {
    //
    // NOTE: add here your application-specific error handling
    //
    (void)module;
    (void)location;

    QF_INT_DISABLE(); // disable all interrupts
    digitalWrite(LED_BUILTIN, HIGH); // turn the LED on
    for (;;) { // sit in an endless loop for now
    }
}

//============================================================================
// generate declarations and definitions of all AO classes (state machines)...
//.$declare${AOs::Blinky} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//.${AOs::Blinky} ............................................................
class Blinky : public QP::QActive {
private:
    QP::QTimeEvt m_timeEvt;

public:
    static Blinky instance;

public:
    Blinky();

protected:
    Q_STATE_DECL(initial);
    Q_STATE_DECL(off);
    Q_STATE_DECL(on);
};
//.$enddecl${AOs::Blinky} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//.$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//. Check for the minimum required QP version
#if (QP_VERSION < 690U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpcpp version 6.9.0 or higher required
#endif
//.$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//.$define${AOs::Blinky} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//.${AOs::Blinky} ............................................................
Blinky Blinky::instance;
//.${AOs::Blinky::Blinky} ....................................................
Blinky::Blinky()
: QActive(Q_STATE_CAST(&Blinky::initial)),
    m_timeEvt(this, TIMEOUT_SIG, 0U)
{}

//.${AOs::Blinky::SM} ........................................................
Q_STATE_DEF(Blinky, initial) {
    //.${AOs::Blinky::SM::initial}
    m_timeEvt.armX(TICKS_PER_SEC/2, TICKS_PER_SEC/2);
    (void)e; // unused parameter
    return tran(&off);
}
//.${AOs::Blinky::SM::off} ...................................................
Q_STATE_DEF(Blinky, off) {
    QP::QState status_;
    switch (e->sig) {
        //.${AOs::Blinky::SM::off}
        case Q_ENTRY_SIG: {
            digitalWrite(LED_BUILTIN, LOW); // turn the LED off
            status_ = Q_RET_HANDLED;
            break;
        }
        //.${AOs::Blinky::SM::off::TIMEOUT}
        case TIMEOUT_SIG: {
            status_ = tran(&on);
            break;
        }
        default: {
            status_ = super(&top);
            break;
        }
    }
    return status_;
}
//.${AOs::Blinky::SM::on} ....................................................
Q_STATE_DEF(Blinky, on) {
    QP::QState status_;
    switch (e->sig) {
        //.${AOs::Blinky::SM::on}
        case Q_ENTRY_SIG: {
            digitalWrite(LED_BUILTIN, HIGH); // turn the LED on
            status_ = Q_RET_HANDLED;
            break;
        }
        //.${AOs::Blinky::SM::on::TIMEOUT}
        case TIMEOUT_SIG: {
            status_ = tran(&off);
            break;
        }
        default: {
            status_ = super(&top);
            break;
        }
    }
    return status_;
}
//.$enddef${AOs::Blinky} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//...

//============================================================================
// generate definitions of all AO opaque pointers...
//.$define${AOs::AO_Blinky} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//.${AOs::AO_Blinky} .........................................................
QP::QActive * const AO_Blinky = &Blinky::instance;
//.$enddef${AOs::AO_Blinky} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//...

//============================================================================
// generate declarations and definitions of all AO classes (state machines)...
//.$declare${AOs::Blinky2} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//.${AOs::Blinky2} ...........................................................
class Blinky2 : public QP::QActive {
private:
    QP::QTimeEvt m_timeEvt;

public:
    static Blinky2 instance;

public:
    Blinky2();

protected:
    Q_STATE_DECL(initial);
    Q_STATE_DECL(off);
    Q_STATE_DECL(on);
};
//.$enddecl${AOs::Blinky2} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//.$define${AOs::Blinky2} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//.${AOs::Blinky2} ...........................................................
Blinky2 Blinky2::instance;
//.${AOs::Blinky2::Blinky2} ..................................................
Blinky2::Blinky2()
: QActive(Q_STATE_CAST(&Blinky2::initial)),
    m_timeEvt(this, TIMEOUT_SIG, 0U)
{}

//.${AOs::Blinky2::SM} .......................................................
Q_STATE_DEF(Blinky2, initial) {
    //.${AOs::Blinky2::SM::initial}
    m_timeEvt.armX(TICKS_PER_SEC/3, TICKS_PER_SEC/3);
    (void)e; // unused parameter
    return tran(&off);
}
//.${AOs::Blinky2::SM::off} ..................................................
Q_STATE_DEF(Blinky2, off) {
    QP::QState status_;
    switch (e->sig) {
        //.${AOs::Blinky2::SM::off}
        case Q_ENTRY_SIG: {
            digitalWrite(LED2_PIN, LOW); // turn the LED off
            status_ = Q_RET_HANDLED;
            break;
        }
        //.${AOs::Blinky2::SM::off::TIMEOUT}
        case TIMEOUT_SIG: {
            status_ = tran(&on);
            break;
        }
        default: {
            status_ = super(&top);
            break;
        }
    }
    return status_;
}
//.${AOs::Blinky2::SM::on} ...................................................
Q_STATE_DEF(Blinky2, on) {
    QP::QState status_;
    switch (e->sig) {
        //.${AOs::Blinky2::SM::on}
        case Q_ENTRY_SIG: {
            digitalWrite(LED2_PIN, HIGH); // turn the LED on
            status_ = Q_RET_HANDLED;
            break;
        }
        //.${AOs::Blinky2::SM::on::TIMEOUT}
        case TIMEOUT_SIG: {
            status_ = tran(&off);
            break;
        }
        default: {
            status_ = super(&top);
            break;
        }
    }
    return status_;
}
//.$enddef${AOs::Blinky2} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//...

//============================================================================
// generate definitions of all AO opaque pointers...
//.$define${AOs::AO_Blinky2} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//.${AOs::AO_Blinky2} ........................................................
QP::QActive * const AO_Blinky2 = &Blinky2::instance;
//.$enddef${AOs::AO_Blinky2} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//...
