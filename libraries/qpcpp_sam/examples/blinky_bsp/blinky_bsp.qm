<?xml version="1.0" encoding="UTF-8"?>
<model version="5.1.3" links="0">
 <documentation>This is a little more advanced Blinky example for the Arduino DUE board. The example demonstrates:

1. One active object class &quot;Blinky&quot; (inside the package &quot;AOs&quot;)
2. A simple state machine
3. The Board Support Package (BSP), see below.

----
# Board configuration:

The external LED needs to be connected between the pins GND and 13, with the short LEG leg at the GND pin.

----
# More info

This example demonstrates the concept of the Board Support Package (BSP), which separates the &quot;What&quot; needs to be done from &quot;How&quot; this is done. The BSP consists of two files &quot;bsp.h&quot; and &quot;bsp.cpp&quot;. The application (active objects) need to include only the &quot;bsp.h&quot; header file and the state machines call only the BSP functions, but don't interact with the hardware directly.

This structure of the code is recommended for applications with only one active object. (See also the dpp_bsp example).</documentation>
 <framework name="qpcpp"/>
 <package name="AOs" stereotype="0x02">
  <class name="Blinky" superclass="qpcpp::QActive">
   <attribute name="m_timeEvt" type="QP::QTimeEvt" visibility="0x02" properties="0x00"/>
   <attribute name="instance" type="Blinky" visibility="0x00" properties="0x01">
    <documentation>static class instance (Singleton)</documentation>
   </attribute>
   <operation name="Blinky" type="" visibility="0x00" properties="0x00">
    <code>: QActive(Q_STATE_CAST(&amp;Blinky::initial)),
    m_timeEvt(this, TIMEOUT_SIG, 0U)</code>
   </operation>
   <statechart properties="0x00">
    <initial target="../1">
     <action>m_timeEvt.armX(BSP::TICKS_PER_SEC/2, BSP::TICKS_PER_SEC/2);
(void)e; // unused parameter</action>
     <initial_glyph conn="2,2,5,1,20,8,-4">
      <action box="0,-2,32,6"/>
     </initial_glyph>
    </initial>
    <state name="off">
     <entry>BSP::ledOff();</entry>
     <tran trig="TIMEOUT" target="../../2">
      <tran_glyph conn="2,16,3,1,18,8,-2">
       <action box="0,-2,8,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="2,8,16,10">
      <entry box="1,2,12,4"/>
     </state_glyph>
    </state>
    <state name="on">
     <entry>BSP::ledOn();</entry>
     <tran trig="TIMEOUT" target="../../1">
      <tran_glyph conn="2,30,3,1,20,-17,-4">
       <action box="0,-2,8,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="2,22,16,10">
      <entry box="1,2,12,4"/>
     </state_glyph>
    </state>
    <state_diagram size="34,34"/>
   </statechart>
  </class>
  <attribute name="AO_Blinky" type="QP::QActive * const" visibility="0x00" properties="0x00">
   <documentation>the opaque pointer to the Blinky AO</documentation>
   <code>= &amp;Blinky::instance;</code>
  </attribute>
 </package>
 <directory name=".">
  <file name="bsp.hpp">
   <text>#ifndef BSP_HPP
#define BSP_HPP

class BSP {
public:
    enum { TICKS_PER_SEC = 100} ;
    static void init(void);
    static void ledOff(void);
    static void ledOn(void);
};

#endif // BSP_HPP
</text>
  </file>
  <file name="bsp.cpp">
   <text>#include &quot;qpcpp.hpp&quot;   // QP-C++ framework
#include &quot;blinky.hpp&quot;  // Blinky application interface
#include &quot;bsp.hpp&quot;     // Board Support Package (BSP)

using namespace QP;

//----------------------------------------------------------------------------
// BSP functions

//............................................................................
void BSP::init(void) {
    // initialize the hardware used in this sketch...
    // NOTE: interrupts are configured and started later in QF::onStartup()
    pinMode(LED_BUILTIN, OUTPUT);
}
//............................................................................
void BSP::ledOff(void) {
    digitalWrite(LED_BUILTIN, LOW);
}
//............................................................................
void BSP::ledOn(void) {
    digitalWrite(LED_BUILTIN, HIGH);
}

//----------------------------------------------------------------------------
// QF callbacks...

// ATSAM3X timer used for the system clock tick
//
// NOTE: The usual source of system clock tick in ARM Cortex-M (SysTick timer)
// is aready used by the Arduino library. Therefore, this code uses a different
// hardware timer of the ATSAM MCU for providing the system clock tick.
//
// NOTE: You can re-define the macros to use a different ATSAM timer/channel.
//
#define TIMER           TC1
#define TIMER_CLCK_HZ   650000
#define TIMER_CHANNEL   0
#define TIMER_IRQn      TC3_IRQn
#define TIMER_HANDLER   TC3_Handler

// interrupts.................................................................
void TIMER_HANDLER(void) {
    TC_GetStatus(TIMER, TIMER_CHANNEL);  // clear the interrupt source
    QF::TICK_X(0, (void *)0); // process time events for tick rate 0
}
//............................................................................
void QF::onStartup(void) {
    // configure the timer-counter channel........
    pmc_set_writeprotect(false);   // disable write protection
    pmc_enable_periph_clk(TIMER_IRQn); // enable peripheral clock
    TC_Configure(TIMER, TIMER_CHANNEL,
                 TC_CMR_WAVE           // WAVE mode
                 | TC_CMR_WAVSEL_UP_RC // count-up with trigger on RC compare
                 | TC_CMR_TCCLKS_TIMER_CLOCK4);  // internal Clock4
    TC_SetRC(TIMER, TIMER_CHANNEL,
             TIMER_CLCK_HZ / BSP::TICKS_PER_SEC); // set the RC compare value
    TC_Start(TIMER, TIMER_CHANNEL);
    // enable interrrupt for RC compare
    TIMER-&gt;TC_CHANNEL[TIMER_CHANNEL].TC_IER = TC_IER_CPCS;
    TIMER-&gt;TC_CHANNEL[TIMER_CHANNEL].TC_IDR = ~TC_IER_CPCS;
    pmc_set_writeprotect(true); // enable write protection

    // explicitly set the NVIC priorities for all &quot;kernel AWARE&quot; interrupts
    // NOTE: This is important!
    NVIC_SetPriority(TIMER_IRQn,  QF_AWARE_ISR_CMSIS_PRI);
    // ...

    // enable the interrupts in the NVIC
    NVIC_EnableIRQ(TIMER_IRQn);
    // ...
}
//............................................................................
void QV::onIdle(void) { // called with interrupts DISABLED
#ifdef NDEBUG
    // Put the CPU and peripherals to the low-power mode. You might
    // need to customize the clock management for your application,
    // see the datasheet for your particular MCU.
    QV_CPU_SLEEP();  // atomically go to sleep and enable interrupts
#else
    QF_INT_ENABLE(); // simply re-enable interrupts
#endif
}
//............................................................................
extern &quot;C&quot; Q_NORETURN Q_onAssert(char const * const module, int location) {
    //
    // NOTE: add here your application-specific error handling
    //
    (void)module;
    (void)location;

    QF_INT_DISABLE(); // disable all interrupts
    BSP::ledOn();  // trun the LED on
    for (;;) { // sit in an endless loop for now
    }
}

</text>
  </file>
  <file name="blinky.hpp">
   <text>#ifndef BLINKY_HPP
#define BLINKY_HPP

enum BlinkySignals {
    TIMEOUT_SIG = QP::Q_USER_SIG,
    MAX_SIG
};

// genearate declarations of all opaque AO pointers
$declare${AOs::AO_Blinky}
//...

#endif // BLINKY_HPP
</text>
  </file>
  <file name="blinky_bsp.ino">
   <text>#include &quot;qpcpp.hpp&quot;   // QP-C++ framework
#include &quot;blinky.hpp&quot;  // Blinky application interface
#include &quot;bsp.hpp&quot;     // Board Support Package (BSP)

using namespace QP;

//............................................................................
void setup() {
    QF::init(); // initialize the framework
    BSP::init(); // initialize the BSP

    // statically allocate event queues for the AOs and start them...
    static QEvt const *blinky_queueSto[10];
    AO_Blinky-&gt;start(1U, // priority
                     blinky_queueSto, Q_DIM(blinky_queueSto),
                     (void *)0, 0U); // no stack
    //...
}

//............................................................................
void loop() {
    QF::run(); // run the QF/C++ framework
}

//============================================================================
// generate declarations and definitions of all AO classes (state machines)...
$declare${AOs::Blinky}
$define${AOs::Blinky}
//...

//============================================================================
// generate definitions of all AO opaque pointers...
$define${AOs::AO_Blinky}
//...
</text>
  </file>
 </directory>
</model>
