<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QP/C++: Cooperative QV Kernel</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
  <a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">
    <img id="logo" src="img/logo_ql.png" alt="Quantum Leaps">
  </a>
  <span id="projectname">QP/C++</span>
  <span id="projectnumber">6.9.3</span>
           <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)"
               onblur="searchBox.OnSearchFieldFocus(false)"
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;"
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('arm-cm_qv.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0"
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Cooperative QV Kernel </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#arm-cm_qv-synopsis">Synopsis of the QV Port on ARM Cortex-M</a></li>
<li class="level1"><a href="#arm-cm_qv-qep_port">The qep_port.h Header File</a></li>
<li class="level1"><a href="#arm-cm_qv-qf_port">The qf_port.h Header File</a></li>
<li class="level1"><a href="#arm-cm_qv_port_h">The qv_port.h Header File</a></li>
<li class="level1"><a href="#arm-cm_qv_port_c">The qv_port.c Implementation File</a></li>
<li class="level1"><a href="#arm-cm_qv-isr">Writing ISRs for QV</a></li>
<li class="level1"><a href="#arm-cm_qv-fpu">Using the FPU in the QV Port (Cortex-M4F/M7)</a><ul><li class="level2"><a href="#arm-cm_qv-fpu_noisr">FPU NOT used in the ISRs</a></li>
<li class="level2"><a href="#arm-cm_qv-fpu_isr">FPU used in the ISRs</a></li>
</ul>
</li>
<li class="level1"><a href="#arm-cm_qv-idle">QV Idle Processing Customization in QV_onIdle()</a></li>
</ul>
</div>
<div class="textblock"><p>The non-preemptive, cooperative QV kernel executes active objects one at a time, with priority-based scheduling performed after run-to-completion (RTC) processing of each event. Due to naturally short duration of event processing in state machines, the simple QV kernel is often adequate for many real-time systems. (NOTE: Long RTC steps can be often broken into shorter pieces by means of the "Reminder" state pattern [<a class="el" href="arm-cm.html#Reminder">Reminder</a>]) </p>
<dl class="section remark"><dt>Remarks</dt><dd>In the QV port, the only components requiring platform-specific porting are QF and QV itself. The other two components: QEP and QS require merely recompilation and will not be discussed here. With the QV port you're not using the QK or QXK kernels. The QV port to ARM Cortex-M is located in the folder <span class="img folder">/ports/arm-cm/qv/</span>.</dd></dl>
<h1><a class="anchor" id="arm-cm_qv-synopsis"></a>
Synopsis of the QV Port on ARM Cortex-M</h1>
<p>The cooperative QV kernel works essentially as the traditional foreground-background system (a.k.a. "superloop") in that all active objects are executed in the main loop and interrupts always return back to the point of preemption. To avoid race conditions between the main loop and the interrupts, QV briefly disables interrupts.</p>
<ol type="1">
<li>The ARM Cortex-M processor executes application code (the main loop) in the Privileged Thread mode, which is exactly the mode entered out of reset.</li>
<li>The exceptions (including all interrupts) are always processed in the Privileged Handler mode.</li>
<li>QV uses only the Main Stack Pointer. The Process Stack Pointer is not used and is not initialized.</li>
<li>ARM Cortex-M enters interrupt context without disabling interrupts (without setting the PRIMASK bit or the BASEPRI register). Generally, you should not disable interrupts inside your ISRs. In particular, the <a class="el" href="namespace_q_p.html" title="namespace associated with the QP/C++ framework">QP</a> services QF_PUBLISH(), QF_TICK_X(), and QACTIVE_POST() should be called with <b>interrupts enabled</b>, to avoid nesting of critical sections.</li>
</ol>
<blockquote class="doxtable">
<p><b>NOTE:</b> If you don't wish an interrupt to be preempted by another interrupt, you can always prioritize that interrupt in the NVIC to a higher level (use a lower numerical value of priority). </p>
</blockquote>
<ol type="1">
<li>The <code>QF_init()</code> function calls the function <code>QV_init()</code> to set the interrupt priority of all IRQs available in the MCU to the safe value of <a class="el" href="arm-cm_qv.html#QF_BASEPRI">QF_BASEPRI</a> (for ARM-v7 architecture).</li>
</ol>
<h1><a class="anchor" id="arm-cm_qv-qep_port"></a>
The qep_port.h Header File</h1>
<p>The QEP header file for the ARM Cortex-M port is located in <span class="img file_h"><code>/ports/arm-cm/qv/gnu/qep_port.h</code></span>. The following shows the <code>qep_port.h</code> header file for ARM Cortex-M/GNU. The GNU-ARM compiler is a standard C99 compiler, so it simply includes the <code>&lt;stdint.h&gt;</code> header file that defines the platform-specific exact-with integer types.</p>
<p><a class="anchor" id="arm-cm_qv_qep_port-code"></a><b>Listing: The qep_port.h header file for ARM Cortex-M</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdint.h&gt;</span>  <span class="comment">/* Exact-width types. WG14/N843 C99 Standard */</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdbool.h&gt;</span> <span class="comment">/* Boolean type.      WG14/N843 C99 Standard */</span></div>
<div class="line"><span class="preprocessor">#include &quot;qep.h&quot;</span>     <span class="comment">/* QEP platform-independent public interface */</span></div>
</div><!-- fragment --><dl class="section remark"><dt>Remarks</dt><dd>If you use a pre-C99 compiler (e.g., a C89 compiler), you can provide the <code>stdint.h</code> and <code>stdbool.h</code> header files yourself, or you can define the standard integer types and Boolean types directly in the <code>qep_port.h</code> header file.</dd></dl>
<h1><a class="anchor" id="arm-cm_qv-qf_port"></a>
The qf_port.h Header File</h1>
<p>The QF header file for the ARM Cortex-M port is located in <span class="img file_h"><code>/ports/arm-cm/qv/gnu/qf_port.h</code></span>. This file specifies the interrupt disabling policy (QF critical section) as well as the configuration constants for QF (see Chapter 8 in [PSiCC2]).</p>
<dl class="section note"><dt>Note</dt><dd>The ARM Cortex-M allows you to use the simplest "unconditional interrupt disabling"ù policy (see Section 7.3.2 in [PSiCC2]), because ARM Cortex-M is equipped with the standard nested vectored interrupt controller (NVIC) and generally runs ISRs with interrupts enabled (so the body of an ISR is not a critical section).</dd></dl>
<p>The following listing shows the <code>qf_port.h</code> header file for ARM Cortex-M with the GNU-ARM toolchain. Other toolchains use slightly different conditional compilation macros to select the Cortex-M variants, but implement the same policies.</p>
<p><a class="anchor" id="arm-cm_qf_port_h-code"></a><b>Listing: The qf_port.h header file for ARM Cortex-M</b> </p><div class="fragment"><div class="line">     <span class="comment">/* The maximum number of active objects in the application, see NOTE1 */</span></div>
<div class="line"> [1] #define <a class="code" href="qxk_2qf__port_8hpp.html#a776d2a032974db4bf9bcfde01ace1389">QF_MAX_ACTIVE</a>           32</div>
<div class="line"> </div>
<div class="line">     <span class="comment">/* The maximum number of system clock tick rates */</span></div>
<div class="line"> [2] #define QF_MAX_TICK_RATE        2</div>
<div class="line"> </div>
<div class="line">     <span class="comment">/* QF interrupt disable/enable and log2()... */</span></div>
<div class="line"> [3] #<span class="keywordflow">if</span> (__ARM_ARCH == 6) <span class="comment">/* Cortex-M0/M0+/M1(v6-M, v6S-M)? */</span></div>
<div class="line"> </div>
<div class="line">         <span class="comment">/* Cortex-M0/M0+/M1(v6-M, v6S-M) interrupt disabling policy, see NOTE2 */</span></div>
<div class="line"> [4]     #define <a class="code" href="qk_2qf__port_8hpp.html#a88df5203e3a9716327b58923f5aaac80">QF_INT_DISABLE</a>()    __asm volatile (&quot;cpsid i&quot;)</div>
<div class="line"> [5]     <span class="preprocessor">#define QF_INT_ENABLE()     __asm volatile (&quot;cpsie i&quot;</span>)</div>
<div class="line"> </div>
<div class="line">         <span class="comment">/* QF critical section entry/exit (unconditional interrupt disabling) */</span></div>
<div class="line"> [6]     <span class="comment">/*#define QF_CRIT_STAT_TYPE not defined */</span></div>
<div class="line"> [7]     #define <a class="code" href="qk_2qf__port_8hpp.html#a55ad39820bd5eb29621a4bb4e03be884">QF_CRIT_ENTRY</a>(dummy) <a class="code" href="qk_2qf__port_8hpp.html#a88df5203e3a9716327b58923f5aaac80">QF_INT_DISABLE</a>()</div>
<div class="line"> [8]     #define <a class="code" href="qk_2qf__port_8hpp.html#ac26964ee79ab7d340d046cc7dbf5251e">QF_CRIT_EXIT</a>(dummy)  <a class="code" href="qk_2qf__port_8hpp.html#ad2d11956704ad838c9c954368d3d37d5">QF_INT_ENABLE</a>()</div>
<div class="line"> </div>
<div class="line">         <span class="comment">/* CMSIS threshold for &quot;QF-aware&quot; interrupts, see NOTE2 and NOTE5 */</span></div>
<div class="line"> [9]     #define QF_AWARE_ISR_CMSIS_PRI 0</div>
<div class="line"> </div>
<div class="line">         <span class="comment">/* hand-optimized LOG2 in assembly for Cortex-M0/M0+/M1(v6-M, v6S-M) */</span></div>
<div class="line">[10]     #define <a class="code" href="qf__act_8cpp.html#a2ace22134b54e4fd206cf1846af96b4f">QF_LOG2</a>(n_) QF_qlog2((n_))</div>
<div class="line"> </div>
<div class="line">[11] #<span class="keywordflow">else</span> <span class="comment">/* Cortex-M3/M4/M7 */</span></div>
<div class="line"> </div>
<div class="line">         <span class="comment">/* Cortex-M3/M4/M7 alternative interrupt disabling with PRIMASK */</span></div>
<div class="line">[12]     #define QF_PRIMASK_DISABLE() __asm volatile (&quot;cpsid i&quot;)</div>
<div class="line">[13]     <span class="preprocessor">#define QF_PRIMASK_ENABLE()  __asm volatile (&quot;cpsie i&quot;</span>)</div>
<div class="line"> </div>
<div class="line">         <span class="comment">/* Cortex-M3/M4/M7 interrupt disabling policy, see NOTE3 and NOTE4 */</span></div>
<div class="line">[14]     #define <a class="code" href="qk_2qf__port_8hpp.html#a88df5203e3a9716327b58923f5aaac80">QF_INT_DISABLE</a>() __asm volatile (\</div>
<div class="line">             &quot;cpsid i\n&quot; &quot;msr BASEPRI,%0\n&quot; &quot;cpsie i&quot; :: &quot;r&quot; (QF_BASEPRI) : )</div>
<div class="line">[15]     <span class="preprocessor">#define QF_INT_ENABLE()  __asm volatile (\</span></div>
<div class="line"><span class="preprocessor">             &quot;msr BASEPRI,%0&quot;</span> :: &quot;r&quot; (0) : )</div>
<div class="line"> </div>
<div class="line">         <span class="comment">/* QF critical section entry/exit (unconditional interrupt disabling) */</span></div>
<div class="line">[16]     <span class="comment">/*#define QF_CRIT_STAT_TYPE not defined */</span></div>
<div class="line">[17]     #define <a class="code" href="qk_2qf__port_8hpp.html#a55ad39820bd5eb29621a4bb4e03be884">QF_CRIT_ENTRY</a>(dummy) <a class="code" href="qk_2qf__port_8hpp.html#a88df5203e3a9716327b58923f5aaac80">QF_INT_DISABLE</a>()</div>
<div class="line">[18]     #define <a class="code" href="qk_2qf__port_8hpp.html#ac26964ee79ab7d340d046cc7dbf5251e">QF_CRIT_EXIT</a>(dummy)  <a class="code" href="qk_2qf__port_8hpp.html#ad2d11956704ad838c9c954368d3d37d5">QF_INT_ENABLE</a>()</div>
<div class="line"> </div>
<div class="line">         <span class="comment">/* BASEPRI threshold for &quot;QF-aware&quot; interrupts, see NOTE3 */</span></div>
<div class="line">[19]     #define QF_BASEPRI           0x3F</div>
<div class="line"> </div>
<div class="line">         <span class="comment">/* CMSIS threshold for &quot;QF-aware&quot; interrupts, see NOTE5 */</span></div>
<div class="line">[20]     #define QF_AWARE_ISR_CMSIS_PRI (QF_BASEPRI &gt;&gt; (8 - __NVIC_PRIO_BITS))</div>
<div class="line"> </div>
<div class="line">         <span class="comment">/* Cortex-M3/M4/M7 provide the CLZ instruction for fast LOG2 */</span></div>
<div class="line">[21]     #define <a class="code" href="qf__act_8cpp.html#a2ace22134b54e4fd206cf1846af96b4f">QF_LOG2</a>(n_) ((<a class="code" href="16bit_2stdint_8h.html#ad0906fbe05a45fbdb000c58fe8929e70">uint_fast8_t</a>)(32U - __builtin_clz(n_)))</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">     #endif</span></div>
<div class="line"> </div>
<div class="line">[22] #define <a class="code" href="qf_8hpp.html#adc8820f52d450bcfb7d1f830e6c8a8c2">QF_CRIT_EXIT_NOP</a>()      __asm volatile (&quot;isb&quot;)</div>
<div class="line"> </div>
<div class="line">     <span class="preprocessor">#include &quot;qep_port.h&quot;</span> <span class="comment">/* QEP port */</span><span class="preprocessor"></span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">     #if (__ARM_ARCH == 6) </span><span class="comment">/* Cortex-M0/M0+/M1(v6-M, v6S-M)? */</span><span class="preprocessor"></span></div>
<div class="line">         <span class="comment">/* hand-optimized quick LOG2 in assembly */</span></div>
<div class="line">[23]     <a class="code" href="16bit_2stdint_8h.html#ad0906fbe05a45fbdb000c58fe8929e70">uint_fast8_t</a> QF_qlog2(<a class="code" href="16bit_2stdint_8h.html#a33594304e786b158f3fb30289278f5af">uint32_t</a> x);</div>
<div class="line"><span class="preprocessor">     #endif </span><span class="comment">/* Cortex-M0/M0+/M1(v6-M, v6S-M) */</span><span class="preprocessor"></span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">     #include &quot;qv_port.h&quot;</span>  <span class="comment">/* QV port cooperative kernel port */</span></div>
<div class="line"><span class="preprocessor">     #include &quot;qf.h&quot;</span>       <span class="comment">/* QF platform-independent public interface */</span></div>
<div class="ttc" id="a16bit_2stdint_8h_html_a33594304e786b158f3fb30289278f5af"><div class="ttname"><a href="16bit_2stdint_8h.html#a33594304e786b158f3fb30289278f5af">uint32_t</a></div><div class="ttdeci">unsigned long int uint32_t</div><div class="ttdoc">exact-width 32-bit unsigned int</div><div class="ttdef"><b>Definition:</b> <a href="16bit_2stdint_8h_source.html#l00031">16bit/stdint.h:31</a></div></div>
<div class="ttc" id="a16bit_2stdint_8h_html_ad0906fbe05a45fbdb000c58fe8929e70"><div class="ttname"><a href="16bit_2stdint_8h.html#ad0906fbe05a45fbdb000c58fe8929e70">uint_fast8_t</a></div><div class="ttdeci">unsigned int uint_fast8_t</div><div class="ttdoc">fast at-least 8-bit unsigned int</div><div class="ttdef"><b>Definition:</b> <a href="16bit_2stdint_8h_source.html#l00036">16bit/stdint.h:36</a></div></div>
<div class="ttc" id="aqf_8hpp_html_adc8820f52d450bcfb7d1f830e6c8a8c2"><div class="ttname"><a href="qf_8hpp.html#adc8820f52d450bcfb7d1f830e6c8a8c2">QF_CRIT_EXIT_NOP</a></div><div class="ttdeci">#define QF_CRIT_EXIT_NOP()</div><div class="ttdoc">No-operation for exiting a critical section.</div><div class="ttdef"><b>Definition:</b> <a href="qf_8hpp_source.html#l00674">qf.hpp:674</a></div></div>
<div class="ttc" id="aqf__act_8cpp_html_a2ace22134b54e4fd206cf1846af96b4f"><div class="ttname"><a href="qf__act_8cpp.html#a2ace22134b54e4fd206cf1846af96b4f">QF_LOG2</a></div><div class="ttdeci">std::uint_fast8_t QF_LOG2(QP::QPSetBits x) noexcept</div><div class="ttdoc">function that returns (log2(x) + 1), where x is a 32-bit bitmask</div><div class="ttdef"><b>Definition:</b> <a href="qf__act_8cpp_source.html#l00151">qf_act.cpp:151</a></div></div>
<div class="ttc" id="aqk_2qf__port_8hpp_html_a55ad39820bd5eb29621a4bb4e03be884"><div class="ttname"><a href="qk_2qf__port_8hpp.html#a55ad39820bd5eb29621a4bb4e03be884">QF_CRIT_ENTRY</a></div><div class="ttdeci">#define QF_CRIT_ENTRY(stat_)</div><div class="ttdef"><b>Definition:</b> <a href="qk_2qf__port_8hpp_source.html#l00048">qk/qf_port.hpp:48</a></div></div>
<div class="ttc" id="aqk_2qf__port_8hpp_html_a88df5203e3a9716327b58923f5aaac80"><div class="ttname"><a href="qk_2qf__port_8hpp.html#a88df5203e3a9716327b58923f5aaac80">QF_INT_DISABLE</a></div><div class="ttdeci">#define QF_INT_DISABLE()</div><div class="ttdef"><b>Definition:</b> <a href="qk_2qf__port_8hpp_source.html#l00043">qk/qf_port.hpp:43</a></div></div>
<div class="ttc" id="aqk_2qf__port_8hpp_html_ac26964ee79ab7d340d046cc7dbf5251e"><div class="ttname"><a href="qk_2qf__port_8hpp.html#ac26964ee79ab7d340d046cc7dbf5251e">QF_CRIT_EXIT</a></div><div class="ttdeci">#define QF_CRIT_EXIT(stat_)</div><div class="ttdef"><b>Definition:</b> <a href="qk_2qf__port_8hpp_source.html#l00049">qk/qf_port.hpp:49</a></div></div>
<div class="ttc" id="aqk_2qf__port_8hpp_html_ad2d11956704ad838c9c954368d3d37d5"><div class="ttname"><a href="qk_2qf__port_8hpp.html#ad2d11956704ad838c9c954368d3d37d5">QF_INT_ENABLE</a></div><div class="ttdeci">#define QF_INT_ENABLE()</div><div class="ttdef"><b>Definition:</b> <a href="qk_2qf__port_8hpp_source.html#l00044">qk/qf_port.hpp:44</a></div></div>
<div class="ttc" id="aqxk_2qf__port_8hpp_html_a776d2a032974db4bf9bcfde01ace1389"><div class="ttname"><a href="qxk_2qf__port_8hpp.html#a776d2a032974db4bf9bcfde01ace1389">QF_MAX_ACTIVE</a></div><div class="ttdeci">#define QF_MAX_ACTIVE</div><div class="ttdoc">The maximum number of active objects in the application.</div><div class="ttdef"><b>Definition:</b> <a href="qxk_2qf__port_8hpp_source.html#l00057">qxk/qf_port.hpp:57</a></div></div>
</div><!-- fragment --><ul class="tag">
<li>
<p class="startli"><span class="tag">1</span> The <a class="el" href="qxk_2qf__port_8hpp.html#a776d2a032974db4bf9bcfde01ace1389" title="The maximum number of active objects in the application.">QF_MAX_ACTIVE</a> specifies the maximum number of active object priorities in the application. You always need to provide this constant. Here, <a class="el" href="qxk_2qf__port_8hpp.html#a776d2a032974db4bf9bcfde01ace1389" title="The maximum number of active objects in the application.">QF_MAX_ACTIVE</a> is set to 32, but it can be increased up to the maximum limit of 63 active object priorities in the system.</p>
<blockquote class="doxtable">
<p><b>NOTE:</b> The <code>qf_port.h</code> header file does not change the default settings for all the rest of various object sizes inside QF. Please refer to Chapter 8 of [PSiCC2] for discussion of all configurable QF parameters. </p>
</blockquote>
</li>
<li>
<span class="tag">2</span> The #QF_MAX_TICK_RATE specifies the maximum number of clock tick rates for <a class="el" href="namespace_q_p.html" title="namespace associated with the QP/C++ framework">QP</a> time events. If you don't need to specify this limit, in which case the default of a single clock rate will be chosen.  </li>
<li>
<p class="startli"><span class="tag">3</span> As described in the previous <a class="el" href="arm-cm.html#arm-cm_int">Section</a>, the interrupt disabling policy for the ARMv6-M architecture (Cortex-M0/M0+) is different than the policy for the ARMv7-M. In GNU-ARM, the macro <code>__ARM_ARCH</code> is defined as 6 for the ARMv6-M architecture (Cortex-M0/M0+), and 7 for ARMv7-M (Cortex-M3/M4/M4F).</p>
<blockquote class="doxtable">
<p><b>NOTE:</b> The <code>__ARM_ARCH</code> macro is specific to the GNU-ARM compiler. Other compilers for ARM Cortex-M provide different macros to detect the CPU type. </p>
</blockquote>
</li>
<li>
<span class="tag">4-5</span> For the ARMv6-M architecture, the interrupt disabling policy uses the PRIMASK register to disable interrupts globally. The <code><a class="el" href="qk_2qf__port_8hpp.html#a88df5203e3a9716327b58923f5aaac80">QF_INT_DISABLE()</a></code> macro resolves in this case to the inline assembly instruction "CPSD i", which sets the PRIMASK. The <code><a class="el" href="qk_2qf__port_8hpp.html#ad2d11956704ad838c9c954368d3d37d5">QF_INT_ENABLE()</a></code> macro resolves to the inline assembly instruction "CPSE i", which clears the PRIMASK.  </li>
<li>
<p class="startli"><span class="tag">6</span> The <a class="el" href="qxk_2qf__port_8hpp.html#a0f6f77bdc9a431c5a74be2162fd106fa" title="Define the type of the critical section status.">QF_CRIT_STAT_TYPE</a> is <b>NOT</b> defined, meaning that the critical section uses the simple policy of "unconditional interrupt disablin".</p>
<blockquote class="doxtable">
<p><b>NOTE:</b> The "unconditional interrupt disabling" policy precludes nesting of critical sections, but this is not needed for ARM Cortex-M, because this CPU never disables interrupts, even when handling exceptions/interrupts. </p>
</blockquote>
</li>
<li>
<span class="tag">7</span> The <a class="el" href="qk_2qf__port_8hpp.html#a55ad39820bd5eb29621a4bb4e03be884">QF_CRIT_ENTRY()</a> enters a critical section. Interrupts are disabled by setting the PRIMASK register.  </li>
<li>
<span class="tag">8</span> The <a class="el" href="qk_2qf__port_8hpp.html#ac26964ee79ab7d340d046cc7dbf5251e">QF_CRIT_EXIT()</a> macro leaves the critical section. Interrupts are unconditionally re-enabled by clearing the PRIMASK register.  </li>
<li>
<span class="tag">9</span> For the ARMv6-M architecture, the <code>QF_AWARE_ISR_CMSIS_PRI</code> priority level is defined as zero, meaning that all interrupts are "kernel-aware", because all interrupt priorities are disabled by the kernel.  </li>
<li>
<p class="startli"><span class="tag">10</span> The <code><a class="el" href="qf__act_8cpp.html#a2ace22134b54e4fd206cf1846af96b4f" title="function that returns (log2(x) + 1), where x is a 32-bit bitmask">QF_LOG2()</a></code> macro is defined as a call to the function <code>QF_qlog2()</code> ("quick log-base-2 logarithm"). This function is coded in hand-optimized assembly, which always takes only 14 CPU cycles to execute (see also label [23]).</p>
<blockquote class="doxtable">
<p><b>NOTE:</b> ARM Cortex-M0/M0+ does NOT implement the <code>CLZ</code> instruction. Therefore the log-base-2 calculation cannot be accelerated in hardware, as it is for ARM Cortex-M3 and higher. </p>
</blockquote>
</li>
<li>
<span class="tag">11</span> For the ARMv7-M (Cortex-M3/M4/M4F) architecture...  </li>
<li>
<span class="tag">12</span> The <code>QF_PRIMASK_DISABLE()</code> macro resolves to the inline assembly instruction <code>CPSD i</code>, which sets the PRIMASK.  </li>
<li>
<span class="tag">13</span> The <code>QF_PRIMASK_ENABLE()</code> macro resolves to the inline assembly instruction <code>CPSE i</code>, which clears the PRIMASK.  </li>
<li>
<p class="startli"><span class="tag">14</span> Interrupts are disabled by setting the BASEPRI register to the value defined in the <code>QF_BASEPRI</code> macro (see label [19]). This setting of the BASEPRI instruction <code>msr BASEPRI,...</code> is surrounded by setting and clearing the PRIMASK register, as a workaround a hardware problem in ARM Cortex-M7 core r0p1:</p>
<blockquote class="doxtable">
<p><b>NOTE:</b> The selective disabling of "QF-aware" interrupts with the BASEPRI register has a problem on ARM Cortex-M7 core r0p1 (see [<a class="el" href="arm-cm.html#ARM-AT610-611">ARM-AT610-611</a>], Erratum 837070). The workaround recommended by ARM is to surround <code>MSR BASEPRI,...</code> with the <code>CPSID i</code>/<code>CPSIE i</code> pair, which is implemented in the <a class="el" href="qk_2qf__port_8hpp.html#a88df5203e3a9716327b58923f5aaac80">QF_INT_DISABLE()</a> macro. This workaround works also for Cortex-M3/M4 cores. </p>
</blockquote>
</li>
<li>
<p class="startli"><span class="tag">15</span> The <code><a class="el" href="qk_2qf__port_8hpp.html#ad2d11956704ad838c9c954368d3d37d5">QF_INT_ENABLE()</a></code> macro sets the BASEPRI register to zero, which disables BASEPRI interrupt masking.</p>
<blockquote class="doxtable">
<p><b>NOTE:</b> this method can never disable interrupt of priority 0 (highest). </p>
</blockquote>
</li>
<li>
<p class="startli"><span class="tag">16</span> The <a class="el" href="qxk_2qf__port_8hpp.html#a0f6f77bdc9a431c5a74be2162fd106fa" title="Define the type of the critical section status.">QF_CRIT_STAT_TYPE</a> is <b>NOT</b> defined, meaning that the critical section uses the simple policy of "unconditional interrupt disabling".</p>
<blockquote class="doxtable">
<p><b>NOTE:</b> The "unconditional interrupt disabling" policy precludes nesting of critical sections, but this is not needed for ARM Cortex-M, because this CPU never disables interrupts, even when handling exceptions/interrupts. </p>
</blockquote>
</li>
<li>
<span class="tag">17</span> The <a class="el" href="qk_2qf__port_8hpp.html#a55ad39820bd5eb29621a4bb4e03be884">QF_CRIT_ENTRY()</a> enters a critical section. Interrupts are disabled with the macro <code><a class="el" href="qk_2qf__port_8hpp.html#a88df5203e3a9716327b58923f5aaac80">QF_INT_DISABLE()</a></code> defined at label [12].  </li>
<li>
<span class="tag">18</span> The <a class="el" href="qk_2qf__port_8hpp.html#ac26964ee79ab7d340d046cc7dbf5251e">QF_CRIT_EXIT()</a> macro leaves the critical section. Interrupts are unconditionally re-enabled with the macro <code><a class="el" href="qk_2qf__port_8hpp.html#ad2d11956704ad838c9c954368d3d37d5">QF_INT_ENABLE()</a></code> defined at label [13].  </li>
<li>
<span class="tag">19</span> <a class="anchor" id="QF_BASEPRI"></a>The <code>QF_BASEPRI</code> value is defined such that it is the lowest priority for the minimum number of 3 priority-bits that the ARM7-M architecture must provide. This partitions the interrupts as "kernel-unaware" and "kernel-aware" interrupts, as shown in section <a class="el" href="arm-cm.html#arm-cm_int-assign">Assigning Interrupt Priorities</a>.  </li>
<li>
<span class="tag">20</span> For the ARMv7-M architecture, the <code>QF_AWARE_ISR_CMSIS_PRI</code> priority level suitable for the CMSIS function <code>NVIC_SetPriority()</code> is determined by the <code>QF_BASEPRI</code> value.  </li>
<li>
<p class="startli"><span class="tag">21</span> The macro <code><a class="el" href="qf__act_8cpp.html#a2ace22134b54e4fd206cf1846af96b4f" title="function that returns (log2(x) + 1), where x is a 32-bit bitmask">QF_LOG2()</a></code> is defined to take advantage of the CLZ instruction (Count Leading Zeroes), which is available in the ARMv7-M architecture.</p>
<blockquote class="doxtable">
<p><b>NOTE:</b> The <code>__builtin_cls()</code> intrinsic function is specific to the GNU-ARM compiler. Other compilers for ARM Cortex-M use different function names for this intrinsic function. </p>
</blockquote>
</li>
<li>
<span class="tag">22</span> The macro <code><a class="el" href="qf_8hpp.html#adc8820f52d450bcfb7d1f830e6c8a8c2" title="No-operation for exiting a critical section.">QF_CRIT_EXIT_NOP()</a></code> provides the protection against merging two critical sections occurring back-to-back in the <a class="el" href="namespace_q_p.html" title="namespace associated with the QP/C++ framework">QP</a> code.  </li>
<li>
<span class="tag">23</span> For ARMv6 architecture, the prototype of the quick, hand-optimized log-base-2 function is provided (see also label [10]).  </li>
</ul>
<h1><a class="anchor" id="arm-cm_qv_port_h"></a>
The qv_port.h Header File</h1>
<p>The QV header file for the ARM Cortex-M port is located in <span class="img file_h">/ports/arm-cm/qv/gnu/qv_port.h</span>. This file provides the macro <a class="el" href="qv__port_8hpp.html#a63d09440889262e482687c417690fea4" title="Macro to put the CPU to sleep safely in the cooperative.">QV_CPU_SLEEP()</a>, which specifies how to enter the CPU sleep mode safely in the cooperative QV kernel (see also Section 4.7) and [Samek 07]).</p>
<dl class="section note"><dt>Note</dt><dd>To avoid race conditions between interrupts waking up active objects and going to sleep, the cooperative QV kernel calls the <a class="el" href="qv__port_8hpp.html#a63d09440889262e482687c417690fea4" title="Macro to put the CPU to sleep safely in the cooperative.">QV_CPU_SLEEP()</a> callback with interrupts disabled.</dd></dl>
<p><a class="anchor" id="arm-cm_qv_port_h-code"></a><b>Listing: The qv_port.h header file for ARM Cortex-M</b> </p><div class="fragment"><div class="line"><span class="preprocessor">    #ifdef ARM_ARCH_V6M </span><span class="comment">/* Cortex-M0/M0+/M1 ? */</span><span class="preprocessor"></span></div>
<div class="line"> </div>
<div class="line">[1]     #define <a class="code" href="qv__port_8hpp.html#a63d09440889262e482687c417690fea4">QV_CPU_SLEEP</a>() do { \</div>
<div class="line">            __asm <span class="keyword">volatile</span> (<span class="stringliteral">&quot;wfi&quot;</span>); \</div>
<div class="line">            QF_INT_ENABLE(); \</div>
<div class="line">        } <span class="keywordflow">while</span> (0)</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">    #else </span><span class="comment">/* Cortex-M3/M4/M7 */</span><span class="preprocessor"></span></div>
<div class="line"> </div>
<div class="line">[2]     #define <a class="code" href="qv__port_8hpp.html#a63d09440889262e482687c417690fea4">QV_CPU_SLEEP</a>() do { \</div>
<div class="line">            QF_PRIMASK_DISABLE(); \</div>
<div class="line">            QF_INT_ENABLE(); \</div>
<div class="line">            __asm <span class="keyword">volatile</span> (<span class="stringliteral">&quot;wfi&quot;</span>); \</div>
<div class="line">            QF_RIMASK_ENABLE(); \</div>
<div class="line">        } <span class="keywordflow">while</span> (0)</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">    #endif</span></div>
<div class="line"> </div>
<div class="line">[3] #define QV_INIT() QV_init()</div>
<div class="line">    <span class="keywordtype">void</span> QV_init();</div>
<div class="line"> </div>
<div class="line">    <span class="preprocessor">#include &quot;qv.h&quot;</span> <span class="comment">/* QV platform-independent public interface */</span><span class="preprocessor"></span></div>
<div class="ttc" id="aqv__port_8hpp_html_a63d09440889262e482687c417690fea4"><div class="ttname"><a href="qv__port_8hpp.html#a63d09440889262e482687c417690fea4">QV_CPU_SLEEP</a></div><div class="ttdeci">#define QV_CPU_SLEEP()</div><div class="ttdoc">Macro to put the CPU to sleep safely in the cooperative.</div><div class="ttdef"><b>Definition:</b> <a href="qv__port_8hpp_source.html#l00052">qv_port.hpp:52</a></div></div>
</div><!-- fragment --><ul class="tag">
<li>
<span class="tag">1</span> For the ARMv6-M architecture, the macro <code><a class="el" href="qv__port_8hpp.html#a63d09440889262e482687c417690fea4" title="Macro to put the CPU to sleep safely in the cooperative.">QV_CPU_SLEEP()</a></code> stops the CPU with the WFI instruction (Wait For Interrupt). After the CPU is woken up by an interrupt, interrupts are re-enabled with the PRIMASK.  </li>
<li>
<span class="tag">2</span> For the ARMv7-M architecture, the macro <code><a class="el" href="qv__port_8hpp.html#a63d09440889262e482687c417690fea4" title="Macro to put the CPU to sleep safely in the cooperative.">QV_CPU_SLEEP()</a></code> first disables interrupts by setting the PRIMASK, then clears the BASEPRI to enable all "kernel-aware" interrupts and only then stops the CPU with the WFI instruction (Wait For Interrupt). After the CPU is woken up by an interrupt, interrupts are re-enabled with the PRIMASK. This sequence is necessary, because the ARM Cortex-M3/M4/M7 cores cannot be woken up by any interrupt blocked by the BASEPRI register.  </li>
<li>
<span class="tag">2</span> The macro <code>QV_INIT()</code> is defined as a call to the <code>QV_init()</code> function, which means that this function will be called from <code>QF_init()</code>. The <code>QV_init()</code> function initializes all available IRQ priorities in the MCU to the safe value of <a class="el" href="arm-cm_qv.html#QF_BASEPRI">QF_BASEPRI</a>.  </li>
</ul>
<h1><a class="anchor" id="arm-cm_qv_port_c"></a>
The qv_port.c Implementation File</h1>
<p>The QV implementation file for the ARM Cortex-M port is located in <span class="img file_c">/ports/arm-cm/qv/gnu/qf_port.c</span>. This file defines the function <code>QV_init()</code>, which for the ARMv7-M architecture sets the interrupt priorities of all IRQs to the safe value <a class="el" href="arm-cm_qv.html#QF_BASEPRI">QF_BASEPRI</a>.</p>
<p><a class="anchor" id="arm-cm_qv_port_c-code"></a><b>Listing: The qv_port.c header file for ARM Cortex-M</b> </p><div class="fragment"><div class="line"><span class="preprocessor">    #include &quot;qf_port.h&quot;</span></div>
<div class="line"> </div>
<div class="line">[1] #<span class="keywordflow">if</span> (__ARM_ARCH != 6) <span class="comment">/* NOT Cortex-M0/M0+/M1 ? */</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">    #define SCnSCB_ICTR  ((uint32_t volatile *)0xE000E004)</span></div>
<div class="line"><span class="preprocessor">    #define SCB_SYSPRI   ((uint32_t volatile *)0xE000ED14)</span></div>
<div class="line"><span class="preprocessor">    #define NVIC_IP      ((uint32_t volatile *)0xE000E400)</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> QV_init(<span class="keywordtype">void</span>) {</div>
<div class="line">        <a class="code" href="16bit_2stdint_8h.html#a33594304e786b158f3fb30289278f5af">uint32_t</a> n;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* set exception priorities to QF_BASEPRI...</span></div>
<div class="line"><span class="comment">        * SCB_SYSPRI1: Usage-fault, Bus-fault, Memory-fault</span></div>
<div class="line"><span class="comment">        */</span></div>
<div class="line">[2]     SCB_SYSPRI[1] |= (QF_BASEPRI &lt;&lt; 16) | (QF_BASEPRI &lt;&lt; 8) | QF_BASEPRI;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* SCB_SYSPRI2: SVCall */</span></div>
<div class="line">[3]     SCB_SYSPRI[2] |= (QF_BASEPRI &lt;&lt; 24);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* SCB_SYSPRI3:  SysTick, PendSV, Debug */</span></div>
<div class="line">[4]     SCB_SYSPRI[3] |= (QF_BASEPRI &lt;&lt; 24) | (QF_BASEPRI &lt;&lt; 16) | QF_BASEPRI;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* set all implemented IRQ priories to QF_BASEPRI... */</span></div>
<div class="line">[5]     n = 8 + (*SCnSCB_ICTR &lt;&lt; 3); <span class="comment">/* # interrupt priority registers */</span></div>
<div class="line">        <span class="keywordflow">do</span> {</div>
<div class="line">            --n;</div>
<div class="line">[6]         NVIC_IP[n] = (QF_BASEPRI &lt;&lt; 24) | (QF_BASEPRI &lt;&lt; 16)</div>
<div class="line">                         | (QF_BASEPRI &lt;&lt; 8) | QF_BASEPRI;</div>
<div class="line">        } <span class="keywordflow">while</span> (n != 0);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">    #endif </span><span class="comment">/* NOT Cortex-M0/M0+/M1 */</span><span class="preprocessor"></span></div>
</div><!-- fragment --><ul class="tag">
<li>
<span class="tag">1</span> For the ARMv7-M architecture (Cortex-M3/M4/M7)...  </li>
<li>
<span class="tag">2</span> The exception priorities for User-Fault, Bus-Fault, and Mem-Fault are set to the value <a class="el" href="arm-cm_qv.html#QF_BASEPRI">QF_BASEPRI</a>.  </li>
<li>
<span class="tag">3</span> The exception priority for SVCCall is set to the value <a class="el" href="arm-cm_qv.html#QF_BASEPRI">QF_BASEPRI</a>.  </li>
<li>
<span class="tag">4</span> The exception priority for SysTick, PendSV, and Debug is set to the value <a class="el" href="arm-cm_qv.html#QF_BASEPRI">QF_BASEPRI</a>.  </li>
<li>
<span class="tag">5</span> The number of implemented IRQs is read from the <code>SCnSCB_ICTR</code> register  </li>
<li>
<span class="tag">6</span> The interrupt priority of all implemented IRQs is set to the safe value <a class="el" href="arm-cm_qv.html#QF_BASEPRI">QF_BASEPRI</a> in a loop.  </li>
</ul>
<h1><a class="anchor" id="arm-cm_qv-isr"></a>
Writing ISRs for QV</h1>
<p>The ARM Cortex-M CPU is designed to use regular C functions as exception and interrupt service routines (ISRs).</p>
<dl class="section note"><dt>Note</dt><dd>The ARM EABI (Embedded Application Binary Interface) requires the stack be 8-byte aligned, whereas some compilers guarantee only 4-byte alignment. For that reason, some compilers (e.g., GNU-ARM) provide a way to designate ISR functions as interrupts. For example, the GNU-ARM compiler provides the <b>attribute</b>((<b>interrupt</b>)) designation that will guarantee the 8-byte stack alignment.</dd></dl>
<p>Typically, ISRs are application-specific (with the main purpose to produce events for active objects). Therefore, ISRs are not part of the generic <a class="el" href="namespace_q_p.html" title="namespace associated with the QP/C++ framework">QP</a> port, but rather part of the BSP (Board Support Package).</p>
<p>The following listing shows an example of the SysTick_Handler() ISR (from the DPP example application). This ISR calls the QF_TICK_X() macro to perform QF time-event management.</p>
<p><a class="anchor" id="arm-cm_qv-isr-code"></a><b>Listing: An ISR header for QV</b> </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> SysTick_Handler(<span class="keywordtype">void</span>) __attribute__((__interrupt__));</div>
<div class="line"><span class="keywordtype">void</span> SysTick_Handler(<span class="keywordtype">void</span>) {</div>
<div class="line">     ~ ~ ~</div>
<div class="line">     QF_TICK_X(0U, &amp;l_SysTick_Handler); <span class="comment">/* process all armed time events */</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The <a class="el" href="namespace_q_p.html" title="namespace associated with the QP/C++ framework">QP</a> port to ARM Cortex-M complies with the CMSIS standard, which dictates the names of all exception handlers and IRQ handlers.</dd></dl>
<h1><a class="anchor" id="arm-cm_qv-fpu"></a>
Using the FPU in the QV Port (Cortex-M4F/M7)</h1>
<p>If you have the Cortex-M4/M7 CPU and your application uses the hardware FPU, it should be enabled because it is turned off out of reset. The CMSIS-compliant way of turning the FPU on looks as follows:</p>
<pre class="fragment">    SCB-&gt;CPACR |= (0xFU &lt;&lt; 20);
</pre><dl class="section note"><dt>Note</dt><dd>The FPU must be enabled before executing any floating point instruction. An attempt to execute a floating point instruction will fault if the FPU is not enabled.</dd></dl>
<p>Depending on whether or not you use the FPU in your ISRs, the QV port allows you to configure the FPU in various ways, as described in the following sub-sections.</p>
<h2><a class="anchor" id="arm-cm_qv-fpu_noisr"></a>
FPU NOT used in the ISRs</h2>
<p>If you use the FPU only at the thread-level (inside active objects) and none of your ISRs use the FPU, you can setup the FPU not to use the automatic state preservation and not to use the lazy stacking feature as follows:</p>
<pre class="fragment">    FPU-&gt;FPCCR &amp;= ~((1U &lt;&lt; FPU_FPCCR_ASPEN_Pos) | (1U &lt;&lt; FPU_FPCCR_LSPEN_Pos));
</pre><p>With this setting, the Cortex-M4F processor handles the ISRs in the exact-same way as Cortex-M0-M3, that is, only the standard interrupt frame with R0-R3,R12,LR,PC,xPSR is used. This scheme is the fastest and incurs no additional CPU cycles to save and restore the FPU registers.</p>
<dl class="section note"><dt>Note</dt><dd>This FPU setting will lead to FPU errors, if any of the ISRs indeed starts to use the FPU</dd></dl>
<h2><a class="anchor" id="arm-cm_qv-fpu_isr"></a>
FPU used in the ISRs</h2>
<p>If you use the FPU both at the thread-level (inside active objects) and in any of your ISRs as well, you should setup the FPU to use the automatic state preservation and the lazy stacking feature as follows:</p>
<pre class="fragment">    FPU-&gt;FPCCR |= (1U &lt;&lt; FPU_FPCCR_ASPEN_Pos) | (1U &lt;&lt; FPU_FPCCR_LSPEN_Pos);
</pre><p>This will enable the lazy stacking feature of the Cortex-M4F/M7 processor [<a class="el" href="arm-cm.html#ARM-AN298">ARM-AN298</a>]. The the "automatic state saving" and "lazy stacking" are enabled by default, so you typically don't need to change these settings.</p>
<dl class="section note"><dt>Note</dt><dd>As described in the ARM Application Note "Cortex-M4(F) Lazy Stacking and Context Switching" [<a class="el" href="arm-cm.html#ARM-AN298">ARM-AN298</a>], the FPU automatic state saving requires more stack plus additional CPU time to save the FPU registers, but only when the FPU is actually used.</dd></dl>
<h1><a class="anchor" id="arm-cm_qv-idle"></a>
QV Idle Processing Customization in QV_onIdle()</h1>
<p>When no events are available, the non-preemptive QV kernel invokes the platform-specific callback function QV_onIdle(), which you can use to save CPU power, or perform any other "idle" processing (such as Quantum Spy software trace output).</p>
<dl class="section note"><dt>Note</dt><dd>The idle callback QV_onIdle() must be invoked with interrupts disabled, because the idle condition can be changed by any interrupt that posts events to event queues. QV_onIdle() must internally enable interrupts, ideally atomically with putting the CPU to the power-saving mode (see also [Samek 07] and Chapter 7 in [PSiCC2]).</dd></dl>
<p>Because QV_onIdle() must enable interrupts internally, the signature of the function depends on the interrupt locking policy. In case of the simple "unconditional interrupt locking and unlocking" policy, which is used in this ARM Cortex-M port, the QV_onIdle() takes no parameters. Listing 6 shows an example implementation of QV_onIdle() for the TM4C MCU. Other ARM Cortex-M embedded microcontrollers (e.g., NXP‚Äôs LPC1114/1343) handle the power-saving mode very similarly.</p>
<p><a class="anchor" id="arm-cm_qv_onidle-code"></a><b>Listing: QV_onIdle() for ARM Cortex-M</b> </p><div class="fragment"><div class="line">[1] <span class="keywordtype">void</span> QV_onIdle(<span class="keywordtype">void</span>) { <span class="comment">/* entered with interrupts DISABLED, see NOTE01 */</span></div>
<div class="line">        ~ ~ ~</div>
<div class="line">[2] #<span class="keywordflow">if</span> defined NDEBUG</div>
<div class="line">        <span class="comment">/* Put the CPU and peripherals to the low-power mode */</span></div>
<div class="line">[3]     <a class="code" href="qv__port_8hpp.html#a63d09440889262e482687c417690fea4">QV_CPU_SLEEP</a>(); <span class="comment">/* atomically go to sleep and enable interrupts */</span></div>
<div class="line"><span class="preprocessor">    #else</span></div>
<div class="line">[4]     <a class="code" href="qk_2qf__port_8hpp.html#ad2d11956704ad838c9c954368d3d37d5">QF_INT_ENABLE</a>(); <span class="comment">/* just enable interrupts */</span></div>
<div class="line"><span class="preprocessor">    #endif</span></div>
<div class="line"><span class="preprocessor">    }</span></div>
</div><!-- fragment --><ul class="tag">
<li>
<span class="tag">1</span> The cooperative QV kernel calls the QV_onIdle() callback with interrupts disabled, to avoid race condition with interrupts that can post events to active objects and thus invalidate the idle condition.  </li>
<li>
<span class="tag">2</span> The sleep mode is used only in the non-debug configuration, because sleep mode stops CPU clock, which can interfere with debugging.  </li>
<li>
<span class="tag">3</span> The macro <a class="el" href="qv__port_8hpp.html#a63d09440889262e482687c417690fea4" title="Macro to put the CPU to sleep safely in the cooperative.">QV_CPU_SLEEP()</a> is used to put the CPU to the low-power sleep mode safely. The macro <a class="el" href="qv__port_8hpp.html#a63d09440889262e482687c417690fea4" title="Macro to put the CPU to sleep safely in the cooperative.">QV_CPU_SLEEP()</a> is defined in the qv_port.h header file for the QV kernel and depends on the interrupt disabling policy used.  </li>
<li>
<span class="tag">4</span> When a sleep mode is not used, the QV_onIdle() callback simply re-enables interrupts.  </li>
</ul>
<hr  />
<p><b>Next:</b> <a class="el" href="arm-cm_qk.html">Preemptive Non-Blocking QK Kernel</a></p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
    <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
      <ul>
        <li class="footer">
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; 2005-2021 Quantum Leaps</a> &nbsp;| &nbsp; <a title="help" href="help.html">Using Online Help</a>&nbsp;| &nbsp;<a title="Doxygen" href="http://www.doxygen.nl">Generated with Doxygen</a>&nbsp; | &nbsp;<b>QP/C++ 6.9.3</b>
<hr class="footer"/><address class="footer"><small>
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; Quantum Leaps 2020</a> &nbsp;| &nbsp; <a title="help" href="help.html">Using Online Help</a>&nbsp;| &nbsp;<a title="Doxygen" href="http://www.doxygen.nl">Generated with Doxygen</a>&nbsp; | &nbsp;<b>QP/C++ 6.9.3</b>
</small></address>
        </li>
      </ul>
    </div>
    <script src="custom.js"></script>
  </body>
</html>
