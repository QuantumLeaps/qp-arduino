<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QP/C++: QXK</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
  <a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">
    <img id="logo" src="img/logo_ql.png" alt="Quantum Leaps">
  </a>
  <span id="projectname">QP/C++</span>
  <span id="projectnumber">6.9.3</span>
           <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)"
               onblur="searchBox.OnSearchFieldFocus(false)"
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;"
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__qxk.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0"
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a>  </div>
  <div class="headertitle">
<div class="title">QXK</div>  </div>
</div><!--header-->
<div class="contents">

<p>Preemptive Dual-Mode (Run-to-Completion/Blocking) RTOS Kernel.
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for QXK:</div>
<div class="dyncontent">
<div class="center"><img src="group__qxk.png" border="0" usemap="#agroup____qxk" alt=""/></div>
<map name="agroup____qxk" id="agroup____qxk">
<area shape="rect" href="group__qep.html" title="Hierarchical Event Processor." alt="" coords="163,14,213,39"/>
<area shape="rect" title="Preemptive Dual&#45;Mode (Run&#45;to&#45;Completion/Blocking) RTOS Kernel." alt="" coords="5,134,53,159"/>
<area shape="rect" href="group__qf.html" title="Active Object (Actor) Framework." alt="" coords="168,74,208,99"/>
<area shape="rect" href="group__qk.html" title="Preemptive Run&#45;To&#45;Completion (Non&#45;Blocking) Kernel." alt="" coords="167,134,209,159"/>
<area shape="rect" href="group__qs.html" title="Software Tracing Instrumentation." alt="" coords="167,194,209,219"/>
<area shape="rect" href="group__qv.html" title="Cooperative Kernel." alt="" coords="167,254,209,279"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:qpcpp_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qpcpp_8h.html">qpcpp.h</a></td></tr>
<tr class="memdesc:qpcpp_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">QP/C++ public interface old-version for backwards-compatibility. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:qpcpp_8hpp"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qpcpp_8hpp.html">qpcpp.hpp</a></td></tr>
<tr class="memdesc:qpcpp_8hpp"><td class="mdescLeft">&#160;</td><td class="mdescRight">QP/C++ public interface including backwards-compatibility layer. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:qxk_8hpp"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qxk_8hpp.html">qxk.hpp</a></td></tr>
<tr class="memdesc:qxk_8hpp"><td class="mdescLeft">&#160;</td><td class="mdescRight">QXK/C++ preemptive extended (blocking) kernel, platform-independent public interface. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:qxthread_8hpp"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qxthread_8hpp.html">qxthread.hpp</a></td></tr>
<tr class="memdesc:qxthread_8hpp"><td class="mdescLeft">&#160;</td><td class="mdescRight">QXK/C++ extended (blocking) thread. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:qxk_8cpp"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qxk_8cpp.html">qxk.cpp</a></td></tr>
<tr class="memdesc:qxk_8cpp"><td class="mdescLeft">&#160;</td><td class="mdescRight">QXK/C++ preemptive kernel core functions public interface. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:qxk__mutex_8cpp"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qxk__mutex_8cpp.html">qxk_mutex.cpp</a></td></tr>
<tr class="memdesc:qxk__mutex_8cpp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Priority-ceiling blocking mutex <a class="el" href="class_q_p_1_1_q_x_mutex.html" title="Priority Ceiling Mutex the QXK preemptive kernel.">QP::QXMutex</a> class definition. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:qxk__sema_8cpp"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qxk__sema_8cpp.html">qxk_sema.cpp</a></td></tr>
<tr class="memdesc:qxk__sema_8cpp"><td class="mdescLeft">&#160;</td><td class="mdescRight">QXK/C++ preemptive kernel counting semaphore implementation. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:qxk__xthr_8cpp"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qxk__xthr_8cpp.html">qxk_xthr.cpp</a></td></tr>
<tr class="memdesc:qxk__xthr_8cpp"><td class="mdescLeft">&#160;</td><td class="mdescRight">QXK/C++ preemptive kernel extended (blocking) thread implementation. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:qxk__pkg_8hpp"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qxk__pkg_8hpp.html">qxk_pkg.hpp</a></td></tr>
<tr class="memdesc:qxk__pkg_8hpp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal (package scope) QXK/C++ interface. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:qxk__port_8hpp"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qxk__port_8hpp.html">qxk_port.hpp</a></td></tr>
<tr class="memdesc:qxk__port_8hpp"><td class="mdescLeft">&#160;</td><td class="mdescRight">QXK/C++ port example, Generic C++ compiler. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Preemptive Dual-Mode (Run-to-Completion/Blocking) RTOS Kernel. </p>
<p>QXK is a small, preemptive, priority-based, dual-mode <b>blocking</b> kernel that executes active objects like the <a class="el" href="group__qk.html">QK kernel</a> (<a class="el" href="group__qxk.html#qxk_basic">basic threads</a>), but can also execute traditional <b>blocking</b> threads (<a class="el" href="group__qxk.html#qxk_extended">extended threads</a>). In this respect, QXK behaves exactly like a <b>conventional RTOS</b> (Real-Time Operating System).</p>
<p>QXK has been designed specifically for mixing event-driven active objects with traditional blocking code, such as commercial middleware (TCP/IP stacks, UDP stacks, embedded file systems, etc.) or legacy software. To this end, QXK is not only more efficient than running <a class="el" href="namespace_q_p.html" title="namespace associated with the QP/C++ framework">QP</a> on top of a <a class="el" href="ports_rtos.html">traditional 3rd-party RTOS</a> (because non-blocking <a class="el" href="group__qxk.html#qxk_basic">basic threads</a> take far less stack space and CPU cycles for context switch than the much heavier <a class="el" href="group__qxk.html#qxk_extended">extended threads</a>). But the biggest advantage of QXK is that it <b>protects</b> the application-level code from inadvertent mixing of blocking calls inside the event-driven active objects. Specifically, QXK "knows" the type of the thread context (extended/basic) and asserts internally if a blocking call (e.g., semaphore-wait or a time-delay) is attempted in a basic thread (active object). This is something that a <a class="el" href="namespace_q_p.html" title="namespace associated with the QP/C++ framework">QP</a> port to a <a class="el" href="ports_rtos.html">conventional 3rd-party RTOS</a> cannot do, because such an RTOS runs all code (including active objects) in the context of havyweight extended threads.</p>
<p>Currently, the QXK kernel has been ported to the following CPUs:</p>
<ul>
<li><a class="el" href="arm-cm_qxk.html">Cortex-M (M0/M0+/M1/M3/M4/M4F/M7)</a><br  />
Supported toolchains include: ARM-KEIL MDK, IAR-ARM, GNU-ARM, TI-ARM.</li>
</ul>
<p>Currently, the QXK kernel is illustrated by the following examples:</p>
<ul>
<li><a class="el" href="arm-cm_dpp_efm32-slstk3401a.html">DPP on EFM32-SLSTK3401A</a> (ARM Cortex-M4F)<br  />
Example illustrates: 6 active objects plus two extended threads, QXK blocking delay, QXK semaphore, QXK mutex, QXK blocking message queue.</li>
<li><a class="el" href="arm-cm_dpp_ek-tm4c123gxl.html">DPP on EK-TM4C123GXL</a> (ARM Cortex-M4F)<br  />
Example illustrates: 6 active objects plus two extended threads, QXK blocking delay, QXK semaphore, QXK mutex, QXK blocking message queue.</li>
<li><a class="el" href="arm-cm_dpp_nucleo-l053r8.html">DPP on NUCLEO-L053R8</a> (ARM Cortex-M0+)<br  />
Example illustrates: 6 active objects plus two extended threads, QXK blocking delay, QXK semaphore, QXK mutex, QXK blocking message queue.</li>
</ul>
<h1><a class="anchor" id="qxk_basic"></a>
Basic Threads</h1>
<p>QXK supports <b>basic</b>-threads (non-blocking, run-to-completion activations). The basic-threads all nest on the same stack (Main Stack Pointer in ARM Cortex-M), so the stack usage is reduced. The additional advantage of basic-threads is that switching from basic-thread to another basic-thread requires only <a class="el" href="qxk_8hpp.html#a6c1512e28d50b179aa627d74513cb242">activation</a> of the basic-thread, which is much simpler and faster than full context-switch required for <a class="el" href="group__qxk.html#qxk_extended">extended</a>-threads that QXK also supports (see below).</p>
<dl class="section remark"><dt>Remarks</dt><dd>QXK adopts the "basic/exteded thread" terms from the <a href="https://www.autosar.org" class="extern" target="_blank">OSEK/AUTOSAR Operating System</a> specification. Other real-time kernels might use different terminology for similar concepts. For example, the <a href="http://www.quasarsoft.com/" class="extern" target="_blank">Q-Kernel</a> uses the term "fibers", while <a href="http://www.ti.com/tool/TI-RTOS" class="extern" target="_blank">TI-RTOS</a> uses the term "software interrupts" for concepts closely related to "basic threads".</dd></dl>
<h1><a class="anchor" id="qxk_extended"></a>
Extended Threads</h1>
<p>QXK supports <b>extended</b>-threads (blocking, typically structrued as endless loops). The extended-threads use private per-thread stacks, as in conventional RTOS kernels. Any switching from basic-to-extended thread or extended-to-extended thread requires full context switch.</p>
<dl class="section remark"><dt>Remarks</dt><dd>QXK is a unique dual-mode kernel on the market that supports interleaving the priorities of basic threads and extended threads. Other dual-mode kernels typically limit the priorities of basic threads to be always higher (more urgent) than any of the extended threads.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_q_p_1_1_q_x_thread.html" title="Extended (blocking) thread of the QXK preemptive kernel.">QP::QXThread</a></dd></dl>
<h1><a class="anchor" id="qxk_classes"></a>
Classes in QXK</h1>
<p>The figure below shows the main classes introduced in the QXK kernel and their relation to the classes of the <a class="el" href="namespace_q_p.html" title="namespace associated with the QP/C++ framework">QP</a> framework.</p>
<div class="image">
<img src="qxk_classes.gif" alt=""/>
<div class="caption">
Classes of the QXK dual-mode kernel</div></div>
<ul class="tag">
<li>
<p class="startli"><span class="tag">0</span> The abstract <a class="el" href="class_q_p_1_1_q_active.html" title="QActive active object (based on QP::QHsm implementation)">QP::QActive</a> class represents active objects in <a class="el" href="namespace_q_p.html" title="namespace associated with the QP/C++ framework">QP</a>. This class contains the <code>thread</code> object of the underlying kernel (QXK thread-control-block in this case) as well as the event queue and the unique priority of the active object. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><span class="tag">1</span> The <a class="el" href="class_q_p_1_1_q_x_thread.html" title="Extended (blocking) thread of the QXK preemptive kernel.">QP::QXThread</a> class represents the extended (blocking) threads of the QXK kernel. It inherits <a class="el" href="class_q_p_1_1_q_active.html" title="QActive active object (based on QP::QHsm implementation)">QP::QActive</a>, so that extended-threads can be treated as active objects internally in the framework. However, the extended-threads do not implement state machines. Instead, the data fields used for storing the current state in active objects are re-used to store the private stack of the extended-thread. The <a class="el" href="class_q_p_1_1_q_x_thread.html" title="Extended (blocking) thread of the QXK preemptive kernel.">QP::QXThread</a> class also contains the <code>timeEvt</code> object (see <a class="el" href="class_q_p_1_1_q_time_evt.html" title="Time Event class.">QP::QTimeEvt</a>) for generating timeouts when the extended-thread is blocked. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><span class="tag">2</span> The <a class="el" href="class_q_p_1_1_q_x_mutex.html" title="Priority Ceiling Mutex the QXK preemptive kernel.">QP::QXMutex</a> class represents the <a class="el" href="class_q_p_1_1_q_x_mutex.html">priority-ceiling mutex</a> of the QXK kernel. The mutex can block and can be used only in the extended-threads and the QXK kernel would assert if an active object (basic thread) would attempt to lock a mutex. The mutex is recursive, meaning that it can be locked multiple times from the same extended thread (but it needs to be unlocked equal number of times). </p>
<blockquote class="doxtable">
<p><b>NOTE:</b> Both active objects and extended threads can use the non-blocking, <a class="el" href="class_q_p_1_1_q_x_k.html#a5c49ed626f6699644beec500fe028bbd">selective QXK scheduler locking</a> to protect shared resources. </p>
</blockquote>
</li>
<li>
<span class="tag">3</span> The <a class="el" href="class_q_p_1_1_q_x_semaphore.html" title="Counting Semaphore of the QXK preemptive kernel.">QP::QXSemaphore</a> class represents the <a class="el" href="class_q_p_1_1_q_x_semaphore.html">counting semaphore</a> of the QXK kernel. The semaphore can be waited on only in the extended threads and the QXK kernel would assert if an active object thread would attempt to wait on a semaphore. On the other hand, a semaphore can be signaled from anywhere in the code, including active objects and ISRs.  </li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The main takeaway from the QXK class diagram is QXK's <b>optimal, tight integration</b> with the <a class="el" href="namespace_q_p.html" title="namespace associated with the QP/C++ framework">QP</a> framework. The QXK kernel reuses all mechanisms already provided in <a class="el" href="namespace_q_p.html" title="namespace associated with the QP/C++ framework">QP</a>, thus avoiding any code duplication, inefficient layers of indirection, and additional licensing costs, which are inevitable when using <a class="el" href="ports_rtos.html">3rd-party RTOS kernels</a> to run <a class="el" href="namespace_q_p.html" title="namespace associated with the QP/C++ framework">QP</a> applications.</dd></dl>
<h1><a class="anchor" id="qxk_features"></a>
QXK Feature Summary</h1>
<p>As you can see in the list below, <span class="highlight">QXK provides most features you might expect of a traditional blocking <b>RTOS</b> kernel and is <b>recommended</b> as the preferred RTOS kernel for <a class="el" href="namespace_q_p.html" title="namespace associated with the QP/C++ framework">QP</a> applications</span> that need to mix active objects with traditional blocking code.</p>
<ul class="tag">
<li>
<p class="startli"><span class="bullet">&gt;</span>Preemptive, priority-based scheduling of up to 64 threads. Each thread must be assigned its own unique priority (1 .. <a class="el" href="qxk_2qf__port_8hpp.html#a776d2a032974db4bf9bcfde01ace1389" title="The maximum number of active objects in the application.">QF_MAX_ACTIVE</a>); </p>
<blockquote class="doxtable">
<p>NOTE: QXK always executes the highest-priority thread that is ready to run (is not blocked). The scheduling algorithm used in QXK meets all the requirement of the Rate Monotonic Scheduling (a.k.a. Rate Monotonic Analysis — RMA) and can be used in hard real-time systems. </p>
</blockquote>
</li>
<li>
<p class="startli"><span class="bullet">&gt;</span>QXK distinguishes between two types of threads: </p>
<ul>
<li><b>basic threads</b> of active objects that are made ready-to-run by events posted to the active objects. Such basic threads are non-blocking, run-to-completion activations that cannot block in the middle of the RTC step. QXK asserts when a basic thread attempts to use a blocking mechanism, such as a time-delay or a semaphore-wait. All basic threads share the common stack.</li>
<li><b>extended threads</b> that can block anywhere in their thread-handler function, whereas QXK provides a typical assortments of blocking primitives for extended-threads, such as time-delay, blocking message queue, counting semaphore, or a mutex. Each extended thread must be provided with its own private stack.</li>
</ul>
<p class="endli"></p>
</li>
<li>
<p class="startli"><span class="bullet">&gt;</span>Tightly integrated mechanisms for communication between event-driven active objects and extended blocking threads: </p>
<ul>
<li>Basic threads (Active Objects) can signal semaphores and send messages to extended threads.</li>
<li>Extended threads can post or publish events to active objects or other extended threads;</li>
<li>Extended threads can subscribe to events and thus can receive events published in the system.</li>
</ul>
<p class="endli"></p>
</li>
<li>
<p class="startli"><span class="bullet">&gt;</span>Priority-Ceiling, recursive Mutexes with optional timeout; </p>
<blockquote class="doxtable">
<p><b>NOTE:</b> Priority-ceiling protocol implemented in QXK is immune to priority-inversions, but requires a unique <a class="el" href="namespace_q_p.html" title="namespace associated with the QP/C++ framework">QP</a> thread priority level (the ceiling priority) to be assigned to the mutex. This ceiling priority is unavailable to <a class="el" href="namespace_q_p.html" title="namespace associated with the QP/C++ framework">QP</a> threads.<br  />
</p>
</blockquote>
<blockquote class="doxtable">
<p><b>NOTE:</b> A QXK mutex can be configured not to use the priority-ceiling protocol (when initialized with a zero priority-ceiling). In that case, the mutex does not require a separate priority level. </p>
</blockquote>
<p class="endli"></p>
</li>
<li>
<p class="startli"><span class="bullet">&gt;</span>Counting Semaphores with optional timeout that can block multiple extended-threads; </p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><span class="bullet">&gt;</span>Blocking "zero-copy" message queue with optional timeout bound to each extended-thread; </p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><span class="bullet">&gt;</span>Deterministic fixed-size memory pools for dynamic memory management available both to extended-threads and active objects; </p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><span class="bullet">&gt;</span>Interrupt management, including "zero-latency", kernel-unaware interrupts that are never disabled; </p>
<blockquote class="doxtable">
<p>NOTE: This feature is only supported on CPUs that allow selective interrupt disabling, such as ARM Cortex-M3/M4 (but not ARM Cortex-M0/M0+); </p>
</blockquote>
</li>
<li>
<p class="startli"><span class="bullet">&gt;</span> <a class="el" href="group__qxk.html#qxk_tls">Thread-Local Storage</a> for all threads (basic threads and extended threads). </p>
<p class="endli"></p>
</li>
</ul>
<h2><a class="anchor" id="qxk_tls"></a>
Thread Local Storage</h2>
<p><b>Thread-local storage (TLS)</b> is a programming method that uses static or global memory local to a thread. TLS is specifically useful for writing library-type code, which is used in a multithreaded environment and needs to access per-thread data in an independent way.</p>
<p>TLS is used in some places where ordinary, single-threaded programs would use static or global variables, but where this would be inappropriate in multithreaded cases. An example of such situations is where library-type functions use a global variable to set an error condition (for example the global variable errno used by many functions of the C library). If errno were simply a global variable, a call of a system function on one thread may overwrite the value previously set by a call of a system function on a different thread, possibly before following code on that different thread could check for the error condition. The solution is to have errno be a variable that looks like it is global, but in fact exists once per thread—i.e., it lives in <em>thread-local storage</em>. A second use case would be multiple threads accumulating information into a global variable. To avoid a race condition, every access to this global variable would have to be protected by a mutual-exclusion mechanism. Alternatively, each thread might accumulate into a thread-local variable (that, by definition, cannot be read from or written to from other threads, implying that there can be no race conditions). Threads then only have to synchronize a final accumulation from their own thread-local variable into a single, truly global variable.</p>
<p>The TLS implementations vary, but many systems, including QXK, implement TLS by providing a pointer-sized variable thread-local. This pointer can be set to arbitrarily sized memory blocks in a thread-local manner, by allocating such a memory block (statically or dynamically) and storing the memory address of that block in the thread-local variable.</p>
<p>Typical usage of TLS in QXK is illustrated in the example <span class="img folder">qpcpp/examples/arm-cm/dpp_efm32-slstk3401a/qxk/</span>, <span class="img file_cpp">test.cpp</span>, and consists:</p>
<ul>
<li>define the TLS structure <div class="fragment"><div class="line"><span class="keyword">struct </span>TLS_test {</div>
<div class="line">    <a class="code" href="16bit_2stdint_8h.html#a33594304e786b158f3fb30289278f5af">uint32_t</a> foo;</div>
<div class="line">    <a class="code" href="16bit_2stdint_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> bar[10];</div>
<div class="line">};</div>
<div class="ttc" id="a16bit_2stdint_8h_html_a33594304e786b158f3fb30289278f5af"><div class="ttname"><a href="16bit_2stdint_8h.html#a33594304e786b158f3fb30289278f5af">uint32_t</a></div><div class="ttdeci">unsigned long int uint32_t</div><div class="ttdoc">exact-width 32-bit unsigned int</div><div class="ttdef"><b>Definition:</b> <a href="16bit_2stdint_8h_source.html#l00031">16bit/stdint.h:31</a></div></div>
<div class="ttc" id="a16bit_2stdint_8h_html_aba7bc1797add20fe3efdf37ced1182c5"><div class="ttname"><a href="16bit_2stdint_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a></div><div class="ttdeci">unsigned char uint8_t</div><div class="ttdoc">exact-width 8-bit unsigned int</div><div class="ttdef"><b>Definition:</b> <a href="16bit_2stdint_8h_source.html#l00029">16bit/stdint.h:29</a></div></div>
</div><!-- fragment --></li>
<li>allocate the TLS storage for all participating threads (extended or basic threads) <div class="fragment"><div class="line"><span class="keyword">static</span> TLS_test l_tls1;</div>
<div class="line"><span class="keyword">static</span> TLS_test l_tls2;</div>
</div><!-- fragment --></li>
<li>initialize the TLS per-thread pointer in each thread routine (for extended threads) or the top-most initial transition (for basic threads of active objects): <div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> Thread1_run(<a class="code" href="class_q_p_1_1_q_x_thread.html">QP::QXThread</a> * <span class="keyword">const</span> me) {</div>
<div class="line">    me-&gt;m_thread = &amp;l_tls1; <span class="comment">// initialize the TLS for Thread1</span></div>
<div class="line">    . . .</div>
<div class="line">}</div>
<div class="line">. . .</div>
<div class="line">static <span class="keywordtype">void</span> Thread2_run(<a class="code" href="class_q_p_1_1_q_x_thread.html">QP::QXThread</a> * <span class="keyword">const</span> me) {</div>
<div class="line">    me-&gt;m_thread = &amp;l_tls2; <span class="comment">// initialize the TLS for Thread2</span></div>
<div class="line">    . . .</div>
<div class="line">}</div>
<div class="ttc" id="aclass_q_p_1_1_q_x_thread_html"><div class="ttname"><a href="class_q_p_1_1_q_x_thread.html">QP::QXThread</a></div><div class="ttdoc">Extended (blocking) thread of the QXK preemptive kernel.</div><div class="ttdef"><b>Definition:</b> <a href="qxthread_8hpp_source.html#l00066">qxthread.hpp:66</a></div></div>
</div><!-- fragment --></li>
<li>access the TLS from your code: <div class="fragment"><div class="line"><span class="keywordtype">void</span> lib_fun(<a class="code" href="16bit_2stdint_8h.html#a33594304e786b158f3fb30289278f5af">uint32_t</a> x) {</div>
<div class="line">    <a class="code" href="qxk_8hpp.html#a0c95c457d7b8d19f6588e1bb9f1af829">QXK_TLS</a>(TLS_test *)-&gt;foo = x;</div>
<div class="line">}</div>
<div class="ttc" id="aqxk_8hpp_html_a0c95c457d7b8d19f6588e1bb9f1af829"><div class="ttname"><a href="qxk_8hpp.html#a0c95c457d7b8d19f6588e1bb9f1af829">QXK_TLS</a></div><div class="ttdeci">#define QXK_TLS(type_)</div><div class="ttdoc">Access Thread-Local Storage (TLS) and cast it on the given type_.</div><div class="ttdef"><b>Definition:</b> <a href="qxk_8hpp_source.html#l00062">qxk.hpp:62</a></div></div>
</div><!-- fragment --></li>
</ul>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="qxk_8hpp.html#a256950f60e40a9e8aa63e7fd77133ed4" title="return the currently executing active-object/thread">QXK_current()</a></li>
<li><a class="el" href="qxk_8hpp.html#a0c95c457d7b8d19f6588e1bb9f1af829" title="Access Thread-Local Storage (TLS) and cast it on the given type_.">QXK_TLS()</a> </li>
</ul>
</dd></dl>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
    <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
      <ul>
        <li class="footer">
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; 2005-2021 Quantum Leaps</a> &nbsp;| &nbsp; <a title="help" href="help.html">Using Online Help</a>&nbsp;| &nbsp;<a title="Doxygen" href="http://www.doxygen.nl">Generated with Doxygen</a>&nbsp; | &nbsp;<b>QP/C++ 6.9.3</b>
<hr class="footer"/><address class="footer"><small>
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; Quantum Leaps 2020</a> &nbsp;| &nbsp; <a title="help" href="help.html">Using Online Help</a>&nbsp;| &nbsp;<a title="Doxygen" href="http://www.doxygen.nl">Generated with Doxygen</a>&nbsp; | &nbsp;<b>QP/C++ 6.9.3</b>
</small></address>
        </li>
      </ul>
    </div>
    <script src="custom.js"></script>
  </body>
</html>
